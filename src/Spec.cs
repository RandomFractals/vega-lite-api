// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var spec = Spec.FromJson(jsonString);

namespace QuickType
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Spec
    {
        /// <summary>
        /// URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you
        /// have a reason to change this, use `https://vega.github.io/schema/vega-lite/v3.json`.
        /// Setting the `$schema` property allows automatic validation and autocomplete in editors
        /// that support JSON schema.
        /// </summary>
        [JsonProperty("$schema", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Schema { get; set; }

        /// <summary>
        /// Sets how the visualization size should be determined. If a string, should be one of
        /// `"pad"`, `"fit"` or `"none"`.
        /// Object values can additionally specify parameters for content sizing and automatic
        /// resizing.
        /// `"fit"` is only supported for single and layered views that don't use `rangeStep`.
        ///
        /// __Default value__: `pad`
        /// </summary>
        [JsonProperty("autosize", NullValueHandling = NullValueHandling.Ignore)]
        public Autosize? Autosize { get; set; }

        /// <summary>
        /// CSS color property to use as the background of visualization.
        ///
        /// __Default value:__ none (transparent)
        /// </summary>
        [JsonProperty("background", NullValueHandling = NullValueHandling.Ignore)]
        public string Background { get; set; }

        /// <summary>
        /// Vega-Lite configuration object.  This property can only be defined at the top-level of a
        /// specification.
        /// </summary>
        [JsonProperty("config", NullValueHandling = NullValueHandling.Ignore)]
        public Config Config { get; set; }

        /// <summary>
        /// An object describing the data source
        /// </summary>
        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public Data Data { get; set; }

        /// <summary>
        /// A global data store for named datasets. This is a mapping from names to inline datasets.
        /// This can be an array of objects or primitive values or a string. Arrays of primitive
        /// values are ingested as objects with a `data` property.
        /// </summary>
        [JsonProperty("datasets", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, InlineDataset> Datasets { get; set; }

        /// <summary>
        /// Description of this mark for commenting purpose.
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A key-value mapping between encoding channels and definition of fields.
        ///
        /// A shared key-value mapping between encoding channels and definition of fields in the
        /// underlying layers.
        /// </summary>
        [JsonProperty("encoding", NullValueHandling = NullValueHandling.Ignore)]
        public Encoding Encoding { get; set; }

        /// <summary>
        /// The height of a visualization.
        ///
        /// __Default value:__
        /// - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type
        /// is `"fit"` or its y-channel has a [continuous
        /// scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the height will be
        /// the value of
        /// [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - For y-axis with a band or point scale: if
        /// [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value
        /// or unspecified, the height is [determined by the range step, paddings, and the
        /// cardinality of the field mapped to
        /// y-channel](https://vega.github.io/vega-lite/docs/scale.html#band). Otherwise, if the
        /// `rangeStep` is `null`, the height will be the value of
        /// [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - If no field is mapped to `y` channel, the `height` will be the value of `rangeStep`.
        ///
        /// __Note__: For plots with [`row` and `column`
        /// channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
        /// height of a single view.
        ///
        /// __See also:__ The documentation for [width and
        /// height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.
        /// </summary>
        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public double? Height { get; set; }

        /// <summary>
        /// A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`,
        /// `"line"`,
        /// `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark definition
        /// object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
        /// </summary>
        [JsonProperty("mark", NullValueHandling = NullValueHandling.Ignore)]
        public AnyMark? Mark { get; set; }

        /// <summary>
        /// Name of the visualization for later reference.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The default visualization padding, in pixels, from the edge of the visualization canvas
        /// to the data rectangle.  If a number, specifies padding for all sides.
        /// If an object, the value should have the format `{"left": 5, "top": 5, "right": 5,
        /// "bottom": 5}` to specify padding for each side of the visualization.
        ///
        /// __Default value__: `5`
        /// </summary>
        [JsonProperty("padding", NullValueHandling = NullValueHandling.Ignore)]
        public Padding? Padding { get; set; }

        /// <summary>
        /// An object defining properties of geographic projection, which will be applied to `shape`
        /// path for `"geoshape"` marks
        /// and to `latitude` and `"longitude"` channels for other marks.
        ///
        /// An object defining properties of the geographic projection shared by underlying layers.
        /// </summary>
        [JsonProperty("projection", NullValueHandling = NullValueHandling.Ignore)]
        public Projection Projection { get; set; }

        /// <summary>
        /// A key-value mapping between selection names and definitions.
        /// </summary>
        [JsonProperty("selection", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, SelectionDef> Selection { get; set; }

        /// <summary>
        /// Title for the plot.
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public Title? Title { get; set; }

        /// <summary>
        /// An array of data transformations such as filter and new field calculation.
        /// </summary>
        [JsonProperty("transform", NullValueHandling = NullValueHandling.Ignore)]
        public Transform[] Transform { get; set; }

        /// <summary>
        /// Optional metadata that will be passed to Vega.
        /// This object is completely ignored by Vega and Vega-Lite and can be used for custom
        /// metadata.
        /// </summary>
        [JsonProperty("usermeta", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Usermeta { get; set; }

        /// <summary>
        /// The width of a visualization.
        ///
        /// __Default value:__ This will be determined by the following rules:
        ///
        /// - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type
        /// is `"fit"` or its x-channel has a [continuous
        /// scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the width will be
        /// the value of
        /// [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - For x-axis with a band or point scale: if
        /// [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value
        /// or unspecified, the width is [determined by the range step, paddings, and the cardinality
        /// of the field mapped to
        /// x-channel](https://vega.github.io/vega-lite/docs/scale.html#band).   Otherwise, if the
        /// `rangeStep` is `null`, the width will be the value of
        /// [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - If no field is mapped to `x` channel, the `width` will be the value of
        /// [`config.scale.textXRangeStep`](https://vega.github.io/vega-lite/docs/size.html#default-width-and-height)
        /// for `text` mark and the value of `rangeStep` for other marks.
        ///
        /// __Note:__ For plots with [`row` and `column`
        /// channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
        /// width of a single view.
        ///
        /// __See also:__ The documentation for [width and
        /// height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.
        /// </summary>
        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public double? Width { get; set; }

        /// <summary>
        /// The alignment to apply to grid rows and columns.
        /// The supported string values are `"all"`, `"each"`, and `"none"`.
        ///
        /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed
        /// one after the other.
        /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or
        /// column may be of variable size.
        /// - For `"all"`, subviews will be aligned and each row or column will be sized identically
        /// based on the maximum observed size. String values for this property will be applied to
        /// both grid rows and columns.
        ///
        /// Alternatively, an object value of the form `{"row": string, "column": string}` can be
        /// used to supply different alignments for rows and columns.
        ///
        /// __Default value:__ `"all"`.
        /// </summary>
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public AlignUnion? Align { get; set; }

        /// <summary>
        /// The bounds calculation method to use for determining the extent of a sub-plot. One of
        /// `full` (the default) or `flush`.
        ///
        /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will
        /// be used.
        /// - If set to `flush`, only the specified width and height values for the sub-view will be
        /// used. The `flush` setting can be useful when attempting to place sub-plots without axes
        /// or legends into a uniform grid structure.
        ///
        /// __Default value:__ `"full"`
        /// </summary>
        [JsonProperty("bounds", NullValueHandling = NullValueHandling.Ignore)]
        public Bounds? Bounds { get; set; }

        /// <summary>
        /// Boolean flag indicating if subviews should be centered relative to their respective rows
        /// or columns.
        ///
        /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply
        /// different centering values for rows and columns.
        ///
        /// __Default value:__ `false`
        ///
        /// Boolean flag indicating if subviews should be centered relative to their respective rows
        /// or columns.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("center", NullValueHandling = NullValueHandling.Ignore)]
        public Center? Center { get; set; }

        /// <summary>
        /// An object that describes mappings between `row` and `column` channels and their field
        /// definitions.
        /// </summary>
        [JsonProperty("facet", NullValueHandling = NullValueHandling.Ignore)]
        public FacetMapping Facet { get; set; }

        /// <summary>
        /// Scale, axis, and legend resolutions for facets.
        ///
        /// Scale, axis, and legend resolutions for layers.
        ///
        /// Scale and legend resolutions for repeated charts.
        ///
        /// Scale, axis, and legend resolutions for vertically concatenated charts.
        ///
        /// Scale, axis, and legend resolutions for horizontally concatenated charts.
        /// </summary>
        [JsonProperty("resolve", NullValueHandling = NullValueHandling.Ignore)]
        public Resolve Resolve { get; set; }

        /// <summary>
        /// The spacing in pixels between sub-views of the composition operator.
        /// An object of the form `{"row": number, "column": number}` can be used to set
        /// different spacing values for rows and columns.
        ///
        /// __Default value__: `10`
        ///
        /// The spacing in pixels between sub-views of the concat operator.
        ///
        /// __Default value__: `10`
        /// </summary>
        [JsonProperty("spacing", NullValueHandling = NullValueHandling.Ignore)]
        public Spacing? Spacing { get; set; }

        /// <summary>
        /// A specification of the view that gets faceted.
        /// </summary>
        [JsonProperty("spec", NullValueHandling = NullValueHandling.Ignore)]
        public SpecClass SpecSpec { get; set; }

        /// <summary>
        /// Layer or single view specifications to be layered.
        ///
        /// __Note__: Specifications inside `layer` cannot use `row` and `column` channels as
        /// layering facet specifications is not allowed. Instead, use the [facet
        /// operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a
        /// facet.
        /// </summary>
        [JsonProperty("layer", NullValueHandling = NullValueHandling.Ignore)]
        public LayerSpec[] Layer { get; set; }

        /// <summary>
        /// An object that describes what fields should be repeated into views that are laid out as a
        /// `row` or `column`.
        /// </summary>
        [JsonProperty("repeat", NullValueHandling = NullValueHandling.Ignore)]
        public Repeat Repeat { get; set; }

        /// <summary>
        /// A list of views that should be concatenated and put into a column.
        /// </summary>
        [JsonProperty("vconcat", NullValueHandling = NullValueHandling.Ignore)]
        public SpecElement[] Vconcat { get; set; }

        /// <summary>
        /// A list of views that should be concatenated and put into a row.
        /// </summary>
        [JsonProperty("hconcat", NullValueHandling = NullValueHandling.Ignore)]
        public SpecElement[] Hconcat { get; set; }
    }

    public partial class RowColVgLayoutAlign
    {
        [JsonProperty("column", NullValueHandling = NullValueHandling.Ignore)]
        public VgLayoutAlign? Column { get; set; }

        [JsonProperty("row", NullValueHandling = NullValueHandling.Ignore)]
        public VgLayoutAlign? Row { get; set; }
    }

    public partial class AutoSizeParams
    {
        /// <summary>
        /// Determines how size calculation should be performed, one of `"content"` or `"padding"`.
        /// The default setting (`"content"`) interprets the width and height settings as the data
        /// rectangle (plotting) dimensions, to which padding is then added. In contrast, the
        /// `"padding"` setting includes the padding within the view size calculations, such that the
        /// width and height settings indicate the **total** intended size of the view.
        ///
        /// __Default value__: `"content"`
        /// </summary>
        [JsonProperty("contains", NullValueHandling = NullValueHandling.Ignore)]
        public Contains? Contains { get; set; }

        /// <summary>
        /// A boolean flag indicating if autosize layout should be re-calculated on every view
        /// update.
        ///
        /// __Default value__: `false`
        /// </summary>
        [JsonProperty("resize", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Resize { get; set; }

        /// <summary>
        /// The sizing format type. One of `"pad"`, `"fit"` or `"none"`. See the [autosize
        /// type](https://vega.github.io/vega-lite/docs/size.html#autosize) documentation for
        /// descriptions of each.
        ///
        /// __Default value__: `"pad"`
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public AutosizeType? Type { get; set; }
    }

    public partial class RowColBoolean
    {
        [JsonProperty("column", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Column { get; set; }

        [JsonProperty("row", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Row { get; set; }
    }

    /// <summary>
    /// Vega-Lite configuration object.  This property can only be defined at the top-level of a
    /// specification.
    /// </summary>
    public partial class Config
    {
        /// <summary>
        /// Area-Specific Config
        /// </summary>
        [JsonProperty("area", NullValueHandling = NullValueHandling.Ignore)]
        public AreaConfig Area { get; set; }

        /// <summary>
        /// Sets how the visualization size should be determined. If a string, should be one of
        /// `"pad"`, `"fit"` or `"none"`.
        /// Object values can additionally specify parameters for content sizing and automatic
        /// resizing.
        /// `"fit"` is only supported for single and layered views that don't use `rangeStep`.
        ///
        /// __Default value__: `pad`
        /// </summary>
        [JsonProperty("autosize", NullValueHandling = NullValueHandling.Ignore)]
        public Autosize? Autosize { get; set; }

        /// <summary>
        /// Axis configuration, which determines default properties for all `x` and `y`
        /// [axes](https://vega.github.io/vega-lite/docs/axis.html). For a full list of axis
        /// configuration options, please see the [corresponding section of the axis
        /// documentation](https://vega.github.io/vega-lite/docs/axis.html#config).
        /// </summary>
        [JsonProperty("axis", NullValueHandling = NullValueHandling.Ignore)]
        public AxisConfig Axis { get; set; }

        /// <summary>
        /// Specific axis config for axes with "band" scales.
        /// </summary>
        [JsonProperty("axisBand", NullValueHandling = NullValueHandling.Ignore)]
        public AxisConfig AxisBand { get; set; }

        /// <summary>
        /// Specific axis config for x-axis along the bottom edge of the chart.
        /// </summary>
        [JsonProperty("axisBottom", NullValueHandling = NullValueHandling.Ignore)]
        public AxisConfig AxisBottom { get; set; }

        /// <summary>
        /// Specific axis config for y-axis along the left edge of the chart.
        /// </summary>
        [JsonProperty("axisLeft", NullValueHandling = NullValueHandling.Ignore)]
        public AxisConfig AxisLeft { get; set; }

        /// <summary>
        /// Specific axis config for y-axis along the right edge of the chart.
        /// </summary>
        [JsonProperty("axisRight", NullValueHandling = NullValueHandling.Ignore)]
        public AxisConfig AxisRight { get; set; }

        /// <summary>
        /// Specific axis config for x-axis along the top edge of the chart.
        /// </summary>
        [JsonProperty("axisTop", NullValueHandling = NullValueHandling.Ignore)]
        public AxisConfig AxisTop { get; set; }

        /// <summary>
        /// X-axis specific config.
        /// </summary>
        [JsonProperty("axisX", NullValueHandling = NullValueHandling.Ignore)]
        public AxisConfig AxisX { get; set; }

        /// <summary>
        /// Y-axis specific config.
        /// </summary>
        [JsonProperty("axisY", NullValueHandling = NullValueHandling.Ignore)]
        public AxisConfig AxisY { get; set; }

        /// <summary>
        /// CSS color property to use as the background of visualization.
        ///
        /// __Default value:__ none (transparent)
        /// </summary>
        [JsonProperty("background", NullValueHandling = NullValueHandling.Ignore)]
        public string Background { get; set; }

        /// <summary>
        /// Bar-Specific Config
        /// </summary>
        [JsonProperty("bar", NullValueHandling = NullValueHandling.Ignore)]
        public BarConfig Bar { get; set; }

        /// <summary>
        /// Box Config
        /// </summary>
        [JsonProperty("boxplot", NullValueHandling = NullValueHandling.Ignore)]
        public BoxPlotConfig Boxplot { get; set; }

        /// <summary>
        /// Circle-Specific Config
        /// </summary>
        [JsonProperty("circle", NullValueHandling = NullValueHandling.Ignore)]
        public MarkConfig Circle { get; set; }

        /// <summary>
        /// Default axis and legend title for count fields.
        ///
        /// __Default value:__ `'Number of Records'`.
        /// </summary>
        [JsonProperty("countTitle", NullValueHandling = NullValueHandling.Ignore)]
        public string CountTitle { get; set; }

        /// <summary>
        /// ErrorBand Config
        /// </summary>
        [JsonProperty("errorband", NullValueHandling = NullValueHandling.Ignore)]
        public ErrorBandConfig Errorband { get; set; }

        /// <summary>
        /// ErrorBar Config
        /// </summary>
        [JsonProperty("errorbar", NullValueHandling = NullValueHandling.Ignore)]
        public ErrorBarConfig Errorbar { get; set; }

        /// <summary>
        /// Defines how Vega-Lite generates title for fields.  There are three possible styles:
        /// - `"verbal"` (Default) - displays function in a verbal style (e.g., "Sum of field",
        /// "Year-month of date", "field (binned)").
        /// - `"function"` - displays function using parentheses and capitalized texts (e.g.,
        /// "SUM(field)", "YEARMONTH(date)", "BIN(field)").
        /// - `"plain"` - displays only the field name without functions (e.g., "field", "date",
        /// "field").
        /// </summary>
        [JsonProperty("fieldTitle", NullValueHandling = NullValueHandling.Ignore)]
        public FieldTitle? FieldTitle { get; set; }

        /// <summary>
        /// Geoshape-Specific Config
        /// </summary>
        [JsonProperty("geoshape", NullValueHandling = NullValueHandling.Ignore)]
        public MarkConfig Geoshape { get; set; }

        /// <summary>
        /// Header configuration, which determines default properties for all
        /// [header](https://vega.github.io/vega-lite/docs/header.html). For a full list of header
        /// configuration options, please see the [corresponding section of in the header
        /// documentation](https://vega.github.io/vega-lite/docs/header.html#config).
        /// </summary>
        [JsonProperty("header", NullValueHandling = NullValueHandling.Ignore)]
        public HeaderConfig Header { get; set; }

        /// <summary>
        /// Defines how Vega-Lite should handle invalid values (`null` and `NaN`).
        /// - If set to `"filter"` (default), all data items with null values will be skipped (for
        /// line, trail, and area marks) or filtered (for other marks).
        /// - If `null`, all data items are included. In this case, invalid values will be
        /// interpreted as zeroes.
        /// </summary>
        [JsonProperty("invalidValues")]
        public InvalidValues? InvalidValues { get; set; }

        /// <summary>
        /// Legend configuration, which determines default properties for all
        /// [legends](https://vega.github.io/vega-lite/docs/legend.html). For a full list of legend
        /// configuration options, please see the [corresponding section of in the legend
        /// documentation](https://vega.github.io/vega-lite/docs/legend.html#config).
        /// </summary>
        [JsonProperty("legend", NullValueHandling = NullValueHandling.Ignore)]
        public LegendConfig Legend { get; set; }

        /// <summary>
        /// Line-Specific Config
        /// </summary>
        [JsonProperty("line", NullValueHandling = NullValueHandling.Ignore)]
        public LineConfig Line { get; set; }

        /// <summary>
        /// Mark Config
        /// </summary>
        [JsonProperty("mark", NullValueHandling = NullValueHandling.Ignore)]
        public MarkConfig Mark { get; set; }

        /// <summary>
        /// D3 Number format for guide labels and text marks. For example "s" for SI units. Use [D3's
        /// number format pattern](https://github.com/d3/d3-format#locale_format).
        /// </summary>
        [JsonProperty("numberFormat", NullValueHandling = NullValueHandling.Ignore)]
        public string NumberFormat { get; set; }

        /// <summary>
        /// The default visualization padding, in pixels, from the edge of the visualization canvas
        /// to the data rectangle.  If a number, specifies padding for all sides.
        /// If an object, the value should have the format `{"left": 5, "top": 5, "right": 5,
        /// "bottom": 5}` to specify padding for each side of the visualization.
        ///
        /// __Default value__: `5`
        /// </summary>
        [JsonProperty("padding", NullValueHandling = NullValueHandling.Ignore)]
        public Padding? Padding { get; set; }

        /// <summary>
        /// Point-Specific Config
        /// </summary>
        [JsonProperty("point", NullValueHandling = NullValueHandling.Ignore)]
        public MarkConfig Point { get; set; }

        /// <summary>
        /// Projection configuration, which determines default properties for all
        /// [projections](https://vega.github.io/vega-lite/docs/projection.html). For a full list of
        /// projection configuration options, please see the [corresponding section of the projection
        /// documentation](https://vega.github.io/vega-lite/docs/projection.html#config).
        /// </summary>
        [JsonProperty("projection", NullValueHandling = NullValueHandling.Ignore)]
        public Projection Projection { get; set; }

        /// <summary>
        /// An object hash that defines default range arrays or schemes for using with scales.
        /// For a full list of scale range configuration options, please see the [corresponding
        /// section of the scale
        /// documentation](https://vega.github.io/vega-lite/docs/scale.html#config).
        /// </summary>
        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, RangeValue> Range { get; set; }

        /// <summary>
        /// Rect-Specific Config
        /// </summary>
        [JsonProperty("rect", NullValueHandling = NullValueHandling.Ignore)]
        public MarkConfig Rect { get; set; }

        /// <summary>
        /// Rule-Specific Config
        /// </summary>
        [JsonProperty("rule", NullValueHandling = NullValueHandling.Ignore)]
        public MarkConfig Rule { get; set; }

        /// <summary>
        /// Scale configuration determines default properties for all
        /// [scales](https://vega.github.io/vega-lite/docs/scale.html). For a full list of scale
        /// configuration options, please see the [corresponding section of the scale
        /// documentation](https://vega.github.io/vega-lite/docs/scale.html#config).
        /// </summary>
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public ScaleConfig Scale { get; set; }

        /// <summary>
        /// An object hash for defining default properties for each type of selections.
        /// </summary>
        [JsonProperty("selection", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionConfig Selection { get; set; }

        /// <summary>
        /// Square-Specific Config
        /// </summary>
        [JsonProperty("square", NullValueHandling = NullValueHandling.Ignore)]
        public MarkConfig Square { get; set; }

        /// <summary>
        /// Default stack offset for stackable mark.
        /// </summary>
        [JsonProperty("stack", NullValueHandling = NullValueHandling.Ignore)]
        public StackOffset? Stack { get; set; }

        /// <summary>
        /// An object hash that defines key-value mappings to determine default properties for marks
        /// with a given [style](https://vega.github.io/vega-lite/docs/mark.html#mark-def).  The keys
        /// represent styles names; the values have to be valid [mark configuration
        /// objects](https://vega.github.io/vega-lite/docs/mark.html#config).
        /// </summary>
        [JsonProperty("style", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, VgMarkConfig> Style { get; set; }

        /// <summary>
        /// Text-Specific Config
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public TextConfig Text { get; set; }

        /// <summary>
        /// Tick-Specific Config
        /// </summary>
        [JsonProperty("tick", NullValueHandling = NullValueHandling.Ignore)]
        public TickConfig Tick { get; set; }

        /// <summary>
        /// Default time format for raw time values (without time units) in text marks, legend labels
        /// and header labels.
        ///
        /// __Default value:__ `"%b %d, %Y"`
        /// __Note:__ Axes automatically determine format each label automatically so this config
        /// would not affect axes.
        /// </summary>
        [JsonProperty("timeFormat", NullValueHandling = NullValueHandling.Ignore)]
        public string TimeFormat { get; set; }

        /// <summary>
        /// Title configuration, which determines default properties for all
        /// [titles](https://vega.github.io/vega-lite/docs/title.html). For a full list of title
        /// configuration options, please see the [corresponding section of the title
        /// documentation](https://vega.github.io/vega-lite/docs/title.html#config).
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public VgTitleConfig Title { get; set; }

        /// <summary>
        /// Trail-Specific Config
        /// </summary>
        [JsonProperty("trail", NullValueHandling = NullValueHandling.Ignore)]
        public LineConfig Trail { get; set; }

        /// <summary>
        /// Default properties for [single view
        /// plots](https://vega.github.io/vega-lite/docs/spec.html#single).
        /// </summary>
        [JsonProperty("view", NullValueHandling = NullValueHandling.Ignore)]
        public ViewConfig View { get; set; }
    }

    /// <summary>
    /// Area-Specific Config
    /// </summary>
    public partial class AreaConfig
    {
        /// <summary>
        /// The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
        /// </summary>
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public Align? Align { get; set; }

        /// <summary>
        /// The rotation angle of the text, in degrees.
        /// </summary>
        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Angle { get; set; }

        /// <summary>
        /// The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
        ///
        /// __Default value:__ `"middle"`
        /// </summary>
        [JsonProperty("baseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? Baseline { get; set; }

        /// <summary>
        /// Default color.  Note that `fill` and `stroke` have higher precedence than `color` and
        /// will override `color`.
        ///
        /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public string Color { get; set; }

        /// <summary>
        /// The radius in pixels of rounded rectangle corners.
        ///
        /// __Default value:__ `0`
        /// </summary>
        [JsonProperty("cornerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? CornerRadius { get; set; }

        /// <summary>
        /// The mouse cursor used over the mark. Any valid [CSS cursor
        /// type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
        /// </summary>
        [JsonProperty("cursor", NullValueHandling = NullValueHandling.Ignore)]
        public Cursor? Cursor { get; set; }

        /// <summary>
        /// The direction of the text. One of `"ltr"` (left-to-right) or `"rtl"` (right-to-left).
        /// This property determines on which side is truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"ltr"`
        /// </summary>
        [JsonProperty("dir", NullValueHandling = NullValueHandling.Ignore)]
        public Dir? Dir { get; set; }

        /// <summary>
        /// The horizontal offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dx", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dx { get; set; }

        /// <summary>
        /// The vertical offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dy", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dy { get; set; }

        /// <summary>
        /// The ellipsis string for text truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"…"`
        /// </summary>
        [JsonProperty("ellipsis", NullValueHandling = NullValueHandling.Ignore)]
        public string Ellipsis { get; set; }

        /// <summary>
        /// Default Fill Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public string Fill { get; set; }

        /// <summary>
        /// Whether the mark's color should be used as fill color instead of stroke color.
        ///
        /// __Default value:__ `false` for `point`, `line` and `rule`; otherwise, `true`.
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("filled", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Filled { get; set; }

        /// <summary>
        /// The fill opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? FillOpacity { get; set; }

        /// <summary>
        /// The typeface to set the text in (e.g., `"Helvetica Neue"`).
        /// </summary>
        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public string Font { get; set; }

        /// <summary>
        /// The font size, in pixels.
        /// </summary>
        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? FontSize { get; set; }

        /// <summary>
        /// The font style (e.g., `"italic"`).
        /// </summary>
        [JsonProperty("fontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public FontStyle? FontStyle { get; set; }

        /// <summary>
        /// The font weight.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? FontWeight { get; set; }

        /// <summary>
        /// A URL to load upon mouse click. If defined, the mark acts as a hyperlink.
        /// </summary>
        [JsonProperty("href", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Href { get; set; }

        /// <summary>
        /// The line interpolation method to use for line and area marks. One of the following:
        /// - `"linear"`: piecewise linear segments, as in a polyline.
        /// - `"linear-closed"`: close the linear segments to form a polygon.
        /// - `"step"`: alternate between horizontal and vertical segments, as in a step function.
        /// - `"step-before"`: alternate between vertical and horizontal segments, as in a step
        /// function.
        /// - `"step-after"`: alternate between horizontal and vertical segments, as in a step
        /// function.
        /// - `"basis"`: a B-spline, with control point duplication on the ends.
        /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
        /// - `"basis-closed"`: a closed B-spline, as in a loop.
        /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
        /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
        /// will intersect other control points.
        /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
        /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
        /// spline.
        /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
        /// </summary>
        [JsonProperty("interpolate", NullValueHandling = NullValueHandling.Ignore)]
        public Interpolate? Interpolate { get; set; }

        /// <summary>
        /// The maximum length of the text mark in pixels. The text value will be automatically
        /// truncated if the rendered size exceeds the limit.
        ///
        /// __Default value:__ `0`, indicating no limit
        /// </summary>
        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public double? Limit { get; set; }

        /// <summary>
        /// A flag for overlaying line on top of area marks, or an object defining the properties of
        /// the overlayed lines.
        ///
        /// - If this value is an empty object (`{}`) or `true`, lines with default properties will
        /// be used.
        ///
        /// - If this value is `false`, no lines would be automatically added to area marks.
        ///
        /// __Default value:__ `false`.
        /// </summary>
        [JsonProperty("line", NullValueHandling = NullValueHandling.Ignore)]
        public Line? Line { get; set; }

        /// <summary>
        /// The overall opacity (value between [0,1]).
        ///
        /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
        /// `square` marks or layered `bar` charts and `1` otherwise.
        /// </summary>
        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? Opacity { get; set; }

        /// <summary>
        /// The orientation of a non-stacked bar, tick, area, and line charts.
        /// The value is either horizontal (default) or vertical.
        /// - For bar, rule and tick, this determines whether the size of the bar and tick
        /// should be applied to x or y dimension.
        /// - For area, this property determines the orient property of the Vega output.
        /// - For line and trail marks, this property determines the sort order of the points in the
        /// line
        /// if `config.sortLineBy` is not specified.
        /// For stacked charts, this is always determined by the orientation of the stack;
        /// therefore explicitly specified value will be ignored.
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public Orient? Orient { get; set; }

        /// <summary>
        /// A flag for overlaying points on top of line or area marks, or an object defining the
        /// properties of the overlayed points.
        ///
        /// - If this property is `"transparent"`, transparent points will be used (for enhancing
        /// tooltips and selections).
        ///
        /// - If this property is an empty object (`{}`) or `true`, filled points with default
        /// properties will be used.
        ///
        /// - If this property is `false`, no points would be automatically added to line or area
        /// marks.
        ///
        /// __Default value:__ `false`.
        /// </summary>
        [JsonProperty("point", NullValueHandling = NullValueHandling.Ignore)]
        public PointUnion? Point { get; set; }

        /// <summary>
        /// Polar coordinate radial offset, in pixels, of the text label from the origin determined
        /// by the `x` and `y` properties.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        /// <summary>
        /// The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`,
        /// `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
        ///
        /// __Default value:__ `"circle"`
        /// </summary>
        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public string Shape { get; set; }

        /// <summary>
        /// Default size for marks.
        /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. For
        /// example: in the case of circles, the radius is determined in part by the square root of
        /// the size value.
        /// - For `bar`, this represents the band size of the bar, in pixels.
        /// - For `text`, this represents the font size, in pixels.
        ///
        /// __Default value:__ `30` for point, circle, square marks; `rangeStep` - 1 for bar marks
        /// with discrete dimensions; `5` for bar marks with continuous dimensions; `11` for text
        /// marks.
        /// </summary>
        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public double? Size { get; set; }

        /// <summary>
        /// Default Stroke Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public string Stroke { get; set; }

        /// <summary>
        /// The stroke cap for line ending style. One of `"butt"`, `"round"`, or `"square"`.
        ///
        /// __Default value:__ `"square"`
        /// </summary>
        [JsonProperty("strokeCap", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeCap? StrokeCap { get; set; }

        /// <summary>
        /// An array of alternating stroke, space lengths for creating dashed or dotted lines.
        /// </summary>
        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] StrokeDash { get; set; }

        /// <summary>
        /// The offset (in pixels) into which to begin drawing with the stroke dash array.
        /// </summary>
        [JsonProperty("strokeDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeDashOffset { get; set; }

        /// <summary>
        /// The stroke line join method. One of `"miter"`, `"round"` or `"bevel"`.
        ///
        /// __Default value:__ `"miter"`
        /// </summary>
        [JsonProperty("strokeJoin", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeJoin? StrokeJoin { get; set; }

        /// <summary>
        /// The miter limit at which to bevel a line join.
        /// </summary>
        [JsonProperty("strokeMiterLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeMiterLimit { get; set; }

        /// <summary>
        /// The stroke opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeOpacity { get; set; }

        /// <summary>
        /// The stroke width, in pixels.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeWidth { get; set; }

        /// <summary>
        /// Depending on the interpolation type, sets the tension parameter (for line and area marks).
        /// </summary>
        [JsonProperty("tension", NullValueHandling = NullValueHandling.Ignore)]
        public double? Tension { get; set; }

        /// <summary>
        /// Placeholder text if the `text` channel is not specified
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        /// <summary>
        /// Polar coordinate angle, in radians, of the text label from the origin determined by the
        /// `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark
        /// `startAngle` and `endAngle` properties: angles are measured in radians, with `0`
        /// indicating "north".
        /// </summary>
        [JsonProperty("theta", NullValueHandling = NullValueHandling.Ignore)]
        public double? Theta { get; set; }

        /// <summary>
        /// The tooltip text string to show upon mouse hover or an object defining which fields
        /// should the tooltip be derived from.
        ///
        /// - If `tooltip` is `{"content": "encoding"}`, then all fields from `encoding` will be
        /// used.
        /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
        /// data point will be used.
        /// </summary>
        [JsonProperty("tooltip", NullValueHandling = NullValueHandling.Ignore)]
        public Tooltip? Tooltip { get; set; }
    }

    public partial class OverlayMarkDef
    {
        /// <summary>
        /// The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
        /// </summary>
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public Align? Align { get; set; }

        /// <summary>
        /// The rotation angle of the text, in degrees.
        /// </summary>
        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Angle { get; set; }

        /// <summary>
        /// The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
        ///
        /// __Default value:__ `"middle"`
        /// </summary>
        [JsonProperty("baseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? Baseline { get; set; }

        /// <summary>
        /// Whether a mark be clipped to the enclosing group’s width and height.
        /// </summary>
        [JsonProperty("clip", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Clip { get; set; }

        /// <summary>
        /// Default color.  Note that `fill` and `stroke` have higher precedence than `color` and
        /// will override `color`.
        ///
        /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public string Color { get; set; }

        /// <summary>
        /// The radius in pixels of rounded rectangle corners.
        ///
        /// __Default value:__ `0`
        /// </summary>
        [JsonProperty("cornerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? CornerRadius { get; set; }

        /// <summary>
        /// The mouse cursor used over the mark. Any valid [CSS cursor
        /// type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
        /// </summary>
        [JsonProperty("cursor", NullValueHandling = NullValueHandling.Ignore)]
        public Cursor? Cursor { get; set; }

        /// <summary>
        /// The direction of the text. One of `"ltr"` (left-to-right) or `"rtl"` (right-to-left).
        /// This property determines on which side is truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"ltr"`
        /// </summary>
        [JsonProperty("dir", NullValueHandling = NullValueHandling.Ignore)]
        public Dir? Dir { get; set; }

        /// <summary>
        /// The horizontal offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dx", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dx { get; set; }

        /// <summary>
        /// The vertical offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dy", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dy { get; set; }

        /// <summary>
        /// The ellipsis string for text truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"…"`
        /// </summary>
        [JsonProperty("ellipsis", NullValueHandling = NullValueHandling.Ignore)]
        public string Ellipsis { get; set; }

        /// <summary>
        /// Default Fill Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public string Fill { get; set; }

        /// <summary>
        /// Whether the mark's color should be used as fill color instead of stroke color.
        ///
        /// __Default value:__ `false` for `point`, `line` and `rule`; otherwise, `true`.
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("filled", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Filled { get; set; }

        /// <summary>
        /// The fill opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? FillOpacity { get; set; }

        /// <summary>
        /// The typeface to set the text in (e.g., `"Helvetica Neue"`).
        /// </summary>
        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public string Font { get; set; }

        /// <summary>
        /// The font size, in pixels.
        /// </summary>
        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? FontSize { get; set; }

        /// <summary>
        /// The font style (e.g., `"italic"`).
        /// </summary>
        [JsonProperty("fontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public FontStyle? FontStyle { get; set; }

        /// <summary>
        /// The font weight.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? FontWeight { get; set; }

        /// <summary>
        /// A URL to load upon mouse click. If defined, the mark acts as a hyperlink.
        /// </summary>
        [JsonProperty("href", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Href { get; set; }

        /// <summary>
        /// The line interpolation method to use for line and area marks. One of the following:
        /// - `"linear"`: piecewise linear segments, as in a polyline.
        /// - `"linear-closed"`: close the linear segments to form a polygon.
        /// - `"step"`: alternate between horizontal and vertical segments, as in a step function.
        /// - `"step-before"`: alternate between vertical and horizontal segments, as in a step
        /// function.
        /// - `"step-after"`: alternate between horizontal and vertical segments, as in a step
        /// function.
        /// - `"basis"`: a B-spline, with control point duplication on the ends.
        /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
        /// - `"basis-closed"`: a closed B-spline, as in a loop.
        /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
        /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
        /// will intersect other control points.
        /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
        /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
        /// spline.
        /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
        /// </summary>
        [JsonProperty("interpolate", NullValueHandling = NullValueHandling.Ignore)]
        public Interpolate? Interpolate { get; set; }

        /// <summary>
        /// The maximum length of the text mark in pixels. The text value will be automatically
        /// truncated if the rendered size exceeds the limit.
        ///
        /// __Default value:__ `0`, indicating no limit
        /// </summary>
        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public double? Limit { get; set; }

        /// <summary>
        /// The overall opacity (value between [0,1]).
        ///
        /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
        /// `square` marks or layered `bar` charts and `1` otherwise.
        /// </summary>
        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? Opacity { get; set; }

        /// <summary>
        /// The orientation of a non-stacked bar, tick, area, and line charts.
        /// The value is either horizontal (default) or vertical.
        /// - For bar, rule and tick, this determines whether the size of the bar and tick
        /// should be applied to x or y dimension.
        /// - For area, this property determines the orient property of the Vega output.
        /// - For line and trail marks, this property determines the sort order of the points in the
        /// line
        /// if `config.sortLineBy` is not specified.
        /// For stacked charts, this is always determined by the orientation of the stack;
        /// therefore explicitly specified value will be ignored.
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public Orient? Orient { get; set; }

        /// <summary>
        /// Polar coordinate radial offset, in pixels, of the text label from the origin determined
        /// by the `x` and `y` properties.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        /// <summary>
        /// The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`,
        /// `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
        ///
        /// __Default value:__ `"circle"`
        /// </summary>
        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public string Shape { get; set; }

        /// <summary>
        /// Default size for marks.
        /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. For
        /// example: in the case of circles, the radius is determined in part by the square root of
        /// the size value.
        /// - For `bar`, this represents the band size of the bar, in pixels.
        /// - For `text`, this represents the font size, in pixels.
        ///
        /// __Default value:__ `30` for point, circle, square marks; `rangeStep` - 1 for bar marks
        /// with discrete dimensions; `5` for bar marks with continuous dimensions; `11` for text
        /// marks.
        /// </summary>
        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public double? Size { get; set; }

        /// <summary>
        /// Default Stroke Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public string Stroke { get; set; }

        /// <summary>
        /// The stroke cap for line ending style. One of `"butt"`, `"round"`, or `"square"`.
        ///
        /// __Default value:__ `"square"`
        /// </summary>
        [JsonProperty("strokeCap", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeCap? StrokeCap { get; set; }

        /// <summary>
        /// An array of alternating stroke, space lengths for creating dashed or dotted lines.
        /// </summary>
        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] StrokeDash { get; set; }

        /// <summary>
        /// The offset (in pixels) into which to begin drawing with the stroke dash array.
        /// </summary>
        [JsonProperty("strokeDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeDashOffset { get; set; }

        /// <summary>
        /// The stroke line join method. One of `"miter"`, `"round"` or `"bevel"`.
        ///
        /// __Default value:__ `"miter"`
        /// </summary>
        [JsonProperty("strokeJoin", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeJoin? StrokeJoin { get; set; }

        /// <summary>
        /// The miter limit at which to bevel a line join.
        /// </summary>
        [JsonProperty("strokeMiterLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeMiterLimit { get; set; }

        /// <summary>
        /// The stroke opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeOpacity { get; set; }

        /// <summary>
        /// The stroke width, in pixels.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeWidth { get; set; }

        /// <summary>
        /// A string or array of strings indicating the name of custom styles to apply to the mark. A
        /// style is a named collection of mark property defaults defined within the [style
        /// configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is
        /// an array, later styles will override earlier styles. Any [mark
        /// properties](https://vega.github.io/vega-lite/docs/encoding.html#mark-prop) explicitly
        /// defined within the `encoding` will override a style default.
        ///
        /// __Default value:__ The mark's name.  For example, a bar mark will have style `"bar"` by
        /// default.
        /// __Note:__ Any specified style will augment the default style. For example, a bar mark
        /// with `"style": "foo"` will receive from `config.style.bar` and `config.style.foo` (the
        /// specified style `"foo"` has higher precedence).
        /// </summary>
        [JsonProperty("style", NullValueHandling = NullValueHandling.Ignore)]
        public Style? Style { get; set; }

        /// <summary>
        /// Depending on the interpolation type, sets the tension parameter (for line and area marks).
        /// </summary>
        [JsonProperty("tension", NullValueHandling = NullValueHandling.Ignore)]
        public double? Tension { get; set; }

        /// <summary>
        /// Placeholder text if the `text` channel is not specified
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        /// <summary>
        /// Polar coordinate angle, in radians, of the text label from the origin determined by the
        /// `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark
        /// `startAngle` and `endAngle` properties: angles are measured in radians, with `0`
        /// indicating "north".
        /// </summary>
        [JsonProperty("theta", NullValueHandling = NullValueHandling.Ignore)]
        public double? Theta { get; set; }

        /// <summary>
        /// The tooltip text string to show upon mouse hover or an object defining which fields
        /// should the tooltip be derived from.
        ///
        /// - If `tooltip` is `{"content": "encoding"}`, then all fields from `encoding` will be
        /// used.
        /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
        /// data point will be used.
        /// </summary>
        [JsonProperty("tooltip", NullValueHandling = NullValueHandling.Ignore)]
        public Tooltip? Tooltip { get; set; }

        /// <summary>
        /// Offset for x2-position.
        /// </summary>
        [JsonProperty("x2Offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? X2Offset { get; set; }

        /// <summary>
        /// Offset for x-position.
        /// </summary>
        [JsonProperty("xOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? XOffset { get; set; }

        /// <summary>
        /// Offset for y2-position.
        /// </summary>
        [JsonProperty("y2Offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? Y2Offset { get; set; }

        /// <summary>
        /// Offset for y-position.
        /// </summary>
        [JsonProperty("yOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? YOffset { get; set; }
    }

    public partial class TooltipContent
    {
        [JsonProperty("content")]
        public Content Content { get; set; }
    }

    /// <summary>
    /// Axis configuration, which determines default properties for all `x` and `y`
    /// [axes](https://vega.github.io/vega-lite/docs/axis.html). For a full list of axis
    /// configuration options, please see the [corresponding section of the axis
    /// documentation](https://vega.github.io/vega-lite/docs/axis.html#config).
    ///
    /// Specific axis config for axes with "band" scales.
    ///
    /// Specific axis config for x-axis along the bottom edge of the chart.
    ///
    /// Specific axis config for y-axis along the left edge of the chart.
    ///
    /// Specific axis config for y-axis along the right edge of the chart.
    ///
    /// Specific axis config for x-axis along the top edge of the chart.
    ///
    /// X-axis specific config.
    ///
    /// Y-axis specific config.
    /// </summary>
    public partial class AxisConfig
    {
        /// <summary>
        /// An interpolation fraction indicating where, for `band` scales, axis ticks should be
        /// positioned. A value of `0` places ticks at the left edge of their bands. A value of `0.5`
        /// places ticks in the middle of their bands.
        ///
        /// __Default value:__ `0.5`
        /// </summary>
        [JsonProperty("bandPosition", NullValueHandling = NullValueHandling.Ignore)]
        public double? BandPosition { get; set; }

        /// <summary>
        /// A boolean flag indicating if the domain (the axis baseline) should be included as part of
        /// the axis.
        ///
        /// __Default value:__ `true`
        /// </summary>
        [JsonProperty("domain", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Domain { get; set; }

        /// <summary>
        /// Color of axis domain line.
        ///
        /// __Default value:__ `"gray"`.
        /// </summary>
        [JsonProperty("domainColor", NullValueHandling = NullValueHandling.Ignore)]
        public string DomainColor { get; set; }

        /// <summary>
        /// Opacity of the axis domain line.
        /// </summary>
        [JsonProperty("domainOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? DomainOpacity { get; set; }

        /// <summary>
        /// Stroke width of axis domain line
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("domainWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? DomainWidth { get; set; }

        /// <summary>
        /// A boolean flag indicating if grid lines should be included as part of the axis
        ///
        /// __Default value:__ `true` for [continuous
        /// scales](https://vega.github.io/vega-lite/docs/scale.html#continuous) that are not binned;
        /// otherwise, `false`.
        /// </summary>
        [JsonProperty("grid", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Grid { get; set; }

        /// <summary>
        /// Color of gridlines.
        ///
        /// __Default value:__ `"lightGray"`.
        /// </summary>
        [JsonProperty("gridColor", NullValueHandling = NullValueHandling.Ignore)]
        public string GridColor { get; set; }

        /// <summary>
        /// The offset (in pixels) into which to begin drawing with the grid dash array.
        /// </summary>
        [JsonProperty("gridDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] GridDash { get; set; }

        /// <summary>
        /// The stroke opacity of grid (value between [0,1])
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("gridOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? GridOpacity { get; set; }

        /// <summary>
        /// The grid width, in pixels.
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("gridWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? GridWidth { get; set; }

        /// <summary>
        /// Horizontal text alignment of axis tick labels, overriding the default setting for the
        /// current axis orientation.
        /// </summary>
        [JsonProperty("labelAlign", NullValueHandling = NullValueHandling.Ignore)]
        public Align? LabelAlign { get; set; }

        /// <summary>
        /// The rotation angle of the axis labels.
        ///
        /// __Default value:__ `-90` for nominal and ordinal fields; `0` otherwise.
        /// </summary>
        [JsonProperty("labelAngle", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelAngle { get; set; }

        /// <summary>
        /// Vertical text baseline of axis tick labels, overriding the default setting for the
        /// current axis orientation. Can be `"top"`, `"middle"`, `"bottom"`, or `"alphabetic"`.
        /// </summary>
        [JsonProperty("labelBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? LabelBaseline { get; set; }

        /// <summary>
        /// Indicates if labels should be hidden if they exceed the axis range. If `false` (the
        /// default) no bounds overlap analysis is performed. If `true`, labels will be hidden if
        /// they exceed the axis range by more than 1 pixel. If this property is a number, it
        /// specifies the pixel tolerance: the maximum amount by which a label bounding box may
        /// exceed the axis range.
        ///
        /// __Default value:__ `false`.
        /// </summary>
        [JsonProperty("labelBound", NullValueHandling = NullValueHandling.Ignore)]
        public Label? LabelBound { get; set; }

        /// <summary>
        /// The color of the tick label, can be in hex color code or regular color name.
        /// </summary>
        [JsonProperty("labelColor", NullValueHandling = NullValueHandling.Ignore)]
        public string LabelColor { get; set; }

        /// <summary>
        /// Indicates if the first and last axis labels should be aligned flush with the scale range.
        /// Flush alignment for a horizontal axis will left-align the first label and right-align the
        /// last label. For vertical axes, bottom and top text baselines are applied instead. If this
        /// property is a number, it also indicates the number of pixels by which to offset the first
        /// and last labels; for example, a value of 2 will flush-align the first and last labels and
        /// also push them 2 pixels outward from the center of the axis. The additional adjustment
        /// can sometimes help the labels better visually group with corresponding axis ticks.
        ///
        /// __Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.
        /// </summary>
        [JsonProperty("labelFlush", NullValueHandling = NullValueHandling.Ignore)]
        public Label? LabelFlush { get; set; }

        /// <summary>
        /// Indicates the number of pixels by which to offset flush-adjusted labels. For example, a
        /// value of `2` will push flush-adjusted labels 2 pixels outward from the center of the
        /// axis. Offsets can help the labels better visually group with corresponding axis ticks.
        ///
        /// __Default value:__ `0`.
        /// </summary>
        [JsonProperty("labelFlushOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelFlushOffset { get; set; }

        /// <summary>
        /// The font of the tick label.
        /// </summary>
        [JsonProperty("labelFont", NullValueHandling = NullValueHandling.Ignore)]
        public string LabelFont { get; set; }

        /// <summary>
        /// The font size of the label, in pixels.
        /// </summary>
        [JsonProperty("labelFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelFontSize { get; set; }

        /// <summary>
        /// Font weight of axis tick labels.
        /// </summary>
        [JsonProperty("labelFontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? LabelFontWeight { get; set; }

        /// <summary>
        /// Maximum allowed pixel width of axis tick labels.
        ///
        /// __Default value:__ `180`
        /// </summary>
        [JsonProperty("labelLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelLimit { get; set; }

        /// <summary>
        /// The opacity of the labels.
        /// </summary>
        [JsonProperty("labelOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelOpacity { get; set; }

        /// <summary>
        /// The strategy to use for resolving overlap of axis labels. If `false` (the default), no
        /// overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing
        /// every other label is used (this works well for standard linear axes). If set to
        /// `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps
        /// with the last visible label (this often works better for log-scaled axes).
        ///
        /// __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log
        /// scales; otherwise `false`.
        /// </summary>
        [JsonProperty("labelOverlap", NullValueHandling = NullValueHandling.Ignore)]
        public LabelOverlap? LabelOverlap { get; set; }

        /// <summary>
        /// The padding, in pixels, between axis and text labels.
        ///
        /// __Default value:__ `2`
        /// </summary>
        [JsonProperty("labelPadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelPadding { get; set; }

        /// <summary>
        /// A boolean flag indicating if labels should be included as part of the axis.
        ///
        /// __Default value:__ `true`.
        /// </summary>
        [JsonProperty("labels", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Labels { get; set; }

        /// <summary>
        /// The maximum extent in pixels that axis ticks and labels should use. This determines a
        /// maximum offset value for axis titles.
        ///
        /// __Default value:__ `undefined`.
        /// </summary>
        [JsonProperty("maxExtent", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxExtent { get; set; }

        /// <summary>
        /// The minimum extent in pixels that axis ticks and labels should use. This determines a
        /// minimum offset value for axis titles.
        ///
        /// __Default value:__ `30` for y-axis; `undefined` for x-axis.
        /// </summary>
        [JsonProperty("minExtent", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinExtent { get; set; }

        /// <summary>
        /// Whether month names and weekday names should be abbreviated.
        ///
        /// __Default value:__  `false`
        /// </summary>
        [JsonProperty("shortTimeLabels", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShortTimeLabels { get; set; }

        /// <summary>
        /// The color of the axis's tick.
        ///
        /// __Default value:__ `"gray"`
        /// </summary>
        [JsonProperty("tickColor", NullValueHandling = NullValueHandling.Ignore)]
        public string TickColor { get; set; }

        /// <summary>
        /// Boolean flag indicating if an extra axis tick should be added for the initial position of
        /// the axis. This flag is useful for styling axes for `band` scales such that ticks are
        /// placed on band boundaries rather in the middle of a band. Use in conjunction with
        /// `"bandPostion": 1` and an axis `"padding"` value of `0`.
        /// </summary>
        [JsonProperty("tickExtra", NullValueHandling = NullValueHandling.Ignore)]
        public bool? TickExtra { get; set; }

        /// <summary>
        /// Position offset in pixels to apply to ticks, labels, and gridlines.
        /// </summary>
        [JsonProperty("tickOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? TickOffset { get; set; }

        /// <summary>
        /// Opacity of the ticks.
        /// </summary>
        [JsonProperty("tickOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? TickOpacity { get; set; }

        /// <summary>
        /// Boolean flag indicating if pixel position values should be rounded to the nearest
        /// integer.
        ///
        /// __Default value:__ `true`
        /// </summary>
        [JsonProperty("tickRound", NullValueHandling = NullValueHandling.Ignore)]
        public bool? TickRound { get; set; }

        /// <summary>
        /// Boolean value that determines whether the axis should include ticks.
        ///
        /// __Default value:__ `true`
        /// </summary>
        [JsonProperty("ticks", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Ticks { get; set; }

        /// <summary>
        /// The size in pixels of axis ticks.
        ///
        /// __Default value:__ `5`
        /// </summary>
        [JsonProperty("tickSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? TickSize { get; set; }

        /// <summary>
        /// The width, in pixels, of ticks.
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("tickWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? TickWidth { get; set; }

        /// <summary>
        /// Horizontal text alignment of axis titles.
        /// </summary>
        [JsonProperty("titleAlign", NullValueHandling = NullValueHandling.Ignore)]
        public Align? TitleAlign { get; set; }

        /// <summary>
        /// Angle in degrees of axis titles.
        /// </summary>
        [JsonProperty("titleAngle", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleAngle { get; set; }

        /// <summary>
        /// Vertical text baseline for axis titles.
        /// </summary>
        [JsonProperty("titleBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? TitleBaseline { get; set; }

        /// <summary>
        /// Color of the title, can be in hex color code or regular color name.
        /// </summary>
        [JsonProperty("titleColor", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleColor { get; set; }

        /// <summary>
        /// Font of the title. (e.g., `"Helvetica Neue"`).
        /// </summary>
        [JsonProperty("titleFont", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleFont { get; set; }

        /// <summary>
        /// Font size of the title.
        /// </summary>
        [JsonProperty("titleFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleFontSize { get; set; }

        /// <summary>
        /// Font weight of the title.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("titleFontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? TitleFontWeight { get; set; }

        /// <summary>
        /// Maximum allowed pixel width of axis titles.
        /// </summary>
        [JsonProperty("titleLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleLimit { get; set; }

        /// <summary>
        /// Opacity of the axis title.
        /// </summary>
        [JsonProperty("titleOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleOpacity { get; set; }

        /// <summary>
        /// The padding, in pixels, between title and axis.
        /// </summary>
        [JsonProperty("titlePadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitlePadding { get; set; }

        /// <summary>
        /// X-coordinate of the axis title relative to the axis group.
        /// </summary>
        [JsonProperty("titleX", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleX { get; set; }

        /// <summary>
        /// Y-coordinate of the axis title relative to the axis group.
        /// </summary>
        [JsonProperty("titleY", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleY { get; set; }
    }

    /// <summary>
    /// Bar-Specific Config
    /// </summary>
    public partial class BarConfig
    {
        /// <summary>
        /// The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
        /// </summary>
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public Align? Align { get; set; }

        /// <summary>
        /// The rotation angle of the text, in degrees.
        /// </summary>
        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Angle { get; set; }

        /// <summary>
        /// The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
        ///
        /// __Default value:__ `"middle"`
        /// </summary>
        [JsonProperty("baseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? Baseline { get; set; }

        /// <summary>
        /// Offset between bars for binned field.  Ideal value for this is either 0 (Preferred by
        /// statisticians) or 1 (Vega-Lite Default, D3 example style).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("binSpacing", NullValueHandling = NullValueHandling.Ignore)]
        public double? BinSpacing { get; set; }

        /// <summary>
        /// Default color.  Note that `fill` and `stroke` have higher precedence than `color` and
        /// will override `color`.
        ///
        /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public string Color { get; set; }

        /// <summary>
        /// The default size of the bars on continuous scales.
        ///
        /// __Default value:__ `5`
        /// </summary>
        [JsonProperty("continuousBandSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? ContinuousBandSize { get; set; }

        /// <summary>
        /// The radius in pixels of rounded rectangle corners.
        ///
        /// __Default value:__ `0`
        /// </summary>
        [JsonProperty("cornerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? CornerRadius { get; set; }

        /// <summary>
        /// The mouse cursor used over the mark. Any valid [CSS cursor
        /// type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
        /// </summary>
        [JsonProperty("cursor", NullValueHandling = NullValueHandling.Ignore)]
        public Cursor? Cursor { get; set; }

        /// <summary>
        /// The direction of the text. One of `"ltr"` (left-to-right) or `"rtl"` (right-to-left).
        /// This property determines on which side is truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"ltr"`
        /// </summary>
        [JsonProperty("dir", NullValueHandling = NullValueHandling.Ignore)]
        public Dir? Dir { get; set; }

        /// <summary>
        /// The default size of the bars with discrete dimensions.  If unspecified, the default size
        /// is  `bandSize-1`,
        /// which provides 1 pixel offset between bars.
        /// </summary>
        [JsonProperty("discreteBandSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? DiscreteBandSize { get; set; }

        /// <summary>
        /// The horizontal offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dx", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dx { get; set; }

        /// <summary>
        /// The vertical offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dy", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dy { get; set; }

        /// <summary>
        /// The ellipsis string for text truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"…"`
        /// </summary>
        [JsonProperty("ellipsis", NullValueHandling = NullValueHandling.Ignore)]
        public string Ellipsis { get; set; }

        /// <summary>
        /// Default Fill Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public string Fill { get; set; }

        /// <summary>
        /// Whether the mark's color should be used as fill color instead of stroke color.
        ///
        /// __Default value:__ `false` for `point`, `line` and `rule`; otherwise, `true`.
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("filled", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Filled { get; set; }

        /// <summary>
        /// The fill opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? FillOpacity { get; set; }

        /// <summary>
        /// The typeface to set the text in (e.g., `"Helvetica Neue"`).
        /// </summary>
        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public string Font { get; set; }

        /// <summary>
        /// The font size, in pixels.
        /// </summary>
        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? FontSize { get; set; }

        /// <summary>
        /// The font style (e.g., `"italic"`).
        /// </summary>
        [JsonProperty("fontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public FontStyle? FontStyle { get; set; }

        /// <summary>
        /// The font weight.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? FontWeight { get; set; }

        /// <summary>
        /// A URL to load upon mouse click. If defined, the mark acts as a hyperlink.
        /// </summary>
        [JsonProperty("href", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Href { get; set; }

        /// <summary>
        /// The line interpolation method to use for line and area marks. One of the following:
        /// - `"linear"`: piecewise linear segments, as in a polyline.
        /// - `"linear-closed"`: close the linear segments to form a polygon.
        /// - `"step"`: alternate between horizontal and vertical segments, as in a step function.
        /// - `"step-before"`: alternate between vertical and horizontal segments, as in a step
        /// function.
        /// - `"step-after"`: alternate between horizontal and vertical segments, as in a step
        /// function.
        /// - `"basis"`: a B-spline, with control point duplication on the ends.
        /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
        /// - `"basis-closed"`: a closed B-spline, as in a loop.
        /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
        /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
        /// will intersect other control points.
        /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
        /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
        /// spline.
        /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
        /// </summary>
        [JsonProperty("interpolate", NullValueHandling = NullValueHandling.Ignore)]
        public Interpolate? Interpolate { get; set; }

        /// <summary>
        /// The maximum length of the text mark in pixels. The text value will be automatically
        /// truncated if the rendered size exceeds the limit.
        ///
        /// __Default value:__ `0`, indicating no limit
        /// </summary>
        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public double? Limit { get; set; }

        /// <summary>
        /// The overall opacity (value between [0,1]).
        ///
        /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
        /// `square` marks or layered `bar` charts and `1` otherwise.
        /// </summary>
        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? Opacity { get; set; }

        /// <summary>
        /// The orientation of a non-stacked bar, tick, area, and line charts.
        /// The value is either horizontal (default) or vertical.
        /// - For bar, rule and tick, this determines whether the size of the bar and tick
        /// should be applied to x or y dimension.
        /// - For area, this property determines the orient property of the Vega output.
        /// - For line and trail marks, this property determines the sort order of the points in the
        /// line
        /// if `config.sortLineBy` is not specified.
        /// For stacked charts, this is always determined by the orientation of the stack;
        /// therefore explicitly specified value will be ignored.
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public Orient? Orient { get; set; }

        /// <summary>
        /// Polar coordinate radial offset, in pixels, of the text label from the origin determined
        /// by the `x` and `y` properties.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        /// <summary>
        /// The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`,
        /// `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
        ///
        /// __Default value:__ `"circle"`
        /// </summary>
        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public string Shape { get; set; }

        /// <summary>
        /// Default size for marks.
        /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. For
        /// example: in the case of circles, the radius is determined in part by the square root of
        /// the size value.
        /// - For `bar`, this represents the band size of the bar, in pixels.
        /// - For `text`, this represents the font size, in pixels.
        ///
        /// __Default value:__ `30` for point, circle, square marks; `rangeStep` - 1 for bar marks
        /// with discrete dimensions; `5` for bar marks with continuous dimensions; `11` for text
        /// marks.
        /// </summary>
        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public double? Size { get; set; }

        /// <summary>
        /// Default Stroke Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public string Stroke { get; set; }

        /// <summary>
        /// The stroke cap for line ending style. One of `"butt"`, `"round"`, or `"square"`.
        ///
        /// __Default value:__ `"square"`
        /// </summary>
        [JsonProperty("strokeCap", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeCap? StrokeCap { get; set; }

        /// <summary>
        /// An array of alternating stroke, space lengths for creating dashed or dotted lines.
        /// </summary>
        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] StrokeDash { get; set; }

        /// <summary>
        /// The offset (in pixels) into which to begin drawing with the stroke dash array.
        /// </summary>
        [JsonProperty("strokeDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeDashOffset { get; set; }

        /// <summary>
        /// The stroke line join method. One of `"miter"`, `"round"` or `"bevel"`.
        ///
        /// __Default value:__ `"miter"`
        /// </summary>
        [JsonProperty("strokeJoin", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeJoin? StrokeJoin { get; set; }

        /// <summary>
        /// The miter limit at which to bevel a line join.
        /// </summary>
        [JsonProperty("strokeMiterLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeMiterLimit { get; set; }

        /// <summary>
        /// The stroke opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeOpacity { get; set; }

        /// <summary>
        /// The stroke width, in pixels.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeWidth { get; set; }

        /// <summary>
        /// Depending on the interpolation type, sets the tension parameter (for line and area marks).
        /// </summary>
        [JsonProperty("tension", NullValueHandling = NullValueHandling.Ignore)]
        public double? Tension { get; set; }

        /// <summary>
        /// Placeholder text if the `text` channel is not specified
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        /// <summary>
        /// Polar coordinate angle, in radians, of the text label from the origin determined by the
        /// `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark
        /// `startAngle` and `endAngle` properties: angles are measured in radians, with `0`
        /// indicating "north".
        /// </summary>
        [JsonProperty("theta", NullValueHandling = NullValueHandling.Ignore)]
        public double? Theta { get; set; }

        /// <summary>
        /// The tooltip text string to show upon mouse hover or an object defining which fields
        /// should the tooltip be derived from.
        ///
        /// - If `tooltip` is `{"content": "encoding"}`, then all fields from `encoding` will be
        /// used.
        /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
        /// data point will be used.
        /// </summary>
        [JsonProperty("tooltip", NullValueHandling = NullValueHandling.Ignore)]
        public Tooltip? Tooltip { get; set; }
    }

    /// <summary>
    /// Box Config
    /// </summary>
    public partial class BoxPlotConfig
    {
        [JsonProperty("box", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Box { get; set; }

        /// <summary>
        /// The extent of the whiskers. Available options include:
        /// - `"min-max"`: min and max are the lower and upper whiskers respectively.
        /// - A number representing multiple of the interquartile range (Q3-Q1).  This number will be
        /// multiplied by the IQR. The product will be added to the third quartile to get the upper
        /// whisker and subtracted from the first quartile to get the lower whisker.
        ///
        /// __Default value:__ `1.5`.
        /// </summary>
        [JsonProperty("extent", NullValueHandling = NullValueHandling.Ignore)]
        public BoxplotExtent? Extent { get; set; }

        [JsonProperty("median", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Median { get; set; }

        [JsonProperty("outliers", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Outliers { get; set; }

        [JsonProperty("rule", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Rule { get; set; }

        /// <summary>
        /// Size of the box and median tick of a box plot
        /// </summary>
        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public double? Size { get; set; }

        [JsonProperty("ticks", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Ticks { get; set; }
    }

    /// <summary>
    /// Circle-Specific Config
    ///
    /// Geoshape-Specific Config
    ///
    /// Mark Config
    ///
    /// Point-Specific Config
    ///
    /// Rect-Specific Config
    ///
    /// Rule-Specific Config
    ///
    /// Square-Specific Config
    /// </summary>
    public partial class MarkConfig
    {
        /// <summary>
        /// The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
        /// </summary>
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public Align? Align { get; set; }

        /// <summary>
        /// The rotation angle of the text, in degrees.
        /// </summary>
        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Angle { get; set; }

        /// <summary>
        /// The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
        ///
        /// __Default value:__ `"middle"`
        /// </summary>
        [JsonProperty("baseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? Baseline { get; set; }

        /// <summary>
        /// Default color.  Note that `fill` and `stroke` have higher precedence than `color` and
        /// will override `color`.
        ///
        /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public string Color { get; set; }

        /// <summary>
        /// The radius in pixels of rounded rectangle corners.
        ///
        /// __Default value:__ `0`
        /// </summary>
        [JsonProperty("cornerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? CornerRadius { get; set; }

        /// <summary>
        /// The mouse cursor used over the mark. Any valid [CSS cursor
        /// type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
        /// </summary>
        [JsonProperty("cursor", NullValueHandling = NullValueHandling.Ignore)]
        public Cursor? Cursor { get; set; }

        /// <summary>
        /// The direction of the text. One of `"ltr"` (left-to-right) or `"rtl"` (right-to-left).
        /// This property determines on which side is truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"ltr"`
        /// </summary>
        [JsonProperty("dir", NullValueHandling = NullValueHandling.Ignore)]
        public Dir? Dir { get; set; }

        /// <summary>
        /// The horizontal offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dx", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dx { get; set; }

        /// <summary>
        /// The vertical offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dy", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dy { get; set; }

        /// <summary>
        /// The ellipsis string for text truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"…"`
        /// </summary>
        [JsonProperty("ellipsis", NullValueHandling = NullValueHandling.Ignore)]
        public string Ellipsis { get; set; }

        /// <summary>
        /// Default Fill Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public string Fill { get; set; }

        /// <summary>
        /// Whether the mark's color should be used as fill color instead of stroke color.
        ///
        /// __Default value:__ `false` for `point`, `line` and `rule`; otherwise, `true`.
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("filled", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Filled { get; set; }

        /// <summary>
        /// The fill opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? FillOpacity { get; set; }

        /// <summary>
        /// The typeface to set the text in (e.g., `"Helvetica Neue"`).
        /// </summary>
        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public string Font { get; set; }

        /// <summary>
        /// The font size, in pixels.
        /// </summary>
        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? FontSize { get; set; }

        /// <summary>
        /// The font style (e.g., `"italic"`).
        /// </summary>
        [JsonProperty("fontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public FontStyle? FontStyle { get; set; }

        /// <summary>
        /// The font weight.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? FontWeight { get; set; }

        /// <summary>
        /// A URL to load upon mouse click. If defined, the mark acts as a hyperlink.
        /// </summary>
        [JsonProperty("href", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Href { get; set; }

        /// <summary>
        /// The line interpolation method to use for line and area marks. One of the following:
        /// - `"linear"`: piecewise linear segments, as in a polyline.
        /// - `"linear-closed"`: close the linear segments to form a polygon.
        /// - `"step"`: alternate between horizontal and vertical segments, as in a step function.
        /// - `"step-before"`: alternate between vertical and horizontal segments, as in a step
        /// function.
        /// - `"step-after"`: alternate between horizontal and vertical segments, as in a step
        /// function.
        /// - `"basis"`: a B-spline, with control point duplication on the ends.
        /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
        /// - `"basis-closed"`: a closed B-spline, as in a loop.
        /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
        /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
        /// will intersect other control points.
        /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
        /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
        /// spline.
        /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
        /// </summary>
        [JsonProperty("interpolate", NullValueHandling = NullValueHandling.Ignore)]
        public Interpolate? Interpolate { get; set; }

        /// <summary>
        /// The maximum length of the text mark in pixels. The text value will be automatically
        /// truncated if the rendered size exceeds the limit.
        ///
        /// __Default value:__ `0`, indicating no limit
        /// </summary>
        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public double? Limit { get; set; }

        /// <summary>
        /// The overall opacity (value between [0,1]).
        ///
        /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
        /// `square` marks or layered `bar` charts and `1` otherwise.
        /// </summary>
        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? Opacity { get; set; }

        /// <summary>
        /// The orientation of a non-stacked bar, tick, area, and line charts.
        /// The value is either horizontal (default) or vertical.
        /// - For bar, rule and tick, this determines whether the size of the bar and tick
        /// should be applied to x or y dimension.
        /// - For area, this property determines the orient property of the Vega output.
        /// - For line and trail marks, this property determines the sort order of the points in the
        /// line
        /// if `config.sortLineBy` is not specified.
        /// For stacked charts, this is always determined by the orientation of the stack;
        /// therefore explicitly specified value will be ignored.
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public Orient? Orient { get; set; }

        /// <summary>
        /// Polar coordinate radial offset, in pixels, of the text label from the origin determined
        /// by the `x` and `y` properties.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        /// <summary>
        /// The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`,
        /// `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
        ///
        /// __Default value:__ `"circle"`
        /// </summary>
        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public string Shape { get; set; }

        /// <summary>
        /// Default size for marks.
        /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. For
        /// example: in the case of circles, the radius is determined in part by the square root of
        /// the size value.
        /// - For `bar`, this represents the band size of the bar, in pixels.
        /// - For `text`, this represents the font size, in pixels.
        ///
        /// __Default value:__ `30` for point, circle, square marks; `rangeStep` - 1 for bar marks
        /// with discrete dimensions; `5` for bar marks with continuous dimensions; `11` for text
        /// marks.
        /// </summary>
        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public double? Size { get; set; }

        /// <summary>
        /// Default Stroke Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public string Stroke { get; set; }

        /// <summary>
        /// The stroke cap for line ending style. One of `"butt"`, `"round"`, or `"square"`.
        ///
        /// __Default value:__ `"square"`
        /// </summary>
        [JsonProperty("strokeCap", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeCap? StrokeCap { get; set; }

        /// <summary>
        /// An array of alternating stroke, space lengths for creating dashed or dotted lines.
        /// </summary>
        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] StrokeDash { get; set; }

        /// <summary>
        /// The offset (in pixels) into which to begin drawing with the stroke dash array.
        /// </summary>
        [JsonProperty("strokeDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeDashOffset { get; set; }

        /// <summary>
        /// The stroke line join method. One of `"miter"`, `"round"` or `"bevel"`.
        ///
        /// __Default value:__ `"miter"`
        /// </summary>
        [JsonProperty("strokeJoin", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeJoin? StrokeJoin { get; set; }

        /// <summary>
        /// The miter limit at which to bevel a line join.
        /// </summary>
        [JsonProperty("strokeMiterLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeMiterLimit { get; set; }

        /// <summary>
        /// The stroke opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeOpacity { get; set; }

        /// <summary>
        /// The stroke width, in pixels.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeWidth { get; set; }

        /// <summary>
        /// Depending on the interpolation type, sets the tension parameter (for line and area marks).
        /// </summary>
        [JsonProperty("tension", NullValueHandling = NullValueHandling.Ignore)]
        public double? Tension { get; set; }

        /// <summary>
        /// Placeholder text if the `text` channel is not specified
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        /// <summary>
        /// Polar coordinate angle, in radians, of the text label from the origin determined by the
        /// `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark
        /// `startAngle` and `endAngle` properties: angles are measured in radians, with `0`
        /// indicating "north".
        /// </summary>
        [JsonProperty("theta", NullValueHandling = NullValueHandling.Ignore)]
        public double? Theta { get; set; }

        /// <summary>
        /// The tooltip text string to show upon mouse hover or an object defining which fields
        /// should the tooltip be derived from.
        ///
        /// - If `tooltip` is `{"content": "encoding"}`, then all fields from `encoding` will be
        /// used.
        /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
        /// data point will be used.
        /// </summary>
        [JsonProperty("tooltip", NullValueHandling = NullValueHandling.Ignore)]
        public Tooltip? Tooltip { get; set; }
    }

    /// <summary>
    /// ErrorBand Config
    /// </summary>
    public partial class ErrorBandConfig
    {
        [JsonProperty("band", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Band { get; set; }

        [JsonProperty("borders", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Borders { get; set; }

        /// <summary>
        /// The extent of the band. Available options include:
        /// - `"ci"`: Extend the band to the confidence interval of the mean.
        /// - `"stderr"`: The size of band are set to the value of standard error, extending from the
        /// mean.
        /// - `"stdev"`: The size of band are set to the value of standard deviation, extending from
        /// the mean.
        /// - `"iqr"`: Extend the band to the q1 and q3.
        ///
        /// __Default value:__ `"stderr"`.
        /// </summary>
        [JsonProperty("extent", NullValueHandling = NullValueHandling.Ignore)]
        public ErrorbandExtent? Extent { get; set; }

        /// <summary>
        /// The line interpolation method for the error band. One of the following:
        /// - `"linear"`: piecewise linear segments, as in a polyline.
        /// - `"linear-closed"`: close the linear segments to form a polygon.
        /// - `"step"`: alternate between horizontal and vertical segments, as in a step function.
        /// - `"step-before"`: alternate between vertical and horizontal segments, as in a step
        /// function.
        /// - `"step-after"`: alternate between horizontal and vertical segments, as in a step
        /// function.
        /// - `"basis"`: a B-spline, with control point duplication on the ends.
        /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
        /// - `"basis-closed"`: a closed B-spline, as in a loop.
        /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
        /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
        /// will intersect other control points.
        /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
        /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
        /// spline.
        /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
        /// </summary>
        [JsonProperty("interpolate", NullValueHandling = NullValueHandling.Ignore)]
        public Interpolate? Interpolate { get; set; }

        /// <summary>
        /// The tension parameter for the interpolation type of the error band.
        /// </summary>
        [JsonProperty("tension", NullValueHandling = NullValueHandling.Ignore)]
        public double? Tension { get; set; }
    }

    /// <summary>
    /// ErrorBar Config
    /// </summary>
    public partial class ErrorBarConfig
    {
        /// <summary>
        /// The extent of the rule. Available options include:
        /// - `"ci"`: Extend the rule to the confidence interval of the mean.
        /// - `"stderr"`: The size of rule are set to the value of standard error, extending from the
        /// mean.
        /// - `"stdev"`: The size of rule are set to the value of standard deviation, extending from
        /// the mean.
        /// - `"iqr"`: Extend the rule to the q1 and q3.
        ///
        /// __Default value:__ `"stderr"`.
        /// </summary>
        [JsonProperty("extent", NullValueHandling = NullValueHandling.Ignore)]
        public ErrorbandExtent? Extent { get; set; }

        [JsonProperty("rule", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Rule { get; set; }

        [JsonProperty("ticks", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Ticks { get; set; }
    }

    /// <summary>
    /// Header configuration, which determines default properties for all
    /// [header](https://vega.github.io/vega-lite/docs/header.html). For a full list of header
    /// configuration options, please see the [corresponding section of in the header
    /// documentation](https://vega.github.io/vega-lite/docs/header.html#config).
    /// </summary>
    public partial class HeaderConfig
    {
        /// <summary>
        /// The rotation angle of the header labels.
        ///
        /// __Default value:__ `0` for column header, `-90` for row header.
        /// </summary>
        [JsonProperty("labelAngle", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelAngle { get; set; }

        /// <summary>
        /// The color of the header label, can be in hex color code or regular color name.
        /// </summary>
        [JsonProperty("labelColor", NullValueHandling = NullValueHandling.Ignore)]
        public string LabelColor { get; set; }

        /// <summary>
        /// The font of the header label.
        /// </summary>
        [JsonProperty("labelFont", NullValueHandling = NullValueHandling.Ignore)]
        public string LabelFont { get; set; }

        /// <summary>
        /// The font size of the header label, in pixels.
        /// </summary>
        [JsonProperty("labelFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelFontSize { get; set; }

        /// <summary>
        /// The maximum length of the header label in pixels. The text value will be automatically
        /// truncated if the rendered size exceeds the limit.
        ///
        /// __Default value:__ `0`, indicating no limit
        /// </summary>
        [JsonProperty("labelLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelLimit { get; set; }

        /// <summary>
        /// The orthogonal distance in pixels by which to displace the title from its position along
        /// the edge of the chart.
        ///
        /// __Default value:__ `10`
        /// </summary>
        [JsonProperty("labelPadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelPadding { get; set; }

        /// <summary>
        /// The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For
        /// example, with an orientation of top these anchor positions map to a left-, center-, or
        /// right-aligned title.
        ///
        /// __Default value:__ `"middle"` for
        /// [single](https://vega.github.io/vega-lite/docs/spec.html) and
        /// [layered](https://vega.github.io/vega-lite/docs/layer.html) views.
        /// `"start"` for other composite views.
        ///
        /// __Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only
        /// customizable only for [single](https://vega.github.io/vega-lite/docs/spec.html) and
        /// [layered](https://vega.github.io/vega-lite/docs/layer.html) views.  For other composite
        /// views, `anchor` is always `"start"`.
        /// </summary>
        [JsonProperty("titleAnchor", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleAnchor { get; set; }

        /// <summary>
        /// The rotation angle of the header title.
        ///
        /// __Default value:__ `0`.
        /// </summary>
        [JsonProperty("titleAngle", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleAngle { get; set; }

        /// <summary>
        /// Vertical text baseline for the header title. One of `"top"`, `"bottom"`, `"middle"`.
        ///
        /// __Default value:__ `"middle"`
        /// </summary>
        [JsonProperty("titleBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? TitleBaseline { get; set; }

        /// <summary>
        /// Color of the header title, can be in hex color code or regular color name.
        /// </summary>
        [JsonProperty("titleColor", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleColor { get; set; }

        /// <summary>
        /// Font of the header title. (e.g., `"Helvetica Neue"`).
        /// </summary>
        [JsonProperty("titleFont", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleFont { get; set; }

        /// <summary>
        /// Font size of the header title.
        /// </summary>
        [JsonProperty("titleFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleFontSize { get; set; }

        /// <summary>
        /// Font weight of the header title.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("titleFontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? TitleFontWeight { get; set; }

        /// <summary>
        /// The maximum length of the header title in pixels. The text value will be automatically
        /// truncated if the rendered size exceeds the limit.
        ///
        /// __Default value:__ `0`, indicating no limit
        /// </summary>
        [JsonProperty("titleLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleLimit { get; set; }

        /// <summary>
        /// The orthogonal distance in pixels by which to displace the title from its position along
        /// the edge of the chart.
        ///
        /// __Default value:__ `10`
        /// </summary>
        [JsonProperty("titlePadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitlePadding { get; set; }
    }

    /// <summary>
    /// Legend configuration, which determines default properties for all
    /// [legends](https://vega.github.io/vega-lite/docs/legend.html). For a full list of legend
    /// configuration options, please see the [corresponding section of in the legend
    /// documentation](https://vega.github.io/vega-lite/docs/legend.html#config).
    /// </summary>
    public partial class LegendConfig
    {
        /// <summary>
        /// The height in pixels to clip symbol legend entries and limit their size.
        /// </summary>
        [JsonProperty("clipHeight", NullValueHandling = NullValueHandling.Ignore)]
        public double? ClipHeight { get; set; }

        /// <summary>
        /// The horizontal padding in pixels between symbol legend entries.
        ///
        /// __Default value:__ `10`.
        /// </summary>
        [JsonProperty("columnPadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? ColumnPadding { get; set; }

        /// <summary>
        /// The number of columns in which to arrange symbol legend entries. A value of `0` or lower
        /// indicates a single row with one column per entry.
        /// </summary>
        [JsonProperty("columns", NullValueHandling = NullValueHandling.Ignore)]
        public double? Columns { get; set; }

        /// <summary>
        /// Corner radius for the full legend.
        /// </summary>
        [JsonProperty("cornerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? CornerRadius { get; set; }

        /// <summary>
        /// Background fill color for the full legend.
        /// </summary>
        [JsonProperty("fillColor", NullValueHandling = NullValueHandling.Ignore)]
        public string FillColor { get; set; }

        /// <summary>
        /// The default direction (`"horizontal"` or `"vertical"`) for gradient legends.
        ///
        /// __Default value:__ `"vertical"`.
        /// </summary>
        [JsonProperty("gradientDirection", NullValueHandling = NullValueHandling.Ignore)]
        public Orient? GradientDirection { get; set; }

        /// <summary>
        /// Max legend length for a horizontal gradient when `config.legend.gradientLength` is
        /// undefined.
        ///
        /// __Default value:__ `200`
        /// </summary>
        [JsonProperty("gradientHorizontalMaxLength", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientHorizontalMaxLength { get; set; }

        /// <summary>
        /// Min legend length for a horizontal gradient when `config.legend.gradientLength` is
        /// undefined.
        ///
        /// __Default value:__ `100`
        /// </summary>
        [JsonProperty("gradientHorizontalMinLength", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientHorizontalMinLength { get; set; }

        /// <summary>
        /// The maximum allowed length in pixels of color ramp gradient labels.
        /// </summary>
        [JsonProperty("gradientLabelLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientLabelLimit { get; set; }

        /// <summary>
        /// Vertical offset in pixels for color ramp gradient labels.
        ///
        /// __Default value:__ `2`.
        /// </summary>
        [JsonProperty("gradientLabelOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientLabelOffset { get; set; }

        /// <summary>
        /// The length in pixels of the primary axis of a color gradient. This value corresponds to
        /// the height of a vertical gradient or the width of a horizontal gradient.
        ///
        /// __Default value:__ `200`.
        /// </summary>
        [JsonProperty("gradientLength", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientLength { get; set; }

        /// <summary>
        /// Opacity of the color gradient.
        /// </summary>
        [JsonProperty("gradientOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientOpacity { get; set; }

        /// <summary>
        /// The color of the gradient stroke, can be in hex color code or regular color name.
        ///
        /// __Default value:__ `"lightGray"`.
        /// </summary>
        [JsonProperty("gradientStrokeColor", NullValueHandling = NullValueHandling.Ignore)]
        public string GradientStrokeColor { get; set; }

        /// <summary>
        /// The width of the gradient stroke, in pixels.
        ///
        /// __Default value:__ `0`.
        /// </summary>
        [JsonProperty("gradientStrokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientStrokeWidth { get; set; }

        /// <summary>
        /// The thickness in pixels of the color gradient. This value corresponds to the width of a
        /// vertical gradient or the height of a horizontal gradient.
        ///
        /// __Default value:__ `16`.
        /// </summary>
        [JsonProperty("gradientThickness", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientThickness { get; set; }

        /// <summary>
        /// Max legend length for a vertical gradient when `config.legend.gradientLength` is
        /// undefined.
        ///
        /// __Default value:__ `200`
        /// </summary>
        [JsonProperty("gradientVerticalMaxLength", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientVerticalMaxLength { get; set; }

        /// <summary>
        /// Min legend length for a vertical gradient when `config.legend.gradientLength` is
        /// undefined.
        ///
        /// __Default value:__ `100`
        /// </summary>
        [JsonProperty("gradientVerticalMinLength", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientVerticalMinLength { get; set; }

        /// <summary>
        /// The alignment to apply to symbol legends rows and columns. The supported string values
        /// are `"all"`, `"each"` (the default), and `none`. For more information, see the [grid
        /// layout documentation](https://vega.github.io/vega/docs/layout).
        ///
        /// __Default value:__ `"each"`.
        /// </summary>
        [JsonProperty("gridAlign", NullValueHandling = NullValueHandling.Ignore)]
        public VgLayoutAlign? GridAlign { get; set; }

        /// <summary>
        /// The alignment of the legend label, can be left, center, or right.
        /// </summary>
        [JsonProperty("labelAlign", NullValueHandling = NullValueHandling.Ignore)]
        public Align? LabelAlign { get; set; }

        /// <summary>
        /// The position of the baseline of legend label, can be `"top"`, `"middle"`, `"bottom"`, or
        /// `"alphabetic"`.
        ///
        /// __Default value:__ `"middle"`.
        /// </summary>
        [JsonProperty("labelBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? LabelBaseline { get; set; }

        /// <summary>
        /// The color of the legend label, can be in hex color code or regular color name.
        /// </summary>
        [JsonProperty("labelColor", NullValueHandling = NullValueHandling.Ignore)]
        public string LabelColor { get; set; }

        /// <summary>
        /// The font of the legend label.
        /// </summary>
        [JsonProperty("labelFont", NullValueHandling = NullValueHandling.Ignore)]
        public string LabelFont { get; set; }

        /// <summary>
        /// The font size of legend label.
        ///
        /// __Default value:__ `10`.
        /// </summary>
        [JsonProperty("labelFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelFontSize { get; set; }

        /// <summary>
        /// The font weight of legend label.
        /// </summary>
        [JsonProperty("labelFontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? LabelFontWeight { get; set; }

        /// <summary>
        /// Maximum allowed pixel width of axis tick labels.
        ///
        /// __Default value:__ `160`.
        /// </summary>
        [JsonProperty("labelLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelLimit { get; set; }

        /// <summary>
        /// The offset of the legend label.
        /// </summary>
        [JsonProperty("labelOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelOffset { get; set; }

        /// <summary>
        /// Opacity of labels.
        /// </summary>
        [JsonProperty("labelOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelOpacity { get; set; }

        /// <summary>
        /// The strategy to use for resolving overlap of labels in gradient legends. If `false`, no
        /// overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing
        /// every other label is used. If set to `"greedy"`, a linear scan of the labels is
        /// performed, removing any label that overlaps with the last visible label (this often works
        /// better for log-scaled axes).
        ///
        /// __Default value:__ `"greedy"` for `log scales otherwise `true`.
        /// *
        /// </summary>
        [JsonProperty("labelOverlap", NullValueHandling = NullValueHandling.Ignore)]
        public LabelOverlap? LabelOverlap { get; set; }

        /// <summary>
        /// Padding in pixels between the legend and legend labels.
        /// </summary>
        [JsonProperty("labelPadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelPadding { get; set; }

        /// <summary>
        /// The offset in pixels by which to displace the legend from the data rectangle and axes.
        ///
        /// __Default value:__ `18`.
        /// </summary>
        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? Offset { get; set; }

        /// <summary>
        /// The orientation of the legend, which determines how the legend is positioned within the
        /// scene. One of "left", "right", "top-left", "top-right", "bottom-left", "bottom-right",
        /// "none".
        ///
        /// __Default value:__ `"right"`
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public LegendOrient? Orient { get; set; }

        /// <summary>
        /// The padding between the border and content of the legend group.
        ///
        /// __Default value:__ `0`.
        /// </summary>
        [JsonProperty("padding", NullValueHandling = NullValueHandling.Ignore)]
        public double? Padding { get; set; }

        /// <summary>
        /// The vertical padding in pixels between symbol legend entries.
        ///
        /// __Default value:__ `2`.
        /// </summary>
        [JsonProperty("rowPadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? RowPadding { get; set; }

        /// <summary>
        /// Whether month names and weekday names should be abbreviated.
        ///
        /// __Default value:__  `false`
        /// </summary>
        [JsonProperty("shortTimeLabels", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShortTimeLabels { get; set; }

        /// <summary>
        /// Border stroke color for the full legend.
        /// </summary>
        [JsonProperty("strokeColor", NullValueHandling = NullValueHandling.Ignore)]
        public string StrokeColor { get; set; }

        /// <summary>
        /// Border stroke dash pattern for the full legend.
        /// </summary>
        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] StrokeDash { get; set; }

        /// <summary>
        /// Border stroke width for the full legend.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeWidth { get; set; }

        /// <summary>
        /// Default fill color for legend symbols. Only applied if there is no `"fill"` scale color
        /// encoding for the legend.
        ///
        /// __Default value:__ `"transparent"`.
        /// </summary>
        [JsonProperty("symbolBaseFillColor", NullValueHandling = NullValueHandling.Ignore)]
        public string SymbolBaseFillColor { get; set; }

        /// <summary>
        /// Default stroke color for legend symbols. Only applied if there is no `"fill"` scale color
        /// encoding for the legend.
        ///
        /// __Default value:__ `"gray"`.
        /// </summary>
        [JsonProperty("symbolBaseStrokeColor", NullValueHandling = NullValueHandling.Ignore)]
        public string SymbolBaseStrokeColor { get; set; }

        /// <summary>
        /// The default direction (`"horizontal"` or `"vertical"`) for symbol legends.
        ///
        /// __Default value:__ `"vertical"`.
        /// </summary>
        [JsonProperty("symbolDirection", NullValueHandling = NullValueHandling.Ignore)]
        public Orient? SymbolDirection { get; set; }

        /// <summary>
        /// The color of the legend symbol,
        /// </summary>
        [JsonProperty("symbolFillColor", NullValueHandling = NullValueHandling.Ignore)]
        public string SymbolFillColor { get; set; }

        /// <summary>
        /// Horizontal pixel offset for legend symbols.
        ///
        /// __Default value:__ `0`.
        /// </summary>
        [JsonProperty("symbolOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? SymbolOffset { get; set; }

        /// <summary>
        /// Opacity of the legend symbols.
        /// </summary>
        [JsonProperty("symbolOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? SymbolOpacity { get; set; }

        /// <summary>
        /// The size of the legend symbol, in pixels.
        ///
        /// __Default value:__ `100`.
        /// </summary>
        [JsonProperty("symbolSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? SymbolSize { get; set; }

        /// <summary>
        /// Stroke color for legend symbols.
        /// </summary>
        [JsonProperty("symbolStrokeColor", NullValueHandling = NullValueHandling.Ignore)]
        public string SymbolStrokeColor { get; set; }

        /// <summary>
        /// The width of the symbol's stroke.
        ///
        /// __Default value:__ `1.5`.
        /// </summary>
        [JsonProperty("symbolStrokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? SymbolStrokeWidth { get; set; }

        /// <summary>
        /// Default shape type (such as "circle") for legend symbols.
        /// Can be one of ``"circle"`, `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`,
        /// `"triangle-down"`, `"triangle-right"`, or `"triangle-left"`.
        /// * In addition to a set of built-in shapes, custom shapes can be defined using [SVG path
        /// strings](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).
        /// *
        /// * __Default value:__ `"circle"`.
        /// *
        /// </summary>
        [JsonProperty("symbolType", NullValueHandling = NullValueHandling.Ignore)]
        public string SymbolType { get; set; }

        /// <summary>
        /// Horizontal text alignment for legend titles.
        ///
        /// __Default value:__ `"left"`.
        /// </summary>
        [JsonProperty("titleAlign", NullValueHandling = NullValueHandling.Ignore)]
        public Align? TitleAlign { get; set; }

        /// <summary>
        /// Vertical text baseline for legend titles.
        ///
        /// __Default value:__ `"top"`.
        /// </summary>
        [JsonProperty("titleBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? TitleBaseline { get; set; }

        /// <summary>
        /// The color of the legend title, can be in hex color code or regular color name.
        /// </summary>
        [JsonProperty("titleColor", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleColor { get; set; }

        /// <summary>
        /// The font of the legend title.
        /// </summary>
        [JsonProperty("titleFont", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleFont { get; set; }

        /// <summary>
        /// The font size of the legend title.
        /// </summary>
        [JsonProperty("titleFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleFontSize { get; set; }

        /// <summary>
        /// The font weight of the legend title.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("titleFontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? TitleFontWeight { get; set; }

        /// <summary>
        /// Maximum allowed pixel width of axis titles.
        ///
        /// __Default value:__ `180`.
        /// </summary>
        [JsonProperty("titleLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleLimit { get; set; }

        /// <summary>
        /// Opacity of the legend title.
        /// </summary>
        [JsonProperty("titleOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleOpacity { get; set; }

        /// <summary>
        /// The padding, in pixels, between title and legend.
        ///
        /// __Default value:__ `5`.
        /// </summary>
        [JsonProperty("titlePadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitlePadding { get; set; }
    }

    /// <summary>
    /// Line-Specific Config
    ///
    /// Trail-Specific Config
    /// </summary>
    public partial class LineConfig
    {
        /// <summary>
        /// The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
        /// </summary>
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public Align? Align { get; set; }

        /// <summary>
        /// The rotation angle of the text, in degrees.
        /// </summary>
        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Angle { get; set; }

        /// <summary>
        /// The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
        ///
        /// __Default value:__ `"middle"`
        /// </summary>
        [JsonProperty("baseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? Baseline { get; set; }

        /// <summary>
        /// Default color.  Note that `fill` and `stroke` have higher precedence than `color` and
        /// will override `color`.
        ///
        /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public string Color { get; set; }

        /// <summary>
        /// The radius in pixels of rounded rectangle corners.
        ///
        /// __Default value:__ `0`
        /// </summary>
        [JsonProperty("cornerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? CornerRadius { get; set; }

        /// <summary>
        /// The mouse cursor used over the mark. Any valid [CSS cursor
        /// type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
        /// </summary>
        [JsonProperty("cursor", NullValueHandling = NullValueHandling.Ignore)]
        public Cursor? Cursor { get; set; }

        /// <summary>
        /// The direction of the text. One of `"ltr"` (left-to-right) or `"rtl"` (right-to-left).
        /// This property determines on which side is truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"ltr"`
        /// </summary>
        [JsonProperty("dir", NullValueHandling = NullValueHandling.Ignore)]
        public Dir? Dir { get; set; }

        /// <summary>
        /// The horizontal offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dx", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dx { get; set; }

        /// <summary>
        /// The vertical offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dy", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dy { get; set; }

        /// <summary>
        /// The ellipsis string for text truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"…"`
        /// </summary>
        [JsonProperty("ellipsis", NullValueHandling = NullValueHandling.Ignore)]
        public string Ellipsis { get; set; }

        /// <summary>
        /// Default Fill Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public string Fill { get; set; }

        /// <summary>
        /// Whether the mark's color should be used as fill color instead of stroke color.
        ///
        /// __Default value:__ `false` for `point`, `line` and `rule`; otherwise, `true`.
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("filled", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Filled { get; set; }

        /// <summary>
        /// The fill opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? FillOpacity { get; set; }

        /// <summary>
        /// The typeface to set the text in (e.g., `"Helvetica Neue"`).
        /// </summary>
        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public string Font { get; set; }

        /// <summary>
        /// The font size, in pixels.
        /// </summary>
        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? FontSize { get; set; }

        /// <summary>
        /// The font style (e.g., `"italic"`).
        /// </summary>
        [JsonProperty("fontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public FontStyle? FontStyle { get; set; }

        /// <summary>
        /// The font weight.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? FontWeight { get; set; }

        /// <summary>
        /// A URL to load upon mouse click. If defined, the mark acts as a hyperlink.
        /// </summary>
        [JsonProperty("href", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Href { get; set; }

        /// <summary>
        /// The line interpolation method to use for line and area marks. One of the following:
        /// - `"linear"`: piecewise linear segments, as in a polyline.
        /// - `"linear-closed"`: close the linear segments to form a polygon.
        /// - `"step"`: alternate between horizontal and vertical segments, as in a step function.
        /// - `"step-before"`: alternate between vertical and horizontal segments, as in a step
        /// function.
        /// - `"step-after"`: alternate between horizontal and vertical segments, as in a step
        /// function.
        /// - `"basis"`: a B-spline, with control point duplication on the ends.
        /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
        /// - `"basis-closed"`: a closed B-spline, as in a loop.
        /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
        /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
        /// will intersect other control points.
        /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
        /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
        /// spline.
        /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
        /// </summary>
        [JsonProperty("interpolate", NullValueHandling = NullValueHandling.Ignore)]
        public Interpolate? Interpolate { get; set; }

        /// <summary>
        /// The maximum length of the text mark in pixels. The text value will be automatically
        /// truncated if the rendered size exceeds the limit.
        ///
        /// __Default value:__ `0`, indicating no limit
        /// </summary>
        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public double? Limit { get; set; }

        /// <summary>
        /// The overall opacity (value between [0,1]).
        ///
        /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
        /// `square` marks or layered `bar` charts and `1` otherwise.
        /// </summary>
        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? Opacity { get; set; }

        /// <summary>
        /// The orientation of a non-stacked bar, tick, area, and line charts.
        /// The value is either horizontal (default) or vertical.
        /// - For bar, rule and tick, this determines whether the size of the bar and tick
        /// should be applied to x or y dimension.
        /// - For area, this property determines the orient property of the Vega output.
        /// - For line and trail marks, this property determines the sort order of the points in the
        /// line
        /// if `config.sortLineBy` is not specified.
        /// For stacked charts, this is always determined by the orientation of the stack;
        /// therefore explicitly specified value will be ignored.
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public Orient? Orient { get; set; }

        /// <summary>
        /// A flag for overlaying points on top of line or area marks, or an object defining the
        /// properties of the overlayed points.
        ///
        /// - If this property is `"transparent"`, transparent points will be used (for enhancing
        /// tooltips and selections).
        ///
        /// - If this property is an empty object (`{}`) or `true`, filled points with default
        /// properties will be used.
        ///
        /// - If this property is `false`, no points would be automatically added to line or area
        /// marks.
        ///
        /// __Default value:__ `false`.
        /// </summary>
        [JsonProperty("point", NullValueHandling = NullValueHandling.Ignore)]
        public PointUnion? Point { get; set; }

        /// <summary>
        /// Polar coordinate radial offset, in pixels, of the text label from the origin determined
        /// by the `x` and `y` properties.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        /// <summary>
        /// The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`,
        /// `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
        ///
        /// __Default value:__ `"circle"`
        /// </summary>
        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public string Shape { get; set; }

        /// <summary>
        /// Default size for marks.
        /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. For
        /// example: in the case of circles, the radius is determined in part by the square root of
        /// the size value.
        /// - For `bar`, this represents the band size of the bar, in pixels.
        /// - For `text`, this represents the font size, in pixels.
        ///
        /// __Default value:__ `30` for point, circle, square marks; `rangeStep` - 1 for bar marks
        /// with discrete dimensions; `5` for bar marks with continuous dimensions; `11` for text
        /// marks.
        /// </summary>
        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public double? Size { get; set; }

        /// <summary>
        /// Default Stroke Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public string Stroke { get; set; }

        /// <summary>
        /// The stroke cap for line ending style. One of `"butt"`, `"round"`, or `"square"`.
        ///
        /// __Default value:__ `"square"`
        /// </summary>
        [JsonProperty("strokeCap", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeCap? StrokeCap { get; set; }

        /// <summary>
        /// An array of alternating stroke, space lengths for creating dashed or dotted lines.
        /// </summary>
        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] StrokeDash { get; set; }

        /// <summary>
        /// The offset (in pixels) into which to begin drawing with the stroke dash array.
        /// </summary>
        [JsonProperty("strokeDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeDashOffset { get; set; }

        /// <summary>
        /// The stroke line join method. One of `"miter"`, `"round"` or `"bevel"`.
        ///
        /// __Default value:__ `"miter"`
        /// </summary>
        [JsonProperty("strokeJoin", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeJoin? StrokeJoin { get; set; }

        /// <summary>
        /// The miter limit at which to bevel a line join.
        /// </summary>
        [JsonProperty("strokeMiterLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeMiterLimit { get; set; }

        /// <summary>
        /// The stroke opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeOpacity { get; set; }

        /// <summary>
        /// The stroke width, in pixels.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeWidth { get; set; }

        /// <summary>
        /// Depending on the interpolation type, sets the tension parameter (for line and area marks).
        /// </summary>
        [JsonProperty("tension", NullValueHandling = NullValueHandling.Ignore)]
        public double? Tension { get; set; }

        /// <summary>
        /// Placeholder text if the `text` channel is not specified
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        /// <summary>
        /// Polar coordinate angle, in radians, of the text label from the origin determined by the
        /// `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark
        /// `startAngle` and `endAngle` properties: angles are measured in radians, with `0`
        /// indicating "north".
        /// </summary>
        [JsonProperty("theta", NullValueHandling = NullValueHandling.Ignore)]
        public double? Theta { get; set; }

        /// <summary>
        /// The tooltip text string to show upon mouse hover or an object defining which fields
        /// should the tooltip be derived from.
        ///
        /// - If `tooltip` is `{"content": "encoding"}`, then all fields from `encoding` will be
        /// used.
        /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
        /// data point will be used.
        /// </summary>
        [JsonProperty("tooltip", NullValueHandling = NullValueHandling.Ignore)]
        public Tooltip? Tooltip { get; set; }
    }

    public partial class PaddingClass
    {
        [JsonProperty("bottom", NullValueHandling = NullValueHandling.Ignore)]
        public double? Bottom { get; set; }

        [JsonProperty("left", NullValueHandling = NullValueHandling.Ignore)]
        public double? Left { get; set; }

        [JsonProperty("right", NullValueHandling = NullValueHandling.Ignore)]
        public double? Right { get; set; }

        [JsonProperty("top", NullValueHandling = NullValueHandling.Ignore)]
        public double? Top { get; set; }
    }

    /// <summary>
    /// Projection configuration, which determines default properties for all
    /// [projections](https://vega.github.io/vega-lite/docs/projection.html). For a full list of
    /// projection configuration options, please see the [corresponding section of the projection
    /// documentation](https://vega.github.io/vega-lite/docs/projection.html#config).
    ///
    /// Any property of Projection can be in config
    ///
    /// An object defining properties of geographic projection, which will be applied to `shape`
    /// path for `"geoshape"` marks
    /// and to `latitude` and `"longitude"` channels for other marks.
    ///
    /// An object defining properties of the geographic projection shared by underlying layers.
    /// </summary>
    public partial class Projection
    {
        /// <summary>
        /// Sets the projection’s center to the specified center, a two-element array of longitude
        /// and latitude in degrees.
        ///
        /// __Default value:__ `[0, 0]`
        /// </summary>
        [JsonProperty("center", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Center { get; set; }

        /// <summary>
        /// Sets the projection’s clipping circle radius to the specified angle in degrees. If
        /// `null`, switches to [antimeridian](http://bl.ocks.org/mbostock/3788999) cutting rather
        /// than small-circle clipping.
        /// </summary>
        [JsonProperty("clipAngle", NullValueHandling = NullValueHandling.Ignore)]
        public double? ClipAngle { get; set; }

        /// <summary>
        /// Sets the projection’s viewport clip extent to the specified bounds in pixels. The extent
        /// bounds are specified as an array `[[x0, y0], [x1, y1]]`, where `x0` is the left-side of
        /// the viewport, `y0` is the top, `x1` is the right and `y1` is the bottom. If `null`, no
        /// viewport clipping is performed.
        /// </summary>
        [JsonProperty("clipExtent", NullValueHandling = NullValueHandling.Ignore)]
        public double[][] ClipExtent { get; set; }

        [JsonProperty("coefficient", NullValueHandling = NullValueHandling.Ignore)]
        public double? Coefficient { get; set; }

        [JsonProperty("distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? Distance { get; set; }

        [JsonProperty("fraction", NullValueHandling = NullValueHandling.Ignore)]
        public double? Fraction { get; set; }

        [JsonProperty("lobes", NullValueHandling = NullValueHandling.Ignore)]
        public double? Lobes { get; set; }

        [JsonProperty("parallel", NullValueHandling = NullValueHandling.Ignore)]
        public double? Parallel { get; set; }

        /// <summary>
        /// Sets the threshold for the projection’s [adaptive
        /// resampling](http://bl.ocks.org/mbostock/3795544) to the specified value in pixels. This
        /// value corresponds to the [Douglas–Peucker
        /// distance](http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm).
        /// If precision is not specified, returns the projection’s current resampling precision
        /// which defaults to `√0.5 ≅ 0.70710…`.
        /// </summary>
        [JsonProperty("precision", NullValueHandling = NullValueHandling.Ignore)]
        public string Precision { get; set; }

        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        [JsonProperty("ratio", NullValueHandling = NullValueHandling.Ignore)]
        public double? Ratio { get; set; }

        /// <summary>
        /// Sets the projection’s three-axis rotation to the specified angles, which must be a two-
        /// or three-element array of numbers [`lambda`, `phi`, `gamma`] specifying the rotation
        /// angles in degrees about each spherical axis. (These correspond to yaw, pitch and roll.)
        ///
        /// __Default value:__ `[0, 0, 0]`
        /// </summary>
        [JsonProperty("rotate", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Rotate { get; set; }

        [JsonProperty("spacing", NullValueHandling = NullValueHandling.Ignore)]
        public double? Spacing { get; set; }

        [JsonProperty("tilt", NullValueHandling = NullValueHandling.Ignore)]
        public double? Tilt { get; set; }

        /// <summary>
        /// The cartographic projection to use. This value is case-insensitive, for example
        /// `"albers"` and `"Albers"` indicate the same projection type. You can find all valid
        /// projection types [in the
        /// documentation](https://vega.github.io/vega-lite/docs/projection.html#projection-types).
        ///
        /// __Default value:__ `mercator`
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public VgProjectionType? Type { get; set; }
    }

    public partial class VgScheme
    {
        [JsonProperty("count", NullValueHandling = NullValueHandling.Ignore)]
        public double? Count { get; set; }

        [JsonProperty("extent", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Extent { get; set; }

        [JsonProperty("scheme", NullValueHandling = NullValueHandling.Ignore)]
        public string Scheme { get; set; }

        [JsonProperty("step", NullValueHandling = NullValueHandling.Ignore)]
        public double? Step { get; set; }
    }

    /// <summary>
    /// Scale configuration determines default properties for all
    /// [scales](https://vega.github.io/vega-lite/docs/scale.html). For a full list of scale
    /// configuration options, please see the [corresponding section of the scale
    /// documentation](https://vega.github.io/vega-lite/docs/scale.html#config).
    /// </summary>
    public partial class ScaleConfig
    {
        /// <summary>
        /// Default inner padding for `x` and `y` band-ordinal scales.
        ///
        /// __Default value:__ `0.1`
        /// </summary>
        [JsonProperty("bandPaddingInner", NullValueHandling = NullValueHandling.Ignore)]
        public double? BandPaddingInner { get; set; }

        /// <summary>
        /// Default outer padding for `x` and `y` band-ordinal scales.
        /// If not specified, by default, band scale's paddingOuter is paddingInner/2.
        /// </summary>
        [JsonProperty("bandPaddingOuter", NullValueHandling = NullValueHandling.Ignore)]
        public double? BandPaddingOuter { get; set; }

        /// <summary>
        /// If true, values that exceed the data domain are clamped to either the minimum or maximum
        /// range value
        /// </summary>
        [JsonProperty("clamp", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Clamp { get; set; }

        /// <summary>
        /// Default padding for continuous scales.
        ///
        /// __Default:__ `5` for continuous x-scale of a vertical bar and continuous y-scale of a
        /// horizontal bar.; `0` otherwise.
        /// </summary>
        [JsonProperty("continuousPadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? ContinuousPadding { get; set; }

        /// <summary>
        /// The default max value for mapping quantitative fields to bar's size/bandSize.
        ///
        /// If undefined (default), we will use the scale's `rangeStep` - 1.
        /// </summary>
        [JsonProperty("maxBandSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxBandSize { get; set; }

        /// <summary>
        /// The default max value for mapping quantitative fields to text's size/fontSize.
        ///
        /// __Default value:__ `40`
        /// </summary>
        [JsonProperty("maxFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxFontSize { get; set; }

        /// <summary>
        /// Default max opacity for mapping a field to opacity.
        ///
        /// __Default value:__ `0.8`
        /// </summary>
        [JsonProperty("maxOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxOpacity { get; set; }

        /// <summary>
        /// Default max value for point size scale.
        /// </summary>
        [JsonProperty("maxSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxSize { get; set; }

        /// <summary>
        /// Default max strokeWidth for the scale of strokeWidth for rule and line marks and of size
        /// for trail marks.
        ///
        /// __Default value:__ `4`
        /// </summary>
        [JsonProperty("maxStrokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxStrokeWidth { get; set; }

        /// <summary>
        /// The default min value for mapping quantitative fields to bar and tick's size/bandSize
        /// scale with zero=false.
        ///
        /// __Default value:__ `2`
        /// </summary>
        [JsonProperty("minBandSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinBandSize { get; set; }

        /// <summary>
        /// The default min value for mapping quantitative fields to tick's size/fontSize scale with
        /// zero=false
        ///
        /// __Default value:__ `8`
        /// </summary>
        [JsonProperty("minFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinFontSize { get; set; }

        /// <summary>
        /// Default minimum opacity for mapping a field to opacity.
        ///
        /// __Default value:__ `0.3`
        /// </summary>
        [JsonProperty("minOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinOpacity { get; set; }

        /// <summary>
        /// Default minimum value for point size scale with zero=false.
        ///
        /// __Default value:__ `9`
        /// </summary>
        [JsonProperty("minSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinSize { get; set; }

        /// <summary>
        /// Default minimum strokeWidth for the scale of strokeWidth for rule and line marks and of
        /// size for trail marks with zero=false.
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("minStrokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinStrokeWidth { get; set; }

        /// <summary>
        /// Default outer padding for `x` and `y` point-ordinal scales.
        ///
        /// __Default value:__ `0.5`
        /// </summary>
        [JsonProperty("pointPadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? PointPadding { get; set; }

        /// <summary>
        /// Default range cardinality for
        /// [`quantile`](https://vega.github.io/vega-lite/docs/scale.html#quantile) scale.
        ///
        /// __Default value:__ `4`
        /// </summary>
        [JsonProperty("quantileCount", NullValueHandling = NullValueHandling.Ignore)]
        public double? QuantileCount { get; set; }

        /// <summary>
        /// Default range cardinality for
        /// [`quantize`](https://vega.github.io/vega-lite/docs/scale.html#quantize) scale.
        ///
        /// __Default value:__ `4`
        /// </summary>
        [JsonProperty("quantizeCount", NullValueHandling = NullValueHandling.Ignore)]
        public double? QuantizeCount { get; set; }

        /// <summary>
        /// Default range step for band and point scales of (1) the `y` channel
        /// and (2) the `x` channel when the mark is not `text`.
        ///
        /// __Default value:__ `21`
        /// </summary>
        [JsonProperty("rangeStep")]
        public double? RangeStep { get; set; }

        /// <summary>
        /// If true, rounds numeric output values to integers.
        /// This can be helpful for snapping to the pixel grid.
        /// (Only available for `x`, `y`, and `size` scales.)
        /// </summary>
        [JsonProperty("round", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Round { get; set; }

        /// <summary>
        /// Default range step for `x` band and point scales of text marks.
        ///
        /// __Default value:__ `90`
        /// </summary>
        [JsonProperty("textXRangeStep", NullValueHandling = NullValueHandling.Ignore)]
        public double? TextXRangeStep { get; set; }

        /// <summary>
        /// Use the source data range before aggregation as scale domain instead of aggregated data
        /// for aggregate axis.
        ///
        /// This is equivalent to setting `domain` to `"unaggregate"` for aggregated _quantitative_
        /// fields by default.
        ///
        /// This property only works with aggregate functions that produce values within the raw data
        /// domain (`"mean"`, `"average"`, `"median"`, `"q1"`, `"q3"`, `"min"`, `"max"`). For other
        /// aggregations that produce values outside of the raw data domain (e.g. `"count"`,
        /// `"sum"`), this property is ignored.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("useUnaggregatedDomain", NullValueHandling = NullValueHandling.Ignore)]
        public bool? UseUnaggregatedDomain { get; set; }
    }

    /// <summary>
    /// An object hash for defining default properties for each type of selections.
    /// </summary>
    public partial class SelectionConfig
    {
        /// <summary>
        /// The default definition for an
        /// [`interval`](https://vega.github.io/vega-lite/docs/selection.html#type) selection. All
        /// properties and transformations
        /// for an interval selection definition (except `type`) may be specified here.
        ///
        /// For instance, setting `interval` to `{"translate": false}` disables the ability to move
        /// interval selections by default.
        /// </summary>
        [JsonProperty("interval", NullValueHandling = NullValueHandling.Ignore)]
        public IntervalSelectionConfig Interval { get; set; }

        /// <summary>
        /// The default definition for a
        /// [`multi`](https://vega.github.io/vega-lite/docs/selection.html#type) selection. All
        /// properties and transformations
        /// for a multi selection definition (except `type`) may be specified here.
        ///
        /// For instance, setting `multi` to `{"toggle": "event.altKey"}` adds additional values to
        /// multi selections when clicking with the alt-key pressed by default.
        /// </summary>
        [JsonProperty("multi", NullValueHandling = NullValueHandling.Ignore)]
        public MultiSelectionConfig Multi { get; set; }

        /// <summary>
        /// The default definition for a
        /// [`single`](https://vega.github.io/vega-lite/docs/selection.html#type) selection. All
        /// properties and transformations
        /// for a single selection definition (except `type`) may be specified here.
        ///
        /// For instance, setting `single` to `{"on": "dblclick"}` populates single selections on
        /// double-click by default.
        /// </summary>
        [JsonProperty("single", NullValueHandling = NullValueHandling.Ignore)]
        public SingleSelectionConfig Single { get; set; }
    }

    /// <summary>
    /// The default definition for an
    /// [`interval`](https://vega.github.io/vega-lite/docs/selection.html#type) selection. All
    /// properties and transformations
    /// for an interval selection definition (except `type`) may be specified here.
    ///
    /// For instance, setting `interval` to `{"translate": false}` disables the ability to move
    /// interval selections by default.
    /// </summary>
    public partial class IntervalSelectionConfig
    {
        /// <summary>
        /// Establishes a two-way binding between the interval selection and the scales
        /// used within the same view. This allows a user to interactively pan and
        /// zoom the view.
        /// </summary>
        [JsonProperty("bind", NullValueHandling = NullValueHandling.Ignore)]
        public BindEnum? Bind { get; set; }

        /// <summary>
        /// By default, all data values are considered to lie within an empty selection.
        /// When set to `none`, empty selections contain no data values.
        /// </summary>
        [JsonProperty("empty", NullValueHandling = NullValueHandling.Ignore)]
        public Empty? Empty { get; set; }

        /// <summary>
        /// An array of encoding channels. The corresponding data field values
        /// must match for a data tuple to fall within the selection.
        /// </summary>
        [JsonProperty("encodings", NullValueHandling = NullValueHandling.Ignore)]
        public SingleDefChannel[] Encodings { get; set; }

        /// <summary>
        /// An array of field names whose values must match for a data tuple to
        /// fall within the selection.
        /// </summary>
        [JsonProperty("fields", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Fields { get; set; }

        /// <summary>
        /// An interval selection also adds a rectangle mark to depict the
        /// extents of the interval. The `mark` property can be used to customize the
        /// appearance of the mark.
        /// </summary>
        [JsonProperty("mark", NullValueHandling = NullValueHandling.Ignore)]
        public BrushConfig Mark { get; set; }

        /// <summary>
        /// A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or
        /// selector) that triggers the selection.
        /// For interval selections, the event stream must specify a [start and
        /// end](https://vega.github.io/vega/docs/event-streams/#between-filters).
        /// </summary>
        [JsonProperty("on")]
        public object On { get; set; }

        /// <summary>
        /// With layered and multi-view displays, a strategy that determines how
        /// selections' data queries are resolved when applied in a filter transform,
        /// conditional encoding rule, or scale domain.
        /// </summary>
        [JsonProperty("resolve", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionResolution? Resolve { get; set; }

        /// <summary>
        /// When truthy, allows a user to interactively move an interval selection
        /// back-and-forth. Can be `true`, `false` (to disable panning), or a
        /// [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/)
        /// which must include a start and end event to trigger continuous panning.
        ///
        /// __Default value:__ `true`, which corresponds to
        /// `[mousedown, window:mouseup] > window:mousemove!` which corresponds to
        /// clicks and dragging within an interval selection to reposition it.
        /// </summary>
        [JsonProperty("translate", NullValueHandling = NullValueHandling.Ignore)]
        public Translate? Translate { get; set; }

        /// <summary>
        /// When truthy, allows a user to interactively resize an interval selection.
        /// Can be `true`, `false` (to disable zooming), or a [Vega event stream
        /// definition](https://vega.github.io/vega/docs/event-streams/). Currently,
        /// only `wheel` events are supported.
        ///
        ///
        /// __Default value:__ `true`, which corresponds to `wheel!`.
        /// </summary>
        [JsonProperty("zoom", NullValueHandling = NullValueHandling.Ignore)]
        public Translate? Zoom { get; set; }
    }

    /// <summary>
    /// An interval selection also adds a rectangle mark to depict the
    /// extents of the interval. The `mark` property can be used to customize the
    /// appearance of the mark.
    /// </summary>
    public partial class BrushConfig
    {
        /// <summary>
        /// The fill color of the interval mark.
        ///
        /// __Default value:__ `#333333`
        /// </summary>
        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public string Fill { get; set; }

        /// <summary>
        /// The fill opacity of the interval mark (a value between 0 and 1).
        ///
        /// __Default value:__ `0.125`
        /// </summary>
        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? FillOpacity { get; set; }

        /// <summary>
        /// The stroke color of the interval mark.
        ///
        /// __Default value:__ `#ffffff`
        /// </summary>
        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public string Stroke { get; set; }

        /// <summary>
        /// An array of alternating stroke and space lengths,
        /// for creating dashed or dotted lines.
        /// </summary>
        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] StrokeDash { get; set; }

        /// <summary>
        /// The offset (in pixels) with which to begin drawing the stroke dash array.
        /// </summary>
        [JsonProperty("strokeDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeDashOffset { get; set; }

        /// <summary>
        /// The stroke opacity of the interval mark (a value between 0 and 1).
        /// </summary>
        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeOpacity { get; set; }

        /// <summary>
        /// The stroke width of the interval mark.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeWidth { get; set; }
    }

    /// <summary>
    /// The default definition for a
    /// [`multi`](https://vega.github.io/vega-lite/docs/selection.html#type) selection. All
    /// properties and transformations
    /// for a multi selection definition (except `type`) may be specified here.
    ///
    /// For instance, setting `multi` to `{"toggle": "event.altKey"}` adds additional values to
    /// multi selections when clicking with the alt-key pressed by default.
    /// </summary>
    public partial class MultiSelectionConfig
    {
        /// <summary>
        /// By default, all data values are considered to lie within an empty selection.
        /// When set to `none`, empty selections contain no data values.
        /// </summary>
        [JsonProperty("empty", NullValueHandling = NullValueHandling.Ignore)]
        public Empty? Empty { get; set; }

        /// <summary>
        /// An array of encoding channels. The corresponding data field values
        /// must match for a data tuple to fall within the selection.
        /// </summary>
        [JsonProperty("encodings", NullValueHandling = NullValueHandling.Ignore)]
        public SingleDefChannel[] Encodings { get; set; }

        /// <summary>
        /// An array of field names whose values must match for a data tuple to
        /// fall within the selection.
        /// </summary>
        [JsonProperty("fields", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Fields { get; set; }

        /// <summary>
        /// When true, an invisible voronoi diagram is computed to accelerate discrete
        /// selection. The data value _nearest_ the mouse cursor is added to the selection.
        ///
        /// See the [nearest transform](https://vega.github.io/vega-lite/docs/nearest.html)
        /// documentation for more information.
        /// </summary>
        [JsonProperty("nearest", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Nearest { get; set; }

        /// <summary>
        /// A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or
        /// selector) that triggers the selection.
        /// For interval selections, the event stream must specify a [start and
        /// end](https://vega.github.io/vega/docs/event-streams/#between-filters).
        /// </summary>
        [JsonProperty("on")]
        public object On { get; set; }

        /// <summary>
        /// With layered and multi-view displays, a strategy that determines how
        /// selections' data queries are resolved when applied in a filter transform,
        /// conditional encoding rule, or scale domain.
        /// </summary>
        [JsonProperty("resolve", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionResolution? Resolve { get; set; }

        /// <summary>
        /// Controls whether data values should be toggled or only ever inserted into
        /// multi selections. Can be `true`, `false` (for insertion only), or a
        /// [Vega expression](https://vega.github.io/vega/docs/expressions/).
        ///
        /// __Default value:__ `true`, which corresponds to `event.shiftKey` (i.e.,
        /// data values are toggled when a user interacts with the shift-key pressed).
        ///
        /// See the [toggle transform](https://vega.github.io/vega-lite/docs/toggle.html)
        /// documentation for more information.
        /// </summary>
        [JsonProperty("toggle", NullValueHandling = NullValueHandling.Ignore)]
        public Translate? Toggle { get; set; }
    }

    /// <summary>
    /// The default definition for a
    /// [`single`](https://vega.github.io/vega-lite/docs/selection.html#type) selection. All
    /// properties and transformations
    /// for a single selection definition (except `type`) may be specified here.
    ///
    /// For instance, setting `single` to `{"on": "dblclick"}` populates single selections on
    /// double-click by default.
    /// </summary>
    public partial class SingleSelectionConfig
    {
        /// <summary>
        /// Establish a two-way binding between a single selection and input elements
        /// (also known as dynamic query widgets). A binding takes the form of
        /// Vega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind)
        /// or can be a mapping between projected field/encodings and binding definitions.
        ///
        /// See the [bind transform](https://vega.github.io/vega-lite/docs/bind.html) documentation
        /// for more information.
        /// </summary>
        [JsonProperty("bind", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, BindValue> Bind { get; set; }

        /// <summary>
        /// By default, all data values are considered to lie within an empty selection.
        /// When set to `none`, empty selections contain no data values.
        /// </summary>
        [JsonProperty("empty", NullValueHandling = NullValueHandling.Ignore)]
        public Empty? Empty { get; set; }

        /// <summary>
        /// An array of encoding channels. The corresponding data field values
        /// must match for a data tuple to fall within the selection.
        /// </summary>
        [JsonProperty("encodings", NullValueHandling = NullValueHandling.Ignore)]
        public SingleDefChannel[] Encodings { get; set; }

        /// <summary>
        /// An array of field names whose values must match for a data tuple to
        /// fall within the selection.
        /// </summary>
        [JsonProperty("fields", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Fields { get; set; }

        /// <summary>
        /// When true, an invisible voronoi diagram is computed to accelerate discrete
        /// selection. The data value _nearest_ the mouse cursor is added to the selection.
        ///
        /// See the [nearest transform](https://vega.github.io/vega-lite/docs/nearest.html)
        /// documentation for more information.
        /// </summary>
        [JsonProperty("nearest", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Nearest { get; set; }

        /// <summary>
        /// A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or
        /// selector) that triggers the selection.
        /// For interval selections, the event stream must specify a [start and
        /// end](https://vega.github.io/vega/docs/event-streams/#between-filters).
        /// </summary>
        [JsonProperty("on")]
        public object On { get; set; }

        /// <summary>
        /// With layered and multi-view displays, a strategy that determines how
        /// selections' data queries are resolved when applied in a filter transform,
        /// conditional encoding rule, or scale domain.
        /// </summary>
        [JsonProperty("resolve", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionResolution? Resolve { get; set; }
    }

    public partial class Binding
    {
        [JsonProperty("debounce", NullValueHandling = NullValueHandling.Ignore)]
        public double? Debounce { get; set; }

        [JsonProperty("element", NullValueHandling = NullValueHandling.Ignore)]
        public string Element { get; set; }

        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }

        [JsonProperty("input", NullValueHandling = NullValueHandling.Ignore)]
        public Input? Input { get; set; }

        [JsonProperty("options", NullValueHandling = NullValueHandling.Ignore)]
        public object[] Options { get; set; }

        [JsonProperty("max", NullValueHandling = NullValueHandling.Ignore)]
        public double? Max { get; set; }

        [JsonProperty("min", NullValueHandling = NullValueHandling.Ignore)]
        public double? Min { get; set; }

        [JsonProperty("step", NullValueHandling = NullValueHandling.Ignore)]
        public double? Step { get; set; }
    }

    public partial class VgMarkConfig
    {
        /// <summary>
        /// The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
        /// </summary>
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public Align? Align { get; set; }

        /// <summary>
        /// The rotation angle of the text, in degrees.
        /// </summary>
        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Angle { get; set; }

        /// <summary>
        /// The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
        ///
        /// __Default value:__ `"middle"`
        /// </summary>
        [JsonProperty("baseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? Baseline { get; set; }

        /// <summary>
        /// The radius in pixels of rounded rectangle corners.
        ///
        /// __Default value:__ `0`
        /// </summary>
        [JsonProperty("cornerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? CornerRadius { get; set; }

        /// <summary>
        /// The mouse cursor used over the mark. Any valid [CSS cursor
        /// type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
        /// </summary>
        [JsonProperty("cursor", NullValueHandling = NullValueHandling.Ignore)]
        public Cursor? Cursor { get; set; }

        /// <summary>
        /// The direction of the text. One of `"ltr"` (left-to-right) or `"rtl"` (right-to-left).
        /// This property determines on which side is truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"ltr"`
        /// </summary>
        [JsonProperty("dir", NullValueHandling = NullValueHandling.Ignore)]
        public Dir? Dir { get; set; }

        /// <summary>
        /// The horizontal offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dx", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dx { get; set; }

        /// <summary>
        /// The vertical offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dy", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dy { get; set; }

        /// <summary>
        /// The ellipsis string for text truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"…"`
        /// </summary>
        [JsonProperty("ellipsis", NullValueHandling = NullValueHandling.Ignore)]
        public string Ellipsis { get; set; }

        /// <summary>
        /// Default Fill Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public string Fill { get; set; }

        /// <summary>
        /// The fill opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? FillOpacity { get; set; }

        /// <summary>
        /// The typeface to set the text in (e.g., `"Helvetica Neue"`).
        /// </summary>
        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public string Font { get; set; }

        /// <summary>
        /// The font size, in pixels.
        /// </summary>
        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? FontSize { get; set; }

        /// <summary>
        /// The font style (e.g., `"italic"`).
        /// </summary>
        [JsonProperty("fontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public FontStyle? FontStyle { get; set; }

        /// <summary>
        /// The font weight.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? FontWeight { get; set; }

        /// <summary>
        /// A URL to load upon mouse click. If defined, the mark acts as a hyperlink.
        /// </summary>
        [JsonProperty("href", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Href { get; set; }

        /// <summary>
        /// The line interpolation method to use for line and area marks. One of the following:
        /// - `"linear"`: piecewise linear segments, as in a polyline.
        /// - `"linear-closed"`: close the linear segments to form a polygon.
        /// - `"step"`: alternate between horizontal and vertical segments, as in a step function.
        /// - `"step-before"`: alternate between vertical and horizontal segments, as in a step
        /// function.
        /// - `"step-after"`: alternate between horizontal and vertical segments, as in a step
        /// function.
        /// - `"basis"`: a B-spline, with control point duplication on the ends.
        /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
        /// - `"basis-closed"`: a closed B-spline, as in a loop.
        /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
        /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
        /// will intersect other control points.
        /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
        /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
        /// spline.
        /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
        /// </summary>
        [JsonProperty("interpolate", NullValueHandling = NullValueHandling.Ignore)]
        public Interpolate? Interpolate { get; set; }

        /// <summary>
        /// The maximum length of the text mark in pixels. The text value will be automatically
        /// truncated if the rendered size exceeds the limit.
        ///
        /// __Default value:__ `0`, indicating no limit
        /// </summary>
        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public double? Limit { get; set; }

        /// <summary>
        /// The overall opacity (value between [0,1]).
        ///
        /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
        /// `square` marks or layered `bar` charts and `1` otherwise.
        /// </summary>
        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? Opacity { get; set; }

        /// <summary>
        /// The orientation of a non-stacked bar, tick, area, and line charts.
        /// The value is either horizontal (default) or vertical.
        /// - For bar, rule and tick, this determines whether the size of the bar and tick
        /// should be applied to x or y dimension.
        /// - For area, this property determines the orient property of the Vega output.
        /// - For line and trail marks, this property determines the sort order of the points in the
        /// line
        /// if `config.sortLineBy` is not specified.
        /// For stacked charts, this is always determined by the orientation of the stack;
        /// therefore explicitly specified value will be ignored.
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public Orient? Orient { get; set; }

        /// <summary>
        /// Polar coordinate radial offset, in pixels, of the text label from the origin determined
        /// by the `x` and `y` properties.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        /// <summary>
        /// The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`,
        /// `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
        ///
        /// __Default value:__ `"circle"`
        /// </summary>
        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public string Shape { get; set; }

        /// <summary>
        /// The pixel area each the point/circle/square.
        /// For example: in the case of circles, the radius is determined in part by the square root
        /// of the size value.
        ///
        /// __Default value:__ `30`
        /// </summary>
        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public double? Size { get; set; }

        /// <summary>
        /// Default Stroke Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public string Stroke { get; set; }

        /// <summary>
        /// The stroke cap for line ending style. One of `"butt"`, `"round"`, or `"square"`.
        ///
        /// __Default value:__ `"square"`
        /// </summary>
        [JsonProperty("strokeCap", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeCap? StrokeCap { get; set; }

        /// <summary>
        /// An array of alternating stroke, space lengths for creating dashed or dotted lines.
        /// </summary>
        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] StrokeDash { get; set; }

        /// <summary>
        /// The offset (in pixels) into which to begin drawing with the stroke dash array.
        /// </summary>
        [JsonProperty("strokeDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeDashOffset { get; set; }

        /// <summary>
        /// The stroke line join method. One of `"miter"`, `"round"` or `"bevel"`.
        ///
        /// __Default value:__ `"miter"`
        /// </summary>
        [JsonProperty("strokeJoin", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeJoin? StrokeJoin { get; set; }

        /// <summary>
        /// The miter limit at which to bevel a line join.
        /// </summary>
        [JsonProperty("strokeMiterLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeMiterLimit { get; set; }

        /// <summary>
        /// The stroke opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeOpacity { get; set; }

        /// <summary>
        /// The stroke width, in pixels.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeWidth { get; set; }

        /// <summary>
        /// Depending on the interpolation type, sets the tension parameter (for line and area marks).
        /// </summary>
        [JsonProperty("tension", NullValueHandling = NullValueHandling.Ignore)]
        public double? Tension { get; set; }

        /// <summary>
        /// Placeholder text if the `text` channel is not specified
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        /// <summary>
        /// Polar coordinate angle, in radians, of the text label from the origin determined by the
        /// `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark
        /// `startAngle` and `endAngle` properties: angles are measured in radians, with `0`
        /// indicating "north".
        /// </summary>
        [JsonProperty("theta", NullValueHandling = NullValueHandling.Ignore)]
        public double? Theta { get; set; }

        /// <summary>
        /// The tooltip text to show upon mouse hover.
        /// </summary>
        [JsonProperty("tooltip")]
        public object Tooltip { get; set; }
    }

    /// <summary>
    /// Text-Specific Config
    /// </summary>
    public partial class TextConfig
    {
        /// <summary>
        /// The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
        /// </summary>
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public Align? Align { get; set; }

        /// <summary>
        /// The rotation angle of the text, in degrees.
        /// </summary>
        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Angle { get; set; }

        /// <summary>
        /// The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
        ///
        /// __Default value:__ `"middle"`
        /// </summary>
        [JsonProperty("baseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? Baseline { get; set; }

        /// <summary>
        /// Default color.  Note that `fill` and `stroke` have higher precedence than `color` and
        /// will override `color`.
        ///
        /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public string Color { get; set; }

        /// <summary>
        /// The radius in pixels of rounded rectangle corners.
        ///
        /// __Default value:__ `0`
        /// </summary>
        [JsonProperty("cornerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? CornerRadius { get; set; }

        /// <summary>
        /// The mouse cursor used over the mark. Any valid [CSS cursor
        /// type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
        /// </summary>
        [JsonProperty("cursor", NullValueHandling = NullValueHandling.Ignore)]
        public Cursor? Cursor { get; set; }

        /// <summary>
        /// The direction of the text. One of `"ltr"` (left-to-right) or `"rtl"` (right-to-left).
        /// This property determines on which side is truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"ltr"`
        /// </summary>
        [JsonProperty("dir", NullValueHandling = NullValueHandling.Ignore)]
        public Dir? Dir { get; set; }

        /// <summary>
        /// The horizontal offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dx", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dx { get; set; }

        /// <summary>
        /// The vertical offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dy", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dy { get; set; }

        /// <summary>
        /// The ellipsis string for text truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"…"`
        /// </summary>
        [JsonProperty("ellipsis", NullValueHandling = NullValueHandling.Ignore)]
        public string Ellipsis { get; set; }

        /// <summary>
        /// Default Fill Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public string Fill { get; set; }

        /// <summary>
        /// Whether the mark's color should be used as fill color instead of stroke color.
        ///
        /// __Default value:__ `false` for `point`, `line` and `rule`; otherwise, `true`.
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("filled", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Filled { get; set; }

        /// <summary>
        /// The fill opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? FillOpacity { get; set; }

        /// <summary>
        /// The typeface to set the text in (e.g., `"Helvetica Neue"`).
        /// </summary>
        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public string Font { get; set; }

        /// <summary>
        /// The font size, in pixels.
        /// </summary>
        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? FontSize { get; set; }

        /// <summary>
        /// The font style (e.g., `"italic"`).
        /// </summary>
        [JsonProperty("fontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public FontStyle? FontStyle { get; set; }

        /// <summary>
        /// The font weight.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? FontWeight { get; set; }

        /// <summary>
        /// A URL to load upon mouse click. If defined, the mark acts as a hyperlink.
        /// </summary>
        [JsonProperty("href", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Href { get; set; }

        /// <summary>
        /// The line interpolation method to use for line and area marks. One of the following:
        /// - `"linear"`: piecewise linear segments, as in a polyline.
        /// - `"linear-closed"`: close the linear segments to form a polygon.
        /// - `"step"`: alternate between horizontal and vertical segments, as in a step function.
        /// - `"step-before"`: alternate between vertical and horizontal segments, as in a step
        /// function.
        /// - `"step-after"`: alternate between horizontal and vertical segments, as in a step
        /// function.
        /// - `"basis"`: a B-spline, with control point duplication on the ends.
        /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
        /// - `"basis-closed"`: a closed B-spline, as in a loop.
        /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
        /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
        /// will intersect other control points.
        /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
        /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
        /// spline.
        /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
        /// </summary>
        [JsonProperty("interpolate", NullValueHandling = NullValueHandling.Ignore)]
        public Interpolate? Interpolate { get; set; }

        /// <summary>
        /// The maximum length of the text mark in pixels. The text value will be automatically
        /// truncated if the rendered size exceeds the limit.
        ///
        /// __Default value:__ `0`, indicating no limit
        /// </summary>
        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public double? Limit { get; set; }

        /// <summary>
        /// The overall opacity (value between [0,1]).
        ///
        /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
        /// `square` marks or layered `bar` charts and `1` otherwise.
        /// </summary>
        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? Opacity { get; set; }

        /// <summary>
        /// The orientation of a non-stacked bar, tick, area, and line charts.
        /// The value is either horizontal (default) or vertical.
        /// - For bar, rule and tick, this determines whether the size of the bar and tick
        /// should be applied to x or y dimension.
        /// - For area, this property determines the orient property of the Vega output.
        /// - For line and trail marks, this property determines the sort order of the points in the
        /// line
        /// if `config.sortLineBy` is not specified.
        /// For stacked charts, this is always determined by the orientation of the stack;
        /// therefore explicitly specified value will be ignored.
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public Orient? Orient { get; set; }

        /// <summary>
        /// Polar coordinate radial offset, in pixels, of the text label from the origin determined
        /// by the `x` and `y` properties.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        /// <summary>
        /// The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`,
        /// `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
        ///
        /// __Default value:__ `"circle"`
        /// </summary>
        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public string Shape { get; set; }

        /// <summary>
        /// Whether month names and weekday names should be abbreviated.
        /// </summary>
        [JsonProperty("shortTimeLabels", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShortTimeLabels { get; set; }

        /// <summary>
        /// Default size for marks.
        /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. For
        /// example: in the case of circles, the radius is determined in part by the square root of
        /// the size value.
        /// - For `bar`, this represents the band size of the bar, in pixels.
        /// - For `text`, this represents the font size, in pixels.
        ///
        /// __Default value:__ `30` for point, circle, square marks; `rangeStep` - 1 for bar marks
        /// with discrete dimensions; `5` for bar marks with continuous dimensions; `11` for text
        /// marks.
        /// </summary>
        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public double? Size { get; set; }

        /// <summary>
        /// Default Stroke Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public string Stroke { get; set; }

        /// <summary>
        /// The stroke cap for line ending style. One of `"butt"`, `"round"`, or `"square"`.
        ///
        /// __Default value:__ `"square"`
        /// </summary>
        [JsonProperty("strokeCap", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeCap? StrokeCap { get; set; }

        /// <summary>
        /// An array of alternating stroke, space lengths for creating dashed or dotted lines.
        /// </summary>
        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] StrokeDash { get; set; }

        /// <summary>
        /// The offset (in pixels) into which to begin drawing with the stroke dash array.
        /// </summary>
        [JsonProperty("strokeDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeDashOffset { get; set; }

        /// <summary>
        /// The stroke line join method. One of `"miter"`, `"round"` or `"bevel"`.
        ///
        /// __Default value:__ `"miter"`
        /// </summary>
        [JsonProperty("strokeJoin", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeJoin? StrokeJoin { get; set; }

        /// <summary>
        /// The miter limit at which to bevel a line join.
        /// </summary>
        [JsonProperty("strokeMiterLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeMiterLimit { get; set; }

        /// <summary>
        /// The stroke opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeOpacity { get; set; }

        /// <summary>
        /// The stroke width, in pixels.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeWidth { get; set; }

        /// <summary>
        /// Depending on the interpolation type, sets the tension parameter (for line and area marks).
        /// </summary>
        [JsonProperty("tension", NullValueHandling = NullValueHandling.Ignore)]
        public double? Tension { get; set; }

        /// <summary>
        /// Placeholder text if the `text` channel is not specified
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        /// <summary>
        /// Polar coordinate angle, in radians, of the text label from the origin determined by the
        /// `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark
        /// `startAngle` and `endAngle` properties: angles are measured in radians, with `0`
        /// indicating "north".
        /// </summary>
        [JsonProperty("theta", NullValueHandling = NullValueHandling.Ignore)]
        public double? Theta { get; set; }

        /// <summary>
        /// The tooltip text string to show upon mouse hover or an object defining which fields
        /// should the tooltip be derived from.
        ///
        /// - If `tooltip` is `{"content": "encoding"}`, then all fields from `encoding` will be
        /// used.
        /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
        /// data point will be used.
        /// </summary>
        [JsonProperty("tooltip", NullValueHandling = NullValueHandling.Ignore)]
        public Tooltip? Tooltip { get; set; }
    }

    /// <summary>
    /// Tick-Specific Config
    /// </summary>
    public partial class TickConfig
    {
        /// <summary>
        /// The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
        /// </summary>
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public Align? Align { get; set; }

        /// <summary>
        /// The rotation angle of the text, in degrees.
        /// </summary>
        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Angle { get; set; }

        /// <summary>
        /// The width of the ticks.
        ///
        /// __Default value:__  2/3 of rangeStep.
        /// </summary>
        [JsonProperty("bandSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? BandSize { get; set; }

        /// <summary>
        /// The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
        ///
        /// __Default value:__ `"middle"`
        /// </summary>
        [JsonProperty("baseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? Baseline { get; set; }

        /// <summary>
        /// Default color.  Note that `fill` and `stroke` have higher precedence than `color` and
        /// will override `color`.
        ///
        /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public string Color { get; set; }

        /// <summary>
        /// The radius in pixels of rounded rectangle corners.
        ///
        /// __Default value:__ `0`
        /// </summary>
        [JsonProperty("cornerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? CornerRadius { get; set; }

        /// <summary>
        /// The mouse cursor used over the mark. Any valid [CSS cursor
        /// type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
        /// </summary>
        [JsonProperty("cursor", NullValueHandling = NullValueHandling.Ignore)]
        public Cursor? Cursor { get; set; }

        /// <summary>
        /// The direction of the text. One of `"ltr"` (left-to-right) or `"rtl"` (right-to-left).
        /// This property determines on which side is truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"ltr"`
        /// </summary>
        [JsonProperty("dir", NullValueHandling = NullValueHandling.Ignore)]
        public Dir? Dir { get; set; }

        /// <summary>
        /// The horizontal offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dx", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dx { get; set; }

        /// <summary>
        /// The vertical offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dy", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dy { get; set; }

        /// <summary>
        /// The ellipsis string for text truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"…"`
        /// </summary>
        [JsonProperty("ellipsis", NullValueHandling = NullValueHandling.Ignore)]
        public string Ellipsis { get; set; }

        /// <summary>
        /// Default Fill Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public string Fill { get; set; }

        /// <summary>
        /// Whether the mark's color should be used as fill color instead of stroke color.
        ///
        /// __Default value:__ `false` for `point`, `line` and `rule`; otherwise, `true`.
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("filled", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Filled { get; set; }

        /// <summary>
        /// The fill opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? FillOpacity { get; set; }

        /// <summary>
        /// The typeface to set the text in (e.g., `"Helvetica Neue"`).
        /// </summary>
        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public string Font { get; set; }

        /// <summary>
        /// The font size, in pixels.
        /// </summary>
        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? FontSize { get; set; }

        /// <summary>
        /// The font style (e.g., `"italic"`).
        /// </summary>
        [JsonProperty("fontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public FontStyle? FontStyle { get; set; }

        /// <summary>
        /// The font weight.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? FontWeight { get; set; }

        /// <summary>
        /// A URL to load upon mouse click. If defined, the mark acts as a hyperlink.
        /// </summary>
        [JsonProperty("href", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Href { get; set; }

        /// <summary>
        /// The line interpolation method to use for line and area marks. One of the following:
        /// - `"linear"`: piecewise linear segments, as in a polyline.
        /// - `"linear-closed"`: close the linear segments to form a polygon.
        /// - `"step"`: alternate between horizontal and vertical segments, as in a step function.
        /// - `"step-before"`: alternate between vertical and horizontal segments, as in a step
        /// function.
        /// - `"step-after"`: alternate between horizontal and vertical segments, as in a step
        /// function.
        /// - `"basis"`: a B-spline, with control point duplication on the ends.
        /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
        /// - `"basis-closed"`: a closed B-spline, as in a loop.
        /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
        /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
        /// will intersect other control points.
        /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
        /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
        /// spline.
        /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
        /// </summary>
        [JsonProperty("interpolate", NullValueHandling = NullValueHandling.Ignore)]
        public Interpolate? Interpolate { get; set; }

        /// <summary>
        /// The maximum length of the text mark in pixels. The text value will be automatically
        /// truncated if the rendered size exceeds the limit.
        ///
        /// __Default value:__ `0`, indicating no limit
        /// </summary>
        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public double? Limit { get; set; }

        /// <summary>
        /// The overall opacity (value between [0,1]).
        ///
        /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
        /// `square` marks or layered `bar` charts and `1` otherwise.
        /// </summary>
        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? Opacity { get; set; }

        /// <summary>
        /// The orientation of a non-stacked bar, tick, area, and line charts.
        /// The value is either horizontal (default) or vertical.
        /// - For bar, rule and tick, this determines whether the size of the bar and tick
        /// should be applied to x or y dimension.
        /// - For area, this property determines the orient property of the Vega output.
        /// - For line and trail marks, this property determines the sort order of the points in the
        /// line
        /// if `config.sortLineBy` is not specified.
        /// For stacked charts, this is always determined by the orientation of the stack;
        /// therefore explicitly specified value will be ignored.
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public Orient? Orient { get; set; }

        /// <summary>
        /// Polar coordinate radial offset, in pixels, of the text label from the origin determined
        /// by the `x` and `y` properties.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        /// <summary>
        /// The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`,
        /// `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
        ///
        /// __Default value:__ `"circle"`
        /// </summary>
        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public string Shape { get; set; }

        /// <summary>
        /// Default size for marks.
        /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. For
        /// example: in the case of circles, the radius is determined in part by the square root of
        /// the size value.
        /// - For `bar`, this represents the band size of the bar, in pixels.
        /// - For `text`, this represents the font size, in pixels.
        ///
        /// __Default value:__ `30` for point, circle, square marks; `rangeStep` - 1 for bar marks
        /// with discrete dimensions; `5` for bar marks with continuous dimensions; `11` for text
        /// marks.
        /// </summary>
        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public double? Size { get; set; }

        /// <summary>
        /// Default Stroke Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public string Stroke { get; set; }

        /// <summary>
        /// The stroke cap for line ending style. One of `"butt"`, `"round"`, or `"square"`.
        ///
        /// __Default value:__ `"square"`
        /// </summary>
        [JsonProperty("strokeCap", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeCap? StrokeCap { get; set; }

        /// <summary>
        /// An array of alternating stroke, space lengths for creating dashed or dotted lines.
        /// </summary>
        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] StrokeDash { get; set; }

        /// <summary>
        /// The offset (in pixels) into which to begin drawing with the stroke dash array.
        /// </summary>
        [JsonProperty("strokeDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeDashOffset { get; set; }

        /// <summary>
        /// The stroke line join method. One of `"miter"`, `"round"` or `"bevel"`.
        ///
        /// __Default value:__ `"miter"`
        /// </summary>
        [JsonProperty("strokeJoin", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeJoin? StrokeJoin { get; set; }

        /// <summary>
        /// The miter limit at which to bevel a line join.
        /// </summary>
        [JsonProperty("strokeMiterLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeMiterLimit { get; set; }

        /// <summary>
        /// The stroke opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeOpacity { get; set; }

        /// <summary>
        /// The stroke width, in pixels.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeWidth { get; set; }

        /// <summary>
        /// Depending on the interpolation type, sets the tension parameter (for line and area marks).
        /// </summary>
        [JsonProperty("tension", NullValueHandling = NullValueHandling.Ignore)]
        public double? Tension { get; set; }

        /// <summary>
        /// Placeholder text if the `text` channel is not specified
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        /// <summary>
        /// Polar coordinate angle, in radians, of the text label from the origin determined by the
        /// `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark
        /// `startAngle` and `endAngle` properties: angles are measured in radians, with `0`
        /// indicating "north".
        /// </summary>
        [JsonProperty("theta", NullValueHandling = NullValueHandling.Ignore)]
        public double? Theta { get; set; }

        /// <summary>
        /// Thickness of the tick mark.
        ///
        /// __Default value:__  `1`
        /// </summary>
        [JsonProperty("thickness", NullValueHandling = NullValueHandling.Ignore)]
        public double? Thickness { get; set; }

        /// <summary>
        /// The tooltip text string to show upon mouse hover or an object defining which fields
        /// should the tooltip be derived from.
        ///
        /// - If `tooltip` is `{"content": "encoding"}`, then all fields from `encoding` will be
        /// used.
        /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
        /// data point will be used.
        /// </summary>
        [JsonProperty("tooltip", NullValueHandling = NullValueHandling.Ignore)]
        public Tooltip? Tooltip { get; set; }
    }

    /// <summary>
    /// Title configuration, which determines default properties for all
    /// [titles](https://vega.github.io/vega-lite/docs/title.html). For a full list of title
    /// configuration options, please see the [corresponding section of the title
    /// documentation](https://vega.github.io/vega-lite/docs/title.html#config).
    /// </summary>
    public partial class VgTitleConfig
    {
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public Align? Align { get; set; }

        /// <summary>
        /// The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For
        /// example, with an orientation of top these anchor positions map to a left-, center-, or
        /// right-aligned title.
        /// </summary>
        [JsonProperty("anchor", NullValueHandling = NullValueHandling.Ignore)]
        public TitleAnchor? Anchor { get; set; }

        /// <summary>
        /// Angle in degrees of title text.
        /// </summary>
        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Angle { get; set; }

        /// <summary>
        /// Vertical text baseline for title text. One of `"top"`, `"middle"`, `"bottom"`, or
        /// `"alphabetic"`.
        /// </summary>
        [JsonProperty("baseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? Baseline { get; set; }

        /// <summary>
        /// Text color for title text.
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public string Color { get; set; }

        /// <summary>
        /// Font name for title text.
        /// </summary>
        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public string Font { get; set; }

        /// <summary>
        /// Font size in pixels for title text.
        ///
        /// __Default value:__ `10`.
        /// </summary>
        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? FontSize { get; set; }

        /// <summary>
        /// Font weight for title text.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? FontWeight { get; set; }

        /// <summary>
        /// The reference frame for the anchor position, one of `"bounds"` (to anchor relative to the
        /// full bounding box) or `"group"` (to anchor relative to the group width or height).
        /// </summary>
        [JsonProperty("frame", NullValueHandling = NullValueHandling.Ignore)]
        public TitleFrame? Frame { get; set; }

        /// <summary>
        /// The maximum allowed length in pixels of legend labels.
        /// </summary>
        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public double? Limit { get; set; }

        /// <summary>
        /// The orthogonal offset in pixels by which to displace the title from its position along
        /// the edge of the chart.
        /// </summary>
        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? Offset { get; set; }

        /// <summary>
        /// Default title orientation (`"top"`, `"bottom"`, `"left"`, or `"right"`)
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public TitleOrient? Orient { get; set; }
    }

    /// <summary>
    /// Default properties for [single view
    /// plots](https://vega.github.io/vega-lite/docs/spec.html#single).
    /// </summary>
    public partial class ViewConfig
    {
        /// <summary>
        /// Whether the view should be clipped.
        /// </summary>
        [JsonProperty("clip", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Clip { get; set; }

        /// <summary>
        /// The fill color.
        ///
        /// __Default value:__ (none)
        /// </summary>
        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public string Fill { get; set; }

        /// <summary>
        /// The fill opacity (value between [0,1]).
        ///
        /// __Default value:__ (none)
        /// </summary>
        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? FillOpacity { get; set; }

        /// <summary>
        /// The default height of the single plot or each plot in a trellis plot when the
        /// visualization has a continuous (non-ordinal) y-scale with `rangeStep` = `null`.
        ///
        /// __Default value:__ `200`
        /// </summary>
        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public double? Height { get; set; }

        /// <summary>
        /// The stroke color.
        ///
        /// __Default value:__ (none)
        /// </summary>
        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public string Stroke { get; set; }

        /// <summary>
        /// An array of alternating stroke, space lengths for creating dashed or dotted lines.
        ///
        /// __Default value:__ (none)
        /// </summary>
        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] StrokeDash { get; set; }

        /// <summary>
        /// The offset (in pixels) into which to begin drawing with the stroke dash array.
        ///
        /// __Default value:__ (none)
        /// </summary>
        [JsonProperty("strokeDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeDashOffset { get; set; }

        /// <summary>
        /// The stroke line join method. One of miter (default), round or bevel.
        ///
        /// __Default value:__ 'miter'
        /// </summary>
        [JsonProperty("strokeJoin", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeJoin? StrokeJoin { get; set; }

        /// <summary>
        /// The stroke line join method. One of miter (default), round or bevel.
        ///
        /// __Default value:__ 'miter'
        /// </summary>
        [JsonProperty("strokeMiterLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeMiterLimit { get; set; }

        /// <summary>
        /// The stroke opacity (value between [0,1]).
        ///
        /// __Default value:__ (none)
        /// </summary>
        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeOpacity { get; set; }

        /// <summary>
        /// The stroke width, in pixels.
        ///
        /// __Default value:__ (none)
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeWidth { get; set; }

        /// <summary>
        /// The default width of the single plot or each plot in a trellis plot when the
        /// visualization has a continuous (non-ordinal) x-scale or ordinal x-scale with `rangeStep`
        /// = `null`.
        ///
        /// __Default value:__ `200`
        /// </summary>
        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public double? Width { get; set; }
    }

    /// <summary>
    /// An object describing the data source
    ///
    /// Secondary data source to lookup in.
    /// </summary>
    public partial class Data
    {
        /// <summary>
        /// An object that specifies the format for parsing the data.
        /// </summary>
        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        public DataFormat Format { get; set; }

        /// <summary>
        /// Provide a placeholder name and bind data at runtime.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// An URL from which to load the data set. Use the `format.type` property
        /// to ensure the loaded data is correctly parsed.
        /// </summary>
        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public string Url { get; set; }

        /// <summary>
        /// The full data set, included inline. This can be an array of objects or primitive values,
        /// an object, or a string.
        /// Arrays of primitive values are ingested as objects with a `data` property. Strings are
        /// parsed according to the specified format type.
        /// </summary>
        [JsonProperty("values", NullValueHandling = NullValueHandling.Ignore)]
        public InlineDataset? Values { get; set; }
    }

    /// <summary>
    /// An object that specifies the format for parsing the data.
    /// </summary>
    public partial class DataFormat
    {
        /// <summary>
        /// If set to `null`, disable type inference based on the spec and only use type inference
        /// based on the data.
        /// Alternatively, a parsing directive object can be provided for explicit data types. Each
        /// property of the object corresponds to a field name, and the value to the desired data
        /// type (one of `"number"`, `"boolean"`, `"date"`, or null (do not parse the field)).
        /// For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field in each
        /// input record a Date value.
        ///
        /// For `"date"`, we parse data based using Javascript's
        /// [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).
        /// For Specific date formats can be provided (e.g., `{foo: 'date:"%m%d%Y"'}`), using the
        /// [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date
        /// format parsing is supported similarly (e.g., `{foo: 'utc:"%m%d%Y"'}`). See more about
        /// [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)
        /// </summary>
        [JsonProperty("parse")]
        public Dictionary<string, string> Parse { get; set; }

        /// <summary>
        /// Type of input data: `"json"`, `"csv"`, `"tsv"`, `"dsv"`.
        /// The default format type is determined by the extension of the file URL.
        /// If no extension is detected, `"json"` will be used by default.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public DataFormatType? Type { get; set; }

        /// <summary>
        /// The delimiter between records. The delimiter must be a single character (i.e., a single
        /// 16-bit code unit); so, ASCII delimiters are fine, but emoji delimiters are not.
        /// </summary>
        [JsonProperty("delimiter", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxLengthCheckConverter))]
        public string Delimiter { get; set; }

        /// <summary>
        /// The JSON property containing the desired data.
        /// This parameter can be used when the loaded JSON file may have surrounding structure or
        /// meta-data.
        /// For example `"property": "values.features"` is equivalent to retrieving
        /// `json.values.features`
        /// from the loaded JSON object.
        /// </summary>
        [JsonProperty("property", NullValueHandling = NullValueHandling.Ignore)]
        public string Property { get; set; }

        /// <summary>
        /// The name of the TopoJSON object set to convert to a GeoJSON feature collection.
        /// For example, in a map of the world, there may be an object set named `"countries"`.
        /// Using the feature property, we can extract this set and generate a GeoJSON feature object
        /// for each country.
        /// </summary>
        [JsonProperty("feature", NullValueHandling = NullValueHandling.Ignore)]
        public string Feature { get; set; }

        /// <summary>
        /// The name of the TopoJSON object set to convert to mesh.
        /// Similar to the `feature` option, `mesh` extracts a named TopoJSON object set.
        /// Unlike the `feature` option, the corresponding geo data is returned as a single, unified
        /// mesh instance, not as individual GeoJSON features.
        /// Extracting a mesh is useful for more efficiently drawing borders or other geographic
        /// elements that you do not need to associate with specific regions such as individual
        /// countries, states or counties.
        /// </summary>
        [JsonProperty("mesh", NullValueHandling = NullValueHandling.Ignore)]
        public string Mesh { get; set; }
    }

    /// <summary>
    /// A key-value mapping between encoding channels and definition of fields.
    ///
    /// A shared key-value mapping between encoding channels and definition of fields in the
    /// underlying layers.
    /// </summary>
    public partial class Encoding
    {
        /// <summary>
        /// Color of the marks – either fill or stroke color based on  the `filled` property of mark
        /// definition.
        /// By default, `color` represents fill color for `"area"`, `"bar"`, `"tick"`,
        /// `"text"`, `"trail"`, `"circle"`, and `"square"` / stroke color for `"line"` and
        /// `"point"`.
        ///
        /// __Default value:__ If undefined, the default color depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.
        ///
        /// _Note:_
        /// 1) For fine-grained control over both fill and stroke colors of the marks, please use the
        /// `fill` and `stroke` channels.  If either `fill` or `stroke` channel is specified, `color`
        /// channel will be ignored.
        /// 2) See the scale documentation for more information about customizing [color
        /// scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition Color { get; set; }

        /// <summary>
        /// Horizontal facets for trellis plots.
        /// </summary>
        [JsonProperty("column", NullValueHandling = NullValueHandling.Ignore)]
        public FacetFieldDef Column { get; set; }

        /// <summary>
        /// Additional levels of detail for grouping data in aggregate views and
        /// in line, trail, and area marks without mapping data to a specific visual channel.
        /// </summary>
        [JsonProperty("detail", NullValueHandling = NullValueHandling.Ignore)]
        public Detail? Detail { get; set; }

        /// <summary>
        /// Fill color of the marks.
        /// __Default value:__ If undefined, the default color depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.
        ///
        /// _Note:_ When using `fill` channel, `color ` channel will be ignored. To customize both
        /// fill and stroke, please use `fill` and `stroke` channels (not `fill` and `color`).
        /// </summary>
        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition Fill { get; set; }

        /// <summary>
        /// Fill opacity of the marks.
        ///
        /// __Default value:__ If undefined, the default opacity depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `fillOpacity` property.
        /// </summary>
        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition FillOpacity { get; set; }

        /// <summary>
        /// A URL to load upon mouse click.
        /// </summary>
        [JsonProperty("href", NullValueHandling = NullValueHandling.Ignore)]
        public ValueDefWithCondition Href { get; set; }

        /// <summary>
        /// A data field to use as a unique key for data binding. When a visualization’s data is
        /// updated, the key value will be used to match data elements to existing mark instances.
        /// Use a key channel to enable object constancy for transitions over dynamic data.
        /// </summary>
        [JsonProperty("key", NullValueHandling = NullValueHandling.Ignore)]
        public FieldDef Key { get; set; }

        /// <summary>
        /// Latitude position of geographically projected marks.
        /// </summary>
        [JsonProperty("latitude", NullValueHandling = NullValueHandling.Ignore)]
        public FieldDef Latitude { get; set; }

        /// <summary>
        /// Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and
        /// `"rule"`.
        /// </summary>
        [JsonProperty("latitude2", NullValueHandling = NullValueHandling.Ignore)]
        public FieldDef Latitude2 { get; set; }

        /// <summary>
        /// Longitude position of geographically projected marks.
        /// </summary>
        [JsonProperty("longitude", NullValueHandling = NullValueHandling.Ignore)]
        public FieldDef Longitude { get; set; }

        /// <summary>
        /// Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`,
        /// and  `"rule"`.
        /// </summary>
        [JsonProperty("longitude2", NullValueHandling = NullValueHandling.Ignore)]
        public FieldDef Longitude2 { get; set; }

        /// <summary>
        /// Opacity of the marks.
        ///
        /// __Default value:__ If undefined, the default opacity depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `opacity` property.
        /// </summary>
        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition Opacity { get; set; }

        /// <summary>
        /// Order of the marks.
        /// - For stacked marks, this `order` channel encodes [stack
        /// order](https://vega.github.io/vega-lite/docs/stack.html#order).
        /// - For line and trail marks, this `order` channel encodes order of data points in the
        /// lines. This can be useful for creating [a connected
        /// scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html).
        /// Setting `order` to `{"value": null}` makes the line marks use the original order in the
        /// data sources.
        /// - Otherwise, this `order` channel encodes layer order of the marks.
        ///
        /// __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating
        /// additional aggregation grouping.
        /// </summary>
        [JsonProperty("order", NullValueHandling = NullValueHandling.Ignore)]
        public Order? Order { get; set; }

        /// <summary>
        /// Vertical facets for trellis plots.
        /// </summary>
        [JsonProperty("row", NullValueHandling = NullValueHandling.Ignore)]
        public FacetFieldDef Row { get; set; }

        /// <summary>
        /// For `point` marks the supported values are
        /// `"circle"` (default), `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`,
        /// or `"triangle-down"`, or else a custom SVG path string.
        /// For `geoshape` marks it should be a field definition of the geojson data
        ///
        /// __Default value:__ If undefined, the default shape depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape`
        /// property.
        /// </summary>
        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition Shape { get; set; }

        /// <summary>
        /// Size of the mark.
        /// - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
        /// - For `"bar"` and `"tick"` – the bar and tick's size.
        /// - For `"text"` – the text's font size.
        /// - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of
        /// line with varying size)
        /// </summary>
        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition Size { get; set; }

        /// <summary>
        /// Stroke color of the marks.
        /// __Default value:__ If undefined, the default color depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.
        ///
        /// _Note:_ When using `stroke` channel, `color ` channel will be ignored. To customize both
        /// stroke and fill, please use `stroke` and `fill` channels (not `stroke` and `color`).
        /// </summary>
        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition Stroke { get; set; }

        /// <summary>
        /// Stroke opacity of the marks.
        ///
        /// __Default value:__ If undefined, the default opacity depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `strokeOpacity`
        /// property.
        /// </summary>
        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition StrokeOpacity { get; set; }

        /// <summary>
        /// Stroke width of the marks.
        ///
        /// __Default value:__ If undefined, the default stroke width depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `strokeWidth` property.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition StrokeWidth { get; set; }

        /// <summary>
        /// Text of the `text` mark.
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public TextValueDefWithCondition Text { get; set; }

        /// <summary>
        /// The tooltip text to show upon mouse hover.
        /// </summary>
        [JsonProperty("tooltip", NullValueHandling = NullValueHandling.Ignore)]
        public TooltipUnion? Tooltip { get; set; }

        /// <summary>
        /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"`.
        /// </summary>
        [JsonProperty("x", NullValueHandling = NullValueHandling.Ignore)]
        public XClass X { get; set; }

        /// <summary>
        /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
        /// </summary>
        [JsonProperty("x2", NullValueHandling = NullValueHandling.Ignore)]
        public X2Class X2 { get; set; }

        /// <summary>
        /// Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
        /// </summary>
        [JsonProperty("xError", NullValueHandling = NullValueHandling.Ignore)]
        public X2Class XError { get; set; }

        /// <summary>
        /// Secondary error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
        /// </summary>
        [JsonProperty("xError2", NullValueHandling = NullValueHandling.Ignore)]
        public X2Class XError2 { get; set; }

        /// <summary>
        /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"`.
        /// </summary>
        [JsonProperty("y", NullValueHandling = NullValueHandling.Ignore)]
        public XClass Y { get; set; }

        /// <summary>
        /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
        /// </summary>
        [JsonProperty("y2", NullValueHandling = NullValueHandling.Ignore)]
        public X2Class Y2 { get; set; }

        /// <summary>
        /// Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
        /// </summary>
        [JsonProperty("yError", NullValueHandling = NullValueHandling.Ignore)]
        public X2Class YError { get; set; }

        /// <summary>
        /// Secondary error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
        /// </summary>
        [JsonProperty("yError2", NullValueHandling = NullValueHandling.Ignore)]
        public X2Class YError2 { get; set; }
    }

    /// <summary>
    /// Color of the marks – either fill or stroke color based on  the `filled` property of mark
    /// definition.
    /// By default, `color` represents fill color for `"area"`, `"bar"`, `"tick"`,
    /// `"text"`, `"trail"`, `"circle"`, and `"square"` / stroke color for `"line"` and
    /// `"point"`.
    ///
    /// __Default value:__ If undefined, the default color depends on [mark
    /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.
    ///
    /// _Note:_
    /// 1) For fine-grained control over both fill and stroke colors of the marks, please use the
    /// `fill` and `stroke` channels.  If either `fill` or `stroke` channel is specified, `color`
    /// channel will be ignored.
    /// 2) See the scale documentation for more information about customizing [color
    /// scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).
    ///
    /// Fill color of the marks.
    /// __Default value:__ If undefined, the default color depends on [mark
    /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.
    ///
    /// _Note:_ When using `fill` channel, `color ` channel will be ignored. To customize both
    /// fill and stroke, please use `fill` and `stroke` channels (not `fill` and `color`).
    ///
    /// Fill opacity of the marks.
    ///
    /// __Default value:__ If undefined, the default opacity depends on [mark
    /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `fillOpacity`
    /// property.
    ///
    /// Opacity of the marks.
    ///
    /// __Default value:__ If undefined, the default opacity depends on [mark
    /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `opacity` property.
    ///
    /// For `point` marks the supported values are
    /// `"circle"` (default), `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`,
    /// or `"triangle-down"`, or else a custom SVG path string.
    /// For `geoshape` marks it should be a field definition of the geojson data
    ///
    /// __Default value:__ If undefined, the default shape depends on [mark
    /// config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape`
    /// property.
    ///
    /// Size of the mark.
    /// - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
    /// - For `"bar"` and `"tick"` – the bar and tick's size.
    /// - For `"text"` – the text's font size.
    /// - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of
    /// line with varying size)
    ///
    /// Stroke color of the marks.
    /// __Default value:__ If undefined, the default color depends on [mark
    /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.
    ///
    /// _Note:_ When using `stroke` channel, `color ` channel will be ignored. To customize both
    /// stroke and fill, please use `stroke` and `fill` channels (not `stroke` and `color`).
    ///
    /// Stroke opacity of the marks.
    ///
    /// __Default value:__ If undefined, the default opacity depends on [mark
    /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `strokeOpacity`
    /// property.
    ///
    /// Stroke width of the marks.
    ///
    /// __Default value:__ If undefined, the default stroke width depends on [mark
    /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `strokeWidth`
    /// property.
    ///
    /// A FieldDef with Condition<ValueDef>
    /// {
    /// condition: {value: ...},
    /// field: ...,
    /// ...
    /// }
    ///
    /// A ValueDef with optional Condition<ValueDef | FieldDef>
    /// {
    /// condition: {field: ...} | {value: ...},
    /// value: ...,
    /// }
    ///
    /// A Condition<ValueDef | FieldDef> only definition.
    /// {
    /// condition: {field: ...} | {value: ...}
    /// }
    /// </summary>
    public partial class MarkPropValueDefWithCondition
    {
        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// One or more value definition(s) with a selection predicate.
        ///
        /// __Note:__ A field definition's `condition` property can only contain [value
        /// definitions](https://vega.github.io/vega-lite/docs/encoding.html#value-def)
        /// since Vega-Lite only allows at most one encoded field per encoding channel.
        ///
        /// A field definition or one or more value definition(s) with a selection predicate.
        /// </summary>
        [JsonProperty("condition", NullValueHandling = NullValueHandling.Ignore)]
        public ColorCondition? Condition { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// An object defining properties of the legend.
        /// If `null`, the legend for the encoding channel will be removed.
        ///
        /// __Default value:__ If undefined, default [legend
        /// properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// </summary>
        [JsonProperty("legend")]
        public Legend Legend { get; set; }

        /// <summary>
        /// An object defining properties of the channel's scale, which is the function that
        /// transforms values in the data domain (numbers, dates, strings, etc) to visual values
        /// (pixels, colors, sizes) of the encoding channels.
        ///
        /// If `null`, the scale will be [disabled and the data value will be directly
        /// encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        ///
        /// __Default value:__ If undefined, default [scale
        /// properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// </summary>
        [JsonProperty("scale")]
        public Scale Scale { get; set; }

        /// <summary>
        /// Sort order for the encoded field.
        ///
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
        /// `"descending"`.
        ///
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
        /// Javascript.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
        /// for sorting by another field.
        /// - [An array specifying the field values in preferred
        /// order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
        /// sort order will obey the values in the array, followed by any unspecified values in their
        /// original order.  For discrete time field, values in the sort array can be [date-time
        /// definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
        /// the values can be the month or day names (case insensitive) or their 3-letter initials
        /// (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        ///
        /// __Default value:__ `"ascending"`
        ///
        /// __Note:__ `null` is not supported for `row` and `column`.
        /// </summary>
        [JsonProperty("sort")]
        public Sort? Sort { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleType? Type { get; set; }

        /// <summary>
        /// A constant value in visual domain.
        /// </summary>
        [JsonProperty("value")]
        public Value? Value { get; set; }
    }

    /// <summary>
    /// Binning properties or boolean flag for determining whether to bin data or not.
    /// </summary>
    public partial class BinParams
    {
        /// <summary>
        /// A value in the binned domain at which to anchor the bins, shifting the bin boundaries if
        /// necessary to ensure that a boundary aligns with the anchor value.
        ///
        /// __Default Value:__ the minimum bin extent value
        /// </summary>
        [JsonProperty("anchor", NullValueHandling = NullValueHandling.Ignore)]
        public double? Anchor { get; set; }

        /// <summary>
        /// The number base to use for automatic bin determination (default is base 10).
        ///
        /// __Default value:__ `10`
        /// </summary>
        [JsonProperty("base", NullValueHandling = NullValueHandling.Ignore)]
        public double? Base { get; set; }

        /// <summary>
        /// Scale factors indicating allowable subdivisions. The default value is [5, 2], which
        /// indicates that for base 10 numbers (the default base), the method may consider dividing
        /// bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can
        /// check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the
        /// given constraints.
        ///
        /// __Default value:__ `[5, 2]`
        /// </summary>
        [JsonProperty("divide", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Divide { get; set; }

        /// <summary>
        /// A two-element (`[min, max]`) array indicating the range of desired bin values.
        /// </summary>
        [JsonProperty("extent", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Extent { get; set; }

        /// <summary>
        /// Maximum number of bins.
        ///
        /// __Default value:__ `6` for `row`, `column` and `shape` channels; `10` for other channels
        /// </summary>
        [JsonProperty("maxbins", NullValueHandling = NullValueHandling.Ignore)]
        public double? Maxbins { get; set; }

        /// <summary>
        /// A minimum allowable step size (particularly useful for integer values).
        /// </summary>
        [JsonProperty("minstep", NullValueHandling = NullValueHandling.Ignore)]
        public double? Minstep { get; set; }

        /// <summary>
        /// If true (the default), attempts to make the bin boundaries use human-friendly boundaries,
        /// such as multiples of ten.
        /// </summary>
        [JsonProperty("nice", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Nice { get; set; }

        /// <summary>
        /// An exact step size to use between bins.
        ///
        /// __Note:__ If provided, options such as maxbins will be ignored.
        /// </summary>
        [JsonProperty("step", NullValueHandling = NullValueHandling.Ignore)]
        public double? Step { get; set; }

        /// <summary>
        /// An array of allowable step sizes to choose from.
        /// </summary>
        [JsonProperty("steps", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Steps { get; set; }
    }

    public partial class ConditionalValueDef
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public LogicalOperandPredicate? Test { get; set; }

        /// <summary>
        /// A constant value in visual domain (e.g., `"red"` / "#0099ff" for color, values between
        /// `0` to `1` for opacity).
        /// </summary>
        [JsonProperty("value")]
        public Value Value { get; set; }

        /// <summary>
        /// A [selection name](https://vega.github.io/vega-lite/docs/selection.html), or a series of
        /// [composed selections](https://vega.github.io/vega-lite/docs/selection.html#compose).
        /// </summary>
        [JsonProperty("selection", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionOperand? Selection { get; set; }
    }

    public partial class Selection
    {
        [JsonProperty("not", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionOperand? Not { get; set; }

        [JsonProperty("and", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionOperand[] And { get; set; }

        [JsonProperty("or", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionOperand[] Or { get; set; }
    }

    public partial class Predicate
    {
        [JsonProperty("not", NullValueHandling = NullValueHandling.Ignore)]
        public LogicalOperandPredicate? Not { get; set; }

        [JsonProperty("and", NullValueHandling = NullValueHandling.Ignore)]
        public LogicalOperandPredicate[] And { get; set; }

        [JsonProperty("or", NullValueHandling = NullValueHandling.Ignore)]
        public LogicalOperandPredicate[] Or { get; set; }

        /// <summary>
        /// The value that the field should be equal to.
        /// </summary>
        [JsonProperty("equal", NullValueHandling = NullValueHandling.Ignore)]
        public Equal? Equal { get; set; }

        /// <summary>
        /// Field to be filtered.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }

        /// <summary>
        /// Time unit for the field to be filtered.
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// An array of inclusive minimum and maximum values
        /// for a field value of a data item to be included in the filtered data.
        /// </summary>
        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleRange[] Range { get; set; }

        /// <summary>
        /// A set of values that the `field`'s value should be a member of,
        /// for a data item included in the filtered data.
        /// </summary>
        [JsonProperty("oneOf", NullValueHandling = NullValueHandling.Ignore)]
        public Equal[] OneOf { get; set; }

        /// <summary>
        /// The value that the field should be less than.
        /// </summary>
        [JsonProperty("lt", NullValueHandling = NullValueHandling.Ignore)]
        public Lt? Lt { get; set; }

        /// <summary>
        /// The value that the field should be greater than.
        /// </summary>
        [JsonProperty("gt", NullValueHandling = NullValueHandling.Ignore)]
        public Lt? Gt { get; set; }

        /// <summary>
        /// The value that the field should be less than or equals to.
        /// </summary>
        [JsonProperty("lte", NullValueHandling = NullValueHandling.Ignore)]
        public Lt? Lte { get; set; }

        /// <summary>
        /// The value that the field should be greater than or equals to.
        /// </summary>
        [JsonProperty("gte", NullValueHandling = NullValueHandling.Ignore)]
        public Lt? Gte { get; set; }

        /// <summary>
        /// If set to true the field's value has to be valid, meaning both not `null` and not
        /// [`NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN).
        /// </summary>
        [JsonProperty("valid", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Valid { get; set; }

        /// <summary>
        /// Filter using a selection name.
        /// </summary>
        [JsonProperty("selection", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionOperand? Selection { get; set; }
    }

    /// <summary>
    /// Object for defining datetime in Vega-Lite Filter.
    /// If both month and quarter are provided, month has higher precedence.
    /// `day` cannot be combined with other date.
    /// We accept string for month and day names.
    /// </summary>
    public partial class DateTime
    {
        /// <summary>
        /// Integer value representing the date from 1-31.
        /// </summary>
        [JsonProperty("date", NullValueHandling = NullValueHandling.Ignore)]
        public double? Date { get; set; }

        /// <summary>
        /// Value representing the day of a week.  This can be one of: (1) integer value -- `1`
        /// represents Monday; (2) case-insensitive day name (e.g., `"Monday"`);  (3)
        /// case-insensitive, 3-character short day name (e.g., `"Mon"`).   <br/> **Warning:** A
        /// DateTime definition object with `day`** should not be combined with `year`, `quarter`,
        /// `month`, or `date`.
        /// </summary>
        [JsonProperty("day", NullValueHandling = NullValueHandling.Ignore)]
        public Day? Day { get; set; }

        /// <summary>
        /// Integer value representing the hour of a day from 0-23.
        /// </summary>
        [JsonProperty("hours", NullValueHandling = NullValueHandling.Ignore)]
        public double? Hours { get; set; }

        /// <summary>
        /// Integer value representing the millisecond segment of time.
        /// </summary>
        [JsonProperty("milliseconds", NullValueHandling = NullValueHandling.Ignore)]
        public double? Milliseconds { get; set; }

        /// <summary>
        /// Integer value representing the minute segment of time from 0-59.
        /// </summary>
        [JsonProperty("minutes", NullValueHandling = NullValueHandling.Ignore)]
        public double? Minutes { get; set; }

        /// <summary>
        /// One of: (1) integer value representing the month from `1`-`12`. `1` represents January;
        /// (2) case-insensitive month name (e.g., `"January"`);  (3) case-insensitive, 3-character
        /// short month name (e.g., `"Jan"`).
        /// </summary>
        [JsonProperty("month", NullValueHandling = NullValueHandling.Ignore)]
        public Month? Month { get; set; }

        /// <summary>
        /// Integer value representing the quarter of the year (from 1-4).
        /// </summary>
        [JsonProperty("quarter", NullValueHandling = NullValueHandling.Ignore)]
        public double? Quarter { get; set; }

        /// <summary>
        /// Integer value representing the second segment (0-59) of a time value
        /// </summary>
        [JsonProperty("seconds", NullValueHandling = NullValueHandling.Ignore)]
        public double? Seconds { get; set; }

        /// <summary>
        /// A boolean flag indicating if date time is in utc time. If false, the date time is in
        /// local time
        /// </summary>
        [JsonProperty("utc", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Utc { get; set; }

        /// <summary>
        /// Integer value representing the year.
        /// </summary>
        [JsonProperty("year", NullValueHandling = NullValueHandling.Ignore)]
        public double? Year { get; set; }
    }

    public partial class ConditionalPredicateMarkPropFieldDefClass
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public LogicalOperandPredicate? Test { get; set; }

        /// <summary>
        /// A constant value in visual domain (e.g., `"red"` / "#0099ff" for color, values between
        /// `0` to `1` for opacity).
        /// </summary>
        [JsonProperty("value")]
        public Value? Value { get; set; }

        /// <summary>
        /// A [selection name](https://vega.github.io/vega-lite/docs/selection.html), or a series of
        /// [composed selections](https://vega.github.io/vega-lite/docs/selection.html#compose).
        /// </summary>
        [JsonProperty("selection", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionOperand? Selection { get; set; }

        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// An object defining properties of the legend.
        /// If `null`, the legend for the encoding channel will be removed.
        ///
        /// __Default value:__ If undefined, default [legend
        /// properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
        /// </summary>
        [JsonProperty("legend")]
        public Legend Legend { get; set; }

        /// <summary>
        /// An object defining properties of the channel's scale, which is the function that
        /// transforms values in the data domain (numbers, dates, strings, etc) to visual values
        /// (pixels, colors, sizes) of the encoding channels.
        ///
        /// If `null`, the scale will be [disabled and the data value will be directly
        /// encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        ///
        /// __Default value:__ If undefined, default [scale
        /// properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// </summary>
        [JsonProperty("scale")]
        public Scale Scale { get; set; }

        /// <summary>
        /// Sort order for the encoded field.
        ///
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
        /// `"descending"`.
        ///
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
        /// Javascript.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
        /// for sorting by another field.
        /// - [An array specifying the field values in preferred
        /// order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
        /// sort order will obey the values in the array, followed by any unspecified values in their
        /// original order.  For discrete time field, values in the sort array can be [date-time
        /// definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
        /// the values can be the month or day names (case insensitive) or their 3-letter initials
        /// (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        ///
        /// __Default value:__ `"ascending"`
        ///
        /// __Note:__ `null` is not supported for `row` and `column`.
        /// </summary>
        [JsonProperty("sort")]
        public Sort? Sort { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleType? Type { get; set; }
    }

    /// <summary>
    /// Reference to a repeated value.
    /// </summary>
    public partial class RepeatRef
    {
        [JsonProperty("repeat")]
        public RepeatEnum Repeat { get; set; }
    }

    /// <summary>
    /// Properties of a legend or boolean flag for determining whether to show it.
    /// </summary>
    public partial class Legend
    {
        /// <summary>
        /// The height in pixels to clip symbol legend entries and limit their size.
        /// </summary>
        [JsonProperty("clipHeight", NullValueHandling = NullValueHandling.Ignore)]
        public double? ClipHeight { get; set; }

        /// <summary>
        /// The horizontal padding in pixels between symbol legend entries.
        ///
        /// __Default value:__ `10`.
        /// </summary>
        [JsonProperty("columnPadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? ColumnPadding { get; set; }

        /// <summary>
        /// The number of columns in which to arrange symbol legend entries. A value of `0` or lower
        /// indicates a single row with one column per entry.
        /// </summary>
        [JsonProperty("columns", NullValueHandling = NullValueHandling.Ignore)]
        public double? Columns { get; set; }

        /// <summary>
        /// Corner radius for the full legend.
        /// </summary>
        [JsonProperty("cornerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? CornerRadius { get; set; }

        /// <summary>
        /// The direction of the legend, one of `"vertical"` or `"horizontal"`.
        ///
        /// __Default value:__ "vertical"`
        /// *
        /// </summary>
        [JsonProperty("direction", NullValueHandling = NullValueHandling.Ignore)]
        public Orient? Direction { get; set; }

        /// <summary>
        /// Background fill color for the full legend.
        /// </summary>
        [JsonProperty("fillColor", NullValueHandling = NullValueHandling.Ignore)]
        public string FillColor { get; set; }

        /// <summary>
        /// The formatting pattern for labels. This is D3's [number format
        /// pattern](https://github.com/d3/d3-format#locale_format) for quantitative fields and D3's
        /// [time format pattern](https://github.com/d3/d3-time-format#locale_format) for time
        /// field.
        ///
        /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
        /// more information.
        ///
        /// __Default value:__  derived from
        /// [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
        /// quantitative fields and from
        /// [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
        /// temporal fields.
        /// </summary>
        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        public string Format { get; set; }

        /// <summary>
        /// The length in pixels of the primary axis of a color gradient. This value corresponds to
        /// the height of a vertical gradient or the width of a horizontal gradient.
        ///
        /// __Default value:__ `200`.
        /// </summary>
        [JsonProperty("gradientLength", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientLength { get; set; }

        /// <summary>
        /// Opacity of the color gradient.
        /// </summary>
        [JsonProperty("gradientOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientOpacity { get; set; }

        /// <summary>
        /// The color of the gradient stroke, can be in hex color code or regular color name.
        ///
        /// __Default value:__ `"lightGray"`.
        /// </summary>
        [JsonProperty("gradientStrokeColor", NullValueHandling = NullValueHandling.Ignore)]
        public string GradientStrokeColor { get; set; }

        /// <summary>
        /// The width of the gradient stroke, in pixels.
        ///
        /// __Default value:__ `0`.
        /// </summary>
        [JsonProperty("gradientStrokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientStrokeWidth { get; set; }

        /// <summary>
        /// The thickness in pixels of the color gradient. This value corresponds to the width of a
        /// vertical gradient or the height of a horizontal gradient.
        ///
        /// __Default value:__ `16`.
        /// </summary>
        [JsonProperty("gradientThickness", NullValueHandling = NullValueHandling.Ignore)]
        public double? GradientThickness { get; set; }

        /// <summary>
        /// The alignment to apply to symbol legends rows and columns. The supported string values
        /// are `"all"`, `"each"` (the default), and `none`. For more information, see the [grid
        /// layout documentation](https://vega.github.io/vega/docs/layout).
        ///
        /// __Default value:__ `"each"`.
        /// </summary>
        [JsonProperty("gridAlign", NullValueHandling = NullValueHandling.Ignore)]
        public VgLayoutAlign? GridAlign { get; set; }

        /// <summary>
        /// The alignment of the legend label, can be left, center, or right.
        /// </summary>
        [JsonProperty("labelAlign", NullValueHandling = NullValueHandling.Ignore)]
        public Align? LabelAlign { get; set; }

        /// <summary>
        /// The position of the baseline of legend label, can be `"top"`, `"middle"`, `"bottom"`, or
        /// `"alphabetic"`.
        ///
        /// __Default value:__ `"middle"`.
        /// </summary>
        [JsonProperty("labelBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? LabelBaseline { get; set; }

        /// <summary>
        /// The color of the legend label, can be in hex color code or regular color name.
        /// </summary>
        [JsonProperty("labelColor", NullValueHandling = NullValueHandling.Ignore)]
        public string LabelColor { get; set; }

        /// <summary>
        /// The font of the legend label.
        /// </summary>
        [JsonProperty("labelFont", NullValueHandling = NullValueHandling.Ignore)]
        public string LabelFont { get; set; }

        /// <summary>
        /// The font size of legend label.
        ///
        /// __Default value:__ `10`.
        /// </summary>
        [JsonProperty("labelFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelFontSize { get; set; }

        /// <summary>
        /// The font weight of legend label.
        /// </summary>
        [JsonProperty("labelFontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? LabelFontWeight { get; set; }

        /// <summary>
        /// Maximum allowed pixel width of axis tick labels.
        ///
        /// __Default value:__ `160`.
        /// </summary>
        [JsonProperty("labelLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelLimit { get; set; }

        /// <summary>
        /// The offset of the legend label.
        /// </summary>
        [JsonProperty("labelOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelOffset { get; set; }

        /// <summary>
        /// Opacity of labels.
        /// </summary>
        [JsonProperty("labelOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelOpacity { get; set; }

        /// <summary>
        /// The strategy to use for resolving overlap of labels in gradient legends. If `false`, no
        /// overlap reduction is attempted. If set to `true` (default) or `"parity"`, a strategy of
        /// removing every other label is used. If set to `"greedy"`, a linear scan of the labels is
        /// performed, removing any label that overlaps with the last visible label (this often works
        /// better for log-scaled axes).
        ///
        /// __Default value:__ `true`.
        /// </summary>
        [JsonProperty("labelOverlap", NullValueHandling = NullValueHandling.Ignore)]
        public LabelOverlap? LabelOverlap { get; set; }

        /// <summary>
        /// Padding in pixels between the legend and legend labels.
        /// </summary>
        [JsonProperty("labelPadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelPadding { get; set; }

        /// <summary>
        /// The offset in pixels by which to displace the legend from the data rectangle and axes.
        ///
        /// __Default value:__ `18`.
        /// </summary>
        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? Offset { get; set; }

        /// <summary>
        /// The orientation of the legend, which determines how the legend is positioned within the
        /// scene. One of "left", "right", "top-left", "top-right", "bottom-left", "bottom-right",
        /// "none".
        ///
        /// __Default value:__ `"right"`
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public LegendOrient? Orient { get; set; }

        /// <summary>
        /// The padding between the border and content of the legend group.
        ///
        /// __Default value:__ `0`.
        /// </summary>
        [JsonProperty("padding", NullValueHandling = NullValueHandling.Ignore)]
        public double? Padding { get; set; }

        /// <summary>
        /// The vertical padding in pixels between symbol legend entries.
        ///
        /// __Default value:__ `2`.
        /// </summary>
        [JsonProperty("rowPadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? RowPadding { get; set; }

        /// <summary>
        /// Border stroke color for the full legend.
        /// </summary>
        [JsonProperty("strokeColor", NullValueHandling = NullValueHandling.Ignore)]
        public string StrokeColor { get; set; }

        /// <summary>
        /// Border stroke width for the full legend.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeWidth { get; set; }

        /// <summary>
        /// The color of the legend symbol,
        /// </summary>
        [JsonProperty("symbolFillColor", NullValueHandling = NullValueHandling.Ignore)]
        public string SymbolFillColor { get; set; }

        /// <summary>
        /// Horizontal pixel offset for legend symbols.
        ///
        /// __Default value:__ `0`.
        /// </summary>
        [JsonProperty("symbolOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? SymbolOffset { get; set; }

        /// <summary>
        /// Opacity of the legend symbols.
        /// </summary>
        [JsonProperty("symbolOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? SymbolOpacity { get; set; }

        /// <summary>
        /// The size of the legend symbol, in pixels.
        ///
        /// __Default value:__ `100`.
        /// </summary>
        [JsonProperty("symbolSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? SymbolSize { get; set; }

        /// <summary>
        /// Stroke color for legend symbols.
        /// </summary>
        [JsonProperty("symbolStrokeColor", NullValueHandling = NullValueHandling.Ignore)]
        public string SymbolStrokeColor { get; set; }

        /// <summary>
        /// The width of the symbol's stroke.
        ///
        /// __Default value:__ `1.5`.
        /// </summary>
        [JsonProperty("symbolStrokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? SymbolStrokeWidth { get; set; }

        /// <summary>
        /// Default shape type (such as "circle") for legend symbols.
        /// Can be one of ``"circle"`, `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`,
        /// `"triangle-down"`, `"triangle-right"`, or `"triangle-left"`.
        /// * In addition to a set of built-in shapes, custom shapes can be defined using [SVG path
        /// strings](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).
        /// *
        /// * __Default value:__ `"circle"`.
        /// *
        /// </summary>
        [JsonProperty("symbolType", NullValueHandling = NullValueHandling.Ignore)]
        public string SymbolType { get; set; }

        /// <summary>
        /// The desired number of tick values for quantitative legends.
        /// </summary>
        [JsonProperty("tickCount", NullValueHandling = NullValueHandling.Ignore)]
        public double? TickCount { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// Horizontal text alignment for legend titles.
        ///
        /// __Default value:__ `"left"`.
        /// </summary>
        [JsonProperty("titleAlign", NullValueHandling = NullValueHandling.Ignore)]
        public Align? TitleAlign { get; set; }

        /// <summary>
        /// Vertical text baseline for legend titles.
        ///
        /// __Default value:__ `"top"`.
        /// </summary>
        [JsonProperty("titleBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? TitleBaseline { get; set; }

        /// <summary>
        /// The color of the legend title, can be in hex color code or regular color name.
        /// </summary>
        [JsonProperty("titleColor", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleColor { get; set; }

        /// <summary>
        /// The font of the legend title.
        /// </summary>
        [JsonProperty("titleFont", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleFont { get; set; }

        /// <summary>
        /// The font size of the legend title.
        /// </summary>
        [JsonProperty("titleFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleFontSize { get; set; }

        /// <summary>
        /// The font weight of the legend title.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("titleFontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? TitleFontWeight { get; set; }

        /// <summary>
        /// Maximum allowed pixel width of axis titles.
        ///
        /// __Default value:__ `180`.
        /// </summary>
        [JsonProperty("titleLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleLimit { get; set; }

        /// <summary>
        /// Opacity of the legend title.
        /// </summary>
        [JsonProperty("titleOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleOpacity { get; set; }

        /// <summary>
        /// The padding, in pixels, between title and legend.
        ///
        /// __Default value:__ `5`.
        /// </summary>
        [JsonProperty("titlePadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitlePadding { get; set; }

        /// <summary>
        /// The type of the legend. Use `"symbol"` to create a discrete legend and `"gradient"` for a
        /// continuous color gradient.
        ///
        /// __Default value:__ `"gradient"` for non-binned quantitative fields and temporal fields;
        /// `"symbol"` otherwise.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public LegendType? Type { get; set; }

        /// <summary>
        /// Explicitly set the visible legend values.
        /// </summary>
        [JsonProperty("values", NullValueHandling = NullValueHandling.Ignore)]
        public Equal[] Values { get; set; }

        /// <summary>
        /// A non-positive integer indicating z-index of the legend.
        /// If zindex is 0, legend should be drawn behind all chart elements.
        /// To put them in front, use zindex = 1.
        /// </summary>
        [JsonProperty("zindex", NullValueHandling = NullValueHandling.Ignore)]
        public double? Zindex { get; set; }
    }

    public partial class Scale
    {
        /// <summary>
        /// The logarithm base of the `log` scale (default `10`).
        /// </summary>
        [JsonProperty("base", NullValueHandling = NullValueHandling.Ignore)]
        public double? Base { get; set; }

        /// <summary>
        /// If `true`, values that exceed the data domain are clamped to either the minimum or
        /// maximum range value
        ///
        /// __Default value:__ derived from the [scale
        /// config](https://vega.github.io/vega-lite/docs/config.html#scale-config)'s `clamp` (`true`
        /// by default).
        /// </summary>
        [JsonProperty("clamp", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Clamp { get; set; }

        /// <summary>
        /// Customized domain values.
        ///
        /// For _quantitative_ fields, `domain` can take the form of a two-element array with minimum
        /// and maximum values.  [Piecewise
        /// scales](https://vega.github.io/vega-lite/docs/scale.html#piecewise) can be created by
        /// providing a `domain` with more than two entries.
        /// If the input field is aggregated, `domain` can also be a string value `"unaggregated"`,
        /// indicating that the domain should include the raw data values prior to the aggregation.
        ///
        /// For _temporal_ fields, `domain` can be a two-element array minimum and maximum values, in
        /// the form of either timestamps or the [DateTime definition
        /// objects](https://vega.github.io/vega-lite/docs/types.html#datetime).
        ///
        /// For _ordinal_ and _nominal_ fields, `domain` can be an array that lists valid input
        /// values.
        ///
        /// The `selection` property can be used to [interactively
        /// determine](https://vega.github.io/vega-lite/docs/selection.html#scale-domains) the scale
        /// domain.
        /// </summary>
        [JsonProperty("domain", NullValueHandling = NullValueHandling.Ignore)]
        public DomainUnion? Domain { get; set; }

        /// <summary>
        /// The exponent of the `pow` scale.
        /// </summary>
        [JsonProperty("exponent", NullValueHandling = NullValueHandling.Ignore)]
        public double? Exponent { get; set; }

        /// <summary>
        /// The interpolation method for range values. By default, a general interpolator for
        /// numbers, dates, strings and colors (in HCL space) is used. For color ranges, this
        /// property allows interpolation in alternative color spaces. Legal values include `rgb`,
        /// `hsl`, `hsl-long`, `lab`, `hcl`, `hcl-long`, `cubehelix` and `cubehelix-long` ('-long'
        /// variants use longer paths in polar coordinate spaces). If object-valued, this property
        /// accepts an object with a string-valued _type_ property and an optional numeric _gamma_
        /// property applicable to rgb and cubehelix interpolators. For more, see the [d3-interpolate
        /// documentation](https://github.com/d3/d3-interpolate).
        ///
        /// * __Default value:__ `hcl`
        ///
        /// __Note:__ Sequential scales do not support `interpolate` as they have a fixed
        /// interpolator.  Since Vega-Lite uses sequential scales for quantitative fields by default,
        /// you have to set the scale `type` to other quantitative scale type such as `"linear"` to
        /// customize `interpolate`.
        /// </summary>
        [JsonProperty("interpolate", NullValueHandling = NullValueHandling.Ignore)]
        public InterpolateUnion? Interpolate { get; set; }

        /// <summary>
        /// Extending the domain so that it starts and ends on nice round values. This method
        /// typically modifies the scale’s domain, and may only extend the bounds to the nearest
        /// round value. Nicing is useful if the domain is computed from data and may be irregular.
        /// For example, for a domain of _[0.201479…, 0.996679…]_, a nice domain might be _[0.2,
        /// 1.0]_.
        ///
        /// For quantitative scales such as linear, `nice` can be either a boolean flag or a number.
        /// If `nice` is a number, it will represent a desired tick count. This allows greater
        /// control over the step size used to extend the bounds, guaranteeing that the returned
        /// ticks will exactly cover the domain.
        ///
        /// For temporal fields with time and utc scales, the `nice` value can be a string indicating
        /// the desired time interval. Legal values are `"millisecond"`, `"second"`, `"minute"`,
        /// `"hour"`, `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, `time` and `utc`
        /// scales can accept an object-valued interval specifier of the form `{"interval": "month",
        /// "step": 3}`, which includes a desired number of interval steps. Here, the domain would
        /// snap to quarter (Jan, Apr, Jul, Oct) boundaries.
        ///
        /// __Default value:__ `true` for unbinned _quantitative_ fields; `false` otherwise.
        /// </summary>
        [JsonProperty("nice", NullValueHandling = NullValueHandling.Ignore)]
        public NiceUnion? Nice { get; set; }

        /// <summary>
        /// For _[continuous](https://vega.github.io/vega-lite/docs/scale.html#continuous)_ scales,
        /// expands the scale domain to accommodate the specified number of pixels on each of the
        /// scale range. The scale range must represent pixels for this parameter to function as
        /// intended. Padding adjustment is performed prior to all other adjustments, including the
        /// effects of the zero, nice, domainMin, and domainMax properties.
        ///
        /// For _[band](https://vega.github.io/vega-lite/docs/scale.html#band)_ scales, shortcut for
        /// setting `paddingInner` and `paddingOuter` to the same value.
        ///
        /// For _[point](https://vega.github.io/vega-lite/docs/scale.html#point)_ scales, alias for
        /// `paddingOuter`.
        ///
        /// __Default value:__ For _continuous_ scales, derived from the [scale
        /// config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `continuousPadding`.
        /// For _band and point_ scales, see `paddingInner` and `paddingOuter`.
        /// </summary>
        [JsonProperty("padding", NullValueHandling = NullValueHandling.Ignore)]
        public double? Padding { get; set; }

        /// <summary>
        /// The inner padding (spacing) within each band step of band scales, as a fraction of the
        /// step size. This value must lie in the range [0,1].
        ///
        /// For point scale, this property is invalid as point scales do not have internal band
        /// widths (only step sizes between bands).
        ///
        /// __Default value:__ derived from the [scale
        /// config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `bandPaddingInner`.
        /// </summary>
        [JsonProperty("paddingInner", NullValueHandling = NullValueHandling.Ignore)]
        public double? PaddingInner { get; set; }

        /// <summary>
        /// The outer padding (spacing) at the ends of the range of band and point scales,
        /// as a fraction of the step size. This value must lie in the range [0,1].
        ///
        /// __Default value:__ derived from the [scale
        /// config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `bandPaddingOuter` for
        /// band scales and `pointPadding` for point scales.
        /// </summary>
        [JsonProperty("paddingOuter", NullValueHandling = NullValueHandling.Ignore)]
        public double? PaddingOuter { get; set; }

        /// <summary>
        /// The range of the scale. One of:
        ///
        /// - A string indicating a [pre-defined named scale
        /// range](https://vega.github.io/vega-lite/docs/scale.html#range-config) (e.g., example,
        /// `"symbol"`, or `"diverging"`).
        ///
        /// - For [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous),
        /// two-element array indicating  minimum and maximum values, or an array with more than two
        /// entries for specifying a [piecewise
        /// scale](https://vega.github.io/vega-lite/docs/scale.html#piecewise).
        ///
        /// - For [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) and
        /// [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales, an
        /// array of desired output values.
        ///
        /// __Notes:__
        ///
        /// 1) For [sequential](https://vega.github.io/vega-lite/docs/scale.html#sequential),
        /// [ordinal](https://vega.github.io/vega-lite/docs/scale.html#ordinal), and discretizing
        /// color scales, you can also specify a color
        /// [`scheme`](https://vega.github.io/vega-lite/docs/scale.html#scheme) instead of `range`.
        ///
        /// 2) Any directly specified `range` for `x` and `y` channels will be ignored. Range can be
        /// customized via the view's corresponding
        /// [size](https://vega.github.io/vega-lite/docs/size.html) (`width` and `height`) or via
        /// [range steps and paddings properties](#range-step) for [band](#band) and [point](#point)
        /// scales.
        /// </summary>
        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public ScaleRange? Range { get; set; }

        /// <summary>
        /// The distance between the starts of adjacent bands or points in
        /// [band](https://vega.github.io/vega-lite/docs/scale.html#band) and
        /// [point](https://vega.github.io/vega-lite/docs/scale.html#point) scales.
        ///
        /// If `rangeStep` is `null` or if the view contains the scale's corresponding
        /// [size](https://vega.github.io/vega-lite/docs/size.html) (`width` for `x` scales and
        /// `height` for `y` scales), `rangeStep` will be automatically determined to fit the size of
        /// the view.
        ///
        /// __Default value:__  derived the [scale
        /// config](https://vega.github.io/vega-lite/docs/config.html#scale-config)'s
        /// `textXRangeStep` (`90` by default) for x-scales of `text` marks and `rangeStep` (`21` by
        /// default) for x-scales of other marks and y-scales.
        ///
        /// __Warning__: If `rangeStep` is `null` and the cardinality of the scale's domain is higher
        /// than `width` or `height`, the rangeStep might become less than one pixel and the mark
        /// might not appear correctly.
        /// </summary>
        [JsonProperty("rangeStep")]
        public double? RangeStep { get; set; }

        /// <summary>
        /// If `true`, rounds numeric output values to integers. This can be helpful for snapping to
        /// the pixel grid.
        ///
        /// __Default value:__ `false`.
        /// </summary>
        [JsonProperty("round", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Round { get; set; }

        /// <summary>
        /// A string indicating a color
        /// [scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme) name (e.g.,
        /// `"category10"` or `"viridis"`) or a [scheme parameter
        /// object](https://vega.github.io/vega-lite/docs/scale.html#scheme-params).
        ///
        /// Discrete color schemes may be used with
        /// [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) or
        /// [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales.
        /// Continuous color schemes are intended for use with
        /// [sequential](https://vega.github.io/vega-lite/docs/scales.html#sequential) scales.
        ///
        /// For the full list of supported schemes, please refer to the [Vega
        /// Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.
        /// </summary>
        [JsonProperty("scheme", NullValueHandling = NullValueHandling.Ignore)]
        public Scheme? Scheme { get; set; }

        /// <summary>
        /// The type of scale.  Vega-Lite supports the following categories of scale types:
        ///
        /// 1) [**Continuous Scales**](https://vega.github.io/vega-lite/docs/scale.html#continuous)
        /// -- mapping continuous domains to continuous output ranges
        /// ([`"linear"`](https://vega.github.io/vega-lite/docs/scale.html#linear),
        /// [`"pow"`](https://vega.github.io/vega-lite/docs/scale.html#pow),
        /// [`"sqrt"`](https://vega.github.io/vega-lite/docs/scale.html#sqrt),
        /// [`"log"`](https://vega.github.io/vega-lite/docs/scale.html#log),
        /// [`"time"`](https://vega.github.io/vega-lite/docs/scale.html#time),
        /// [`"utc"`](https://vega.github.io/vega-lite/docs/scale.html#utc),
        /// [`"sequential"`](https://vega.github.io/vega-lite/docs/scale.html#sequential)).
        ///
        /// 2) [**Discrete Scales**](https://vega.github.io/vega-lite/docs/scale.html#discrete) --
        /// mapping discrete domains to discrete
        /// ([`"ordinal"`](https://vega.github.io/vega-lite/docs/scale.html#ordinal)) or continuous
        /// ([`"band"`](https://vega.github.io/vega-lite/docs/scale.html#band) and
        /// [`"point"`](https://vega.github.io/vega-lite/docs/scale.html#point)) output ranges.
        ///
        /// 3) [**Discretizing
        /// Scales**](https://vega.github.io/vega-lite/docs/scale.html#discretizing) -- mapping
        /// continuous domains to discrete output ranges
        /// ([`"bin-linear"`](https://vega.github.io/vega-lite/docs/scale.html#bin-linear),
        /// [`"bin-ordinal"`](https://vega.github.io/vega-lite/docs/scale.html#bin-ordinal),
        /// [`"quantile"`](https://vega.github.io/vega-lite/docs/scale.html#quantile),
        /// [`"quantize"`](https://vega.github.io/vega-lite/docs/scale.html#quantize) and
        /// [`"threshold"`](https://vega.github.io/vega-lite/docs/scale.html#threshold).
        ///
        /// __Default value:__ please see the [scale type
        /// table](https://vega.github.io/vega-lite/docs/scale.html#type).
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public ScaleType? Type { get; set; }

        /// <summary>
        /// If `true`, ensures that a zero baseline value is included in the scale domain.
        ///
        /// __Default value:__ `true` for x and y channels if the quantitative field is not binned
        /// and no custom `domain` is provided; `false` otherwise.
        ///
        /// __Note:__ Log, time, and utc scales do not support `zero`.
        /// </summary>
        [JsonProperty("zero", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Zero { get; set; }
    }

    public partial class DomainClass
    {
        /// <summary>
        /// The field name to extract selected values for, when a selection is
        /// [projected](https://vega.github.io/vega-lite/docs/project.html)
        /// over multiple fields or encodings.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }

        /// <summary>
        /// The name of a selection.
        /// </summary>
        [JsonProperty("selection")]
        public string Selection { get; set; }

        /// <summary>
        /// The encoding channel to extract selected values for, when a selection is
        /// [projected](https://vega.github.io/vega-lite/docs/project.html)
        /// over multiple fields or encodings.
        /// </summary>
        [JsonProperty("encoding", NullValueHandling = NullValueHandling.Ignore)]
        public string Encoding { get; set; }
    }

    public partial class ScaleInterpolateParams
    {
        [JsonProperty("gamma", NullValueHandling = NullValueHandling.Ignore)]
        public double? Gamma { get; set; }

        [JsonProperty("type")]
        public ScaleInterpolateParamsType Type { get; set; }
    }

    public partial class NiceClass
    {
        [JsonProperty("interval")]
        public string Interval { get; set; }

        [JsonProperty("step")]
        public double Step { get; set; }
    }

    public partial class SchemeParams
    {
        /// <summary>
        /// The number of colors to use in the scheme. This can be useful for scale types such as
        /// `"quantize"`, which use the length of the scale range to determine the number of discrete
        /// bins for the scale domain.
        /// </summary>
        [JsonProperty("count", NullValueHandling = NullValueHandling.Ignore)]
        public double? Count { get; set; }

        /// <summary>
        /// For sequential and diverging schemes only, determines the extent of the color range to
        /// use. For example `[0.2, 1]` will rescale the color scheme such that color values in the
        /// range _[0, 0.2)_ are excluded from the scheme.
        /// </summary>
        [JsonProperty("extent", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Extent { get; set; }

        /// <summary>
        /// A color scheme name for sequential/ordinal scales (e.g., `"category10"` or `"viridis"`).
        ///
        /// For the full list of supported schemes, please refer to the [Vega
        /// Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }
    }

    /// <summary>
    /// A sort definition for sorting a discrete scale in an encoding field definition.
    /// </summary>
    public partial class EncodingSortField
    {
        /// <summary>
        /// The data [field](https://vega.github.io/vega-lite/docs/field.html) to sort by.
        ///
        /// __Default value:__ If unspecified, defaults to the field specified in the outer data
        /// reference.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// An [aggregate operation](https://vega.github.io/vega-lite/docs/aggregate.html#ops) to
        /// perform on the field prior to sorting (e.g., `"count"`, `"mean"` and `"median"`).
        /// This property is required in cases where the sort field and the data reference field do
        /// not match.
        /// The input data objects will be aggregated, grouped by the encoded data field.
        ///
        /// For a full list of operations, please see the documentation for
        /// [aggregate](https://vega.github.io/vega-lite/docs/aggregate.html#ops).
        /// </summary>
        [JsonProperty("op")]
        public AggregateOp Op { get; set; }

        /// <summary>
        /// The sort order. One of `"ascending"` (default), `"descending"`, or `null` (no not sort).
        /// </summary>
        [JsonProperty("order")]
        public VgComparatorOrder? Order { get; set; }
    }

    /// <summary>
    /// Horizontal facets for trellis plots.
    ///
    /// Vertical facets for trellis plots.
    /// </summary>
    public partial class FacetFieldDef
    {
        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// An object defining properties of a facet's header.
        /// </summary>
        [JsonProperty("header", NullValueHandling = NullValueHandling.Ignore)]
        public Header Header { get; set; }

        /// <summary>
        /// Sort order for the encoded field.
        ///
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
        /// `"descending"`.
        ///
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
        /// Javascript.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
        /// for sorting by another field.
        /// - [An array specifying the field values in preferred
        /// order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
        /// sort order will obey the values in the array, followed by any unspecified values in their
        /// original order.  For discrete time field, values in the sort array can be [date-time
        /// definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
        /// the values can be the month or day names (case insensitive) or their 3-letter initials
        /// (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        ///
        /// __Default value:__ `"ascending"`
        ///
        /// __Note:__ `null` is not supported for `row` and `column`.
        /// </summary>
        [JsonProperty("sort")]
        public Sort? Sort { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type")]
        public PurpleType Type { get; set; }
    }

    /// <summary>
    /// An object defining properties of a facet's header.
    ///
    /// Headers of row / column channels for faceted plots.
    /// </summary>
    public partial class Header
    {
        /// <summary>
        /// The formatting pattern for labels. This is D3's [number format
        /// pattern](https://github.com/d3/d3-format#locale_format) for quantitative fields and D3's
        /// [time format pattern](https://github.com/d3/d3-time-format#locale_format) for time
        /// field.
        ///
        /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
        /// more information.
        ///
        /// __Default value:__  derived from
        /// [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
        /// quantitative fields and from
        /// [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
        /// temporal fields.
        /// </summary>
        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        public string Format { get; set; }

        /// <summary>
        /// The rotation angle of the header labels.
        ///
        /// __Default value:__ `0` for column header, `-90` for row header.
        /// </summary>
        [JsonProperty("labelAngle", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelAngle { get; set; }

        /// <summary>
        /// The color of the header label, can be in hex color code or regular color name.
        /// </summary>
        [JsonProperty("labelColor", NullValueHandling = NullValueHandling.Ignore)]
        public string LabelColor { get; set; }

        /// <summary>
        /// The font of the header label.
        /// </summary>
        [JsonProperty("labelFont", NullValueHandling = NullValueHandling.Ignore)]
        public string LabelFont { get; set; }

        /// <summary>
        /// The font size of the header label, in pixels.
        /// </summary>
        [JsonProperty("labelFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelFontSize { get; set; }

        /// <summary>
        /// The maximum length of the header label in pixels. The text value will be automatically
        /// truncated if the rendered size exceeds the limit.
        ///
        /// __Default value:__ `0`, indicating no limit
        /// </summary>
        [JsonProperty("labelLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelLimit { get; set; }

        /// <summary>
        /// The orthogonal distance in pixels by which to displace the title from its position along
        /// the edge of the chart.
        ///
        /// __Default value:__ `10`
        /// </summary>
        [JsonProperty("labelPadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelPadding { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For
        /// example, with an orientation of top these anchor positions map to a left-, center-, or
        /// right-aligned title.
        ///
        /// __Default value:__ `"middle"` for
        /// [single](https://vega.github.io/vega-lite/docs/spec.html) and
        /// [layered](https://vega.github.io/vega-lite/docs/layer.html) views.
        /// `"start"` for other composite views.
        ///
        /// __Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only
        /// customizable only for [single](https://vega.github.io/vega-lite/docs/spec.html) and
        /// [layered](https://vega.github.io/vega-lite/docs/layer.html) views.  For other composite
        /// views, `anchor` is always `"start"`.
        /// </summary>
        [JsonProperty("titleAnchor", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleAnchor { get; set; }

        /// <summary>
        /// The rotation angle of the header title.
        ///
        /// __Default value:__ `0`.
        /// </summary>
        [JsonProperty("titleAngle", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleAngle { get; set; }

        /// <summary>
        /// Vertical text baseline for the header title. One of `"top"`, `"bottom"`, `"middle"`.
        ///
        /// __Default value:__ `"middle"`
        /// </summary>
        [JsonProperty("titleBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? TitleBaseline { get; set; }

        /// <summary>
        /// Color of the header title, can be in hex color code or regular color name.
        /// </summary>
        [JsonProperty("titleColor", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleColor { get; set; }

        /// <summary>
        /// Font of the header title. (e.g., `"Helvetica Neue"`).
        /// </summary>
        [JsonProperty("titleFont", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleFont { get; set; }

        /// <summary>
        /// Font size of the header title.
        /// </summary>
        [JsonProperty("titleFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleFontSize { get; set; }

        /// <summary>
        /// Font weight of the header title.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("titleFontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? TitleFontWeight { get; set; }

        /// <summary>
        /// The maximum length of the header title in pixels. The text value will be automatically
        /// truncated if the rendered size exceeds the limit.
        ///
        /// __Default value:__ `0`, indicating no limit
        /// </summary>
        [JsonProperty("titleLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleLimit { get; set; }

        /// <summary>
        /// The orthogonal distance in pixels by which to displace the title from its position along
        /// the edge of the chart.
        ///
        /// __Default value:__ `10`
        /// </summary>
        [JsonProperty("titlePadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitlePadding { get; set; }
    }

    /// <summary>
    /// Field Def without scale (and without bin: "binned" support).
    ///
    /// A data field to use as a unique key for data binding. When a visualization’s data is
    /// updated, the key value will be used to match data elements to existing mark instances.
    /// Use a key channel to enable object constancy for transitions over dynamic data.
    ///
    /// Latitude position of geographically projected marks.
    ///
    /// Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and
    /// `"rule"`.
    ///
    /// Longitude position of geographically projected marks.
    ///
    /// Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`,
    /// and  `"rule"`.
    /// </summary>
    public partial class FieldDef
    {
        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type")]
        public PurpleType Type { get; set; }
    }

    /// <summary>
    /// A URL to load upon mouse click.
    ///
    /// A FieldDef with Condition<ValueDef>
    /// {
    /// condition: {value: ...},
    /// field: ...,
    /// ...
    /// }
    ///
    /// A ValueDef with optional Condition<ValueDef | FieldDef>
    /// {
    /// condition: {field: ...} | {value: ...},
    /// value: ...,
    /// }
    ///
    /// A Condition<ValueDef | FieldDef> only definition.
    /// {
    /// condition: {field: ...} | {value: ...}
    /// }
    /// </summary>
    public partial class ValueDefWithCondition
    {
        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// One or more value definition(s) with a selection predicate.
        ///
        /// __Note:__ A field definition's `condition` property can only contain [value
        /// definitions](https://vega.github.io/vega-lite/docs/encoding.html#value-def)
        /// since Vega-Lite only allows at most one encoded field per encoding channel.
        ///
        /// A field definition or one or more value definition(s) with a selection predicate.
        /// </summary>
        [JsonProperty("condition", NullValueHandling = NullValueHandling.Ignore)]
        public HrefCondition? Condition { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleType? Type { get; set; }

        /// <summary>
        /// A constant value in visual domain.
        /// </summary>
        [JsonProperty("value")]
        public Value? Value { get; set; }
    }

    public partial class ConditionalPredicateFieldDefClass
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public LogicalOperandPredicate? Test { get; set; }

        /// <summary>
        /// A constant value in visual domain (e.g., `"red"` / "#0099ff" for color, values between
        /// `0` to `1` for opacity).
        /// </summary>
        [JsonProperty("value")]
        public Value? Value { get; set; }

        /// <summary>
        /// A [selection name](https://vega.github.io/vega-lite/docs/selection.html), or a series of
        /// [composed selections](https://vega.github.io/vega-lite/docs/selection.html#compose).
        /// </summary>
        [JsonProperty("selection", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionOperand? Selection { get; set; }

        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleType? Type { get; set; }
    }

    public partial class OrderFieldDef
    {
        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// The sort order. One of `"ascending"` (default) or `"descending"`.
        /// </summary>
        [JsonProperty("sort")]
        public VgComparatorOrder? Sort { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type")]
        public PurpleType Type { get; set; }
    }

    /// <summary>
    /// Definition object for a constant value of an encoding channel.
    /// </summary>
    public partial class OrderFieldDefClass
    {
        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// The sort order. One of `"ascending"` (default) or `"descending"`.
        /// </summary>
        [JsonProperty("sort")]
        public VgComparatorOrder? Sort { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleType? Type { get; set; }

        /// <summary>
        /// A constant value in visual domain (e.g., `"red"` / "#0099ff" for color, values between
        /// `0` to `1` for opacity).
        /// </summary>
        [JsonProperty("value")]
        public Value? Value { get; set; }
    }

    /// <summary>
    /// Text of the `text` mark.
    ///
    /// A FieldDef with Condition<ValueDef>
    /// {
    /// condition: {value: ...},
    /// field: ...,
    /// ...
    /// }
    ///
    /// A ValueDef with optional Condition<ValueDef | FieldDef>
    /// {
    /// condition: {field: ...} | {value: ...},
    /// value: ...,
    /// }
    ///
    /// A Condition<ValueDef | FieldDef> only definition.
    /// {
    /// condition: {field: ...} | {value: ...}
    /// }
    /// </summary>
    public partial class TextValueDefWithCondition
    {
        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// One or more value definition(s) with a selection predicate.
        ///
        /// __Note:__ A field definition's `condition` property can only contain [value
        /// definitions](https://vega.github.io/vega-lite/docs/encoding.html#value-def)
        /// since Vega-Lite only allows at most one encoded field per encoding channel.
        ///
        /// A field definition or one or more value definition(s) with a selection predicate.
        /// </summary>
        [JsonProperty("condition", NullValueHandling = NullValueHandling.Ignore)]
        public TextCondition? Condition { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// The [formatting pattern](https://vega.github.io/vega-lite/docs/format.html) for a text
        /// field. If not defined, this will be determined automatically.
        /// </summary>
        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        public string Format { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleType? Type { get; set; }

        /// <summary>
        /// A constant value in visual domain.
        /// </summary>
        [JsonProperty("value")]
        public Value? Value { get; set; }
    }

    public partial class ConditionalPredicateTextFieldDefClass
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public LogicalOperandPredicate? Test { get; set; }

        /// <summary>
        /// A constant value in visual domain (e.g., `"red"` / "#0099ff" for color, values between
        /// `0` to `1` for opacity).
        /// </summary>
        [JsonProperty("value")]
        public Value? Value { get; set; }

        /// <summary>
        /// A [selection name](https://vega.github.io/vega-lite/docs/selection.html), or a series of
        /// [composed selections](https://vega.github.io/vega-lite/docs/selection.html#compose).
        /// </summary>
        [JsonProperty("selection", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionOperand? Selection { get; set; }

        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// The [formatting pattern](https://vega.github.io/vega-lite/docs/format.html) for a text
        /// field. If not defined, this will be determined automatically.
        /// </summary>
        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        public string Format { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleType? Type { get; set; }
    }

    public partial class TextFieldDef
    {
        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// The [formatting pattern](https://vega.github.io/vega-lite/docs/format.html) for a text
        /// field. If not defined, this will be determined automatically.
        /// </summary>
        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        public string Format { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type")]
        public PurpleType Type { get; set; }
    }

    /// <summary>
    /// A FieldDef with Condition<ValueDef>
    /// {
    /// condition: {value: ...},
    /// field: ...,
    /// ...
    /// }
    ///
    /// A ValueDef with optional Condition<ValueDef | FieldDef>
    /// {
    /// condition: {field: ...} | {value: ...},
    /// value: ...,
    /// }
    ///
    /// A Condition<ValueDef | FieldDef> only definition.
    /// {
    /// condition: {field: ...} | {value: ...}
    /// }
    /// </summary>
    public partial class TextFieldDefWithCondition
    {
        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// One or more value definition(s) with a selection predicate.
        ///
        /// __Note:__ A field definition's `condition` property can only contain [value
        /// definitions](https://vega.github.io/vega-lite/docs/encoding.html#value-def)
        /// since Vega-Lite only allows at most one encoded field per encoding channel.
        ///
        /// A field definition or one or more value definition(s) with a selection predicate.
        /// </summary>
        [JsonProperty("condition", NullValueHandling = NullValueHandling.Ignore)]
        public TextCondition? Condition { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// The [formatting pattern](https://vega.github.io/vega-lite/docs/format.html) for a text
        /// field. If not defined, this will be determined automatically.
        /// </summary>
        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        public string Format { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleType? Type { get; set; }

        /// <summary>
        /// A constant value in visual domain.
        /// </summary>
        [JsonProperty("value")]
        public Value? Value { get; set; }
    }

    /// <summary>
    /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"`.
    ///
    /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"`.
    ///
    /// Definition object for a constant value of an encoding channel.
    /// </summary>
    public partial class XClass
    {
        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// An object defining properties of axis's gridlines, ticks and labels.
        /// If `null`, the axis for the encoding channel will be removed.
        ///
        /// __Default value:__ If undefined, default [axis
        /// properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.
        /// </summary>
        [JsonProperty("axis")]
        public Axis Axis { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// An object defining the properties of the Impute Operation to be applied.
        /// The field value of the other positional channel is taken as `key` of the `Impute`
        /// Operation.
        /// The field of the `color` channel if specified is used as `groupby` of the `Impute`
        /// Operation.
        /// </summary>
        [JsonProperty("impute", NullValueHandling = NullValueHandling.Ignore)]
        public ImputeParams Impute { get; set; }

        /// <summary>
        /// An object defining properties of the channel's scale, which is the function that
        /// transforms values in the data domain (numbers, dates, strings, etc) to visual values
        /// (pixels, colors, sizes) of the encoding channels.
        ///
        /// If `null`, the scale will be [disabled and the data value will be directly
        /// encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
        ///
        /// __Default value:__ If undefined, default [scale
        /// properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
        /// </summary>
        [JsonProperty("scale")]
        public Scale Scale { get; set; }

        /// <summary>
        /// Sort order for the encoded field.
        ///
        /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
        /// `"descending"`.
        ///
        /// For discrete fields, `sort` can be one of the following:
        /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
        /// Javascript.
        /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
        /// for sorting by another field.
        /// - [An array specifying the field values in preferred
        /// order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
        /// sort order will obey the values in the array, followed by any unspecified values in their
        /// original order.  For discrete time field, values in the sort array can be [date-time
        /// definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
        /// the values can be the month or day names (case insensitive) or their 3-letter initials
        /// (e.g., `"Mon"`, `"Tue"`).
        /// - `null` indicating no sort.
        ///
        /// __Default value:__ `"ascending"`
        ///
        /// __Note:__ `null` is not supported for `row` and `column`.
        /// </summary>
        [JsonProperty("sort")]
        public Sort? Sort { get; set; }

        /// <summary>
        /// Type of stacking offset if the field should be stacked.
        /// `stack` is only applicable for `x` and `y` channels with continuous domains.
        /// For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
        ///
        /// `stack` can be one of the following values:
        /// - `"zero"`: stacking with baseline offset at zero value of the scale (for creating
        /// typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and
        /// [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
        /// - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar
        /// and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>
        /// -`"center"` - stacking with center baseline (for
        /// [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
        /// - `null` - No-stacking. This will produce layered
        /// [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area
        /// chart.
        ///
        /// __Default value:__ `zero` for plots with all of the following conditions are true:
        /// (1) the mark is `bar` or `area`;
        /// (2) the stacked measure channel (x or y) has a linear scale;
        /// (3) At least one of non-position channels mapped to an unaggregated field that is
        /// different from x and y.  Otherwise, `null` by default.
        /// </summary>
        [JsonProperty("stack")]
        public StackOffset? Stack { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleType? Type { get; set; }

        /// <summary>
        /// A constant value in visual domain (e.g., `"red"` / "#0099ff" for color, values between
        /// `0` to `1` for opacity).
        /// </summary>
        [JsonProperty("value")]
        public Value? Value { get; set; }
    }

    public partial class Axis
    {
        /// <summary>
        /// An interpolation fraction indicating where, for `band` scales, axis ticks should be
        /// positioned. A value of `0` places ticks at the left edge of their bands. A value of `0.5`
        /// places ticks in the middle of their bands.
        ///
        /// __Default value:__ `0.5`
        /// </summary>
        [JsonProperty("bandPosition", NullValueHandling = NullValueHandling.Ignore)]
        public double? BandPosition { get; set; }

        /// <summary>
        /// A boolean flag indicating if the domain (the axis baseline) should be included as part of
        /// the axis.
        ///
        /// __Default value:__ `true`
        /// </summary>
        [JsonProperty("domain", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Domain { get; set; }

        /// <summary>
        /// Color of axis domain line.
        ///
        /// __Default value:__ `"gray"`.
        /// </summary>
        [JsonProperty("domainColor", NullValueHandling = NullValueHandling.Ignore)]
        public string DomainColor { get; set; }

        /// <summary>
        /// Opacity of the axis domain line.
        /// </summary>
        [JsonProperty("domainOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? DomainOpacity { get; set; }

        /// <summary>
        /// Stroke width of axis domain line
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("domainWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? DomainWidth { get; set; }

        /// <summary>
        /// The formatting pattern for labels. This is D3's [number format
        /// pattern](https://github.com/d3/d3-format#locale_format) for quantitative fields and D3's
        /// [time format pattern](https://github.com/d3/d3-time-format#locale_format) for time
        /// field.
        ///
        /// See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
        /// more information.
        ///
        /// __Default value:__  derived from
        /// [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
        /// quantitative fields and from
        /// [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
        /// temporal fields.
        /// </summary>
        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        public string Format { get; set; }

        /// <summary>
        /// A boolean flag indicating if grid lines should be included as part of the axis
        ///
        /// __Default value:__ `true` for [continuous
        /// scales](https://vega.github.io/vega-lite/docs/scale.html#continuous) that are not binned;
        /// otherwise, `false`.
        /// </summary>
        [JsonProperty("grid", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Grid { get; set; }

        /// <summary>
        /// Color of gridlines.
        ///
        /// __Default value:__ `"lightGray"`.
        /// </summary>
        [JsonProperty("gridColor", NullValueHandling = NullValueHandling.Ignore)]
        public string GridColor { get; set; }

        /// <summary>
        /// The offset (in pixels) into which to begin drawing with the grid dash array.
        /// </summary>
        [JsonProperty("gridDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] GridDash { get; set; }

        /// <summary>
        /// The stroke opacity of grid (value between [0,1])
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("gridOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? GridOpacity { get; set; }

        /// <summary>
        /// The grid width, in pixels.
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("gridWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? GridWidth { get; set; }

        /// <summary>
        /// Horizontal text alignment of axis tick labels, overriding the default setting for the
        /// current axis orientation.
        /// </summary>
        [JsonProperty("labelAlign", NullValueHandling = NullValueHandling.Ignore)]
        public Align? LabelAlign { get; set; }

        /// <summary>
        /// The rotation angle of the axis labels.
        ///
        /// __Default value:__ `-90` for nominal and ordinal fields; `0` otherwise.
        /// </summary>
        [JsonProperty("labelAngle", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelAngle { get; set; }

        /// <summary>
        /// Vertical text baseline of axis tick labels, overriding the default setting for the
        /// current axis orientation. Can be `"top"`, `"middle"`, `"bottom"`, or `"alphabetic"`.
        /// </summary>
        [JsonProperty("labelBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? LabelBaseline { get; set; }

        /// <summary>
        /// Indicates if labels should be hidden if they exceed the axis range. If `false` (the
        /// default) no bounds overlap analysis is performed. If `true`, labels will be hidden if
        /// they exceed the axis range by more than 1 pixel. If this property is a number, it
        /// specifies the pixel tolerance: the maximum amount by which a label bounding box may
        /// exceed the axis range.
        ///
        /// __Default value:__ `false`.
        /// </summary>
        [JsonProperty("labelBound", NullValueHandling = NullValueHandling.Ignore)]
        public Label? LabelBound { get; set; }

        /// <summary>
        /// The color of the tick label, can be in hex color code or regular color name.
        /// </summary>
        [JsonProperty("labelColor", NullValueHandling = NullValueHandling.Ignore)]
        public string LabelColor { get; set; }

        /// <summary>
        /// Indicates if the first and last axis labels should be aligned flush with the scale range.
        /// Flush alignment for a horizontal axis will left-align the first label and right-align the
        /// last label. For vertical axes, bottom and top text baselines are applied instead. If this
        /// property is a number, it also indicates the number of pixels by which to offset the first
        /// and last labels; for example, a value of 2 will flush-align the first and last labels and
        /// also push them 2 pixels outward from the center of the axis. The additional adjustment
        /// can sometimes help the labels better visually group with corresponding axis ticks.
        ///
        /// __Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.
        /// </summary>
        [JsonProperty("labelFlush", NullValueHandling = NullValueHandling.Ignore)]
        public Label? LabelFlush { get; set; }

        /// <summary>
        /// Indicates the number of pixels by which to offset flush-adjusted labels. For example, a
        /// value of `2` will push flush-adjusted labels 2 pixels outward from the center of the
        /// axis. Offsets can help the labels better visually group with corresponding axis ticks.
        ///
        /// __Default value:__ `0`.
        /// </summary>
        [JsonProperty("labelFlushOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelFlushOffset { get; set; }

        /// <summary>
        /// The font of the tick label.
        /// </summary>
        [JsonProperty("labelFont", NullValueHandling = NullValueHandling.Ignore)]
        public string LabelFont { get; set; }

        /// <summary>
        /// The font size of the label, in pixels.
        /// </summary>
        [JsonProperty("labelFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelFontSize { get; set; }

        /// <summary>
        /// Font weight of axis tick labels.
        /// </summary>
        [JsonProperty("labelFontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? LabelFontWeight { get; set; }

        /// <summary>
        /// Maximum allowed pixel width of axis tick labels.
        ///
        /// __Default value:__ `180`
        /// </summary>
        [JsonProperty("labelLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelLimit { get; set; }

        /// <summary>
        /// The opacity of the labels.
        /// </summary>
        [JsonProperty("labelOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelOpacity { get; set; }

        /// <summary>
        /// The strategy to use for resolving overlap of axis labels. If `false` (the default), no
        /// overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing
        /// every other label is used (this works well for standard linear axes). If set to
        /// `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps
        /// with the last visible label (this often works better for log-scaled axes).
        ///
        /// __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log
        /// scales; otherwise `false`.
        /// </summary>
        [JsonProperty("labelOverlap", NullValueHandling = NullValueHandling.Ignore)]
        public LabelOverlap? LabelOverlap { get; set; }

        /// <summary>
        /// The padding, in pixels, between axis and text labels.
        ///
        /// __Default value:__ `2`
        /// </summary>
        [JsonProperty("labelPadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? LabelPadding { get; set; }

        /// <summary>
        /// A boolean flag indicating if labels should be included as part of the axis.
        ///
        /// __Default value:__ `true`.
        /// </summary>
        [JsonProperty("labels", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Labels { get; set; }

        /// <summary>
        /// The maximum extent in pixels that axis ticks and labels should use. This determines a
        /// maximum offset value for axis titles.
        ///
        /// __Default value:__ `undefined`.
        /// </summary>
        [JsonProperty("maxExtent", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxExtent { get; set; }

        /// <summary>
        /// The minimum extent in pixels that axis ticks and labels should use. This determines a
        /// minimum offset value for axis titles.
        ///
        /// __Default value:__ `30` for y-axis; `undefined` for x-axis.
        /// </summary>
        [JsonProperty("minExtent", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinExtent { get; set; }

        /// <summary>
        /// The offset, in pixels, by which to displace the axis from the edge of the enclosing group
        /// or data rectangle.
        ///
        /// __Default value:__ derived from the [axis
        /// config](https://vega.github.io/vega-lite/docs/config.html#facet-scale-config)'s `offset`
        /// (`0` by default)
        /// </summary>
        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? Offset { get; set; }

        /// <summary>
        /// The orientation of the axis. One of `"top"`, `"bottom"`, `"left"` or `"right"`. The
        /// orientation can be used to further specialize the axis type (e.g., a y axis oriented for
        /// the right edge of the chart).
        ///
        /// __Default value:__ `"bottom"` for x-axes and `"left"` for y-axes.
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public AxisOrient? Orient { get; set; }

        /// <summary>
        /// The anchor position of the axis in pixels. For x-axes with top or bottom orientation,
        /// this sets the axis group x coordinate. For y-axes with left or right orientation, this
        /// sets the axis group y coordinate.
        ///
        /// __Default value__: `0`
        /// </summary>
        [JsonProperty("position", NullValueHandling = NullValueHandling.Ignore)]
        public double? Position { get; set; }

        /// <summary>
        /// The color of the axis's tick.
        ///
        /// __Default value:__ `"gray"`
        /// </summary>
        [JsonProperty("tickColor", NullValueHandling = NullValueHandling.Ignore)]
        public string TickColor { get; set; }

        /// <summary>
        /// A desired number of ticks, for axes visualizing quantitative scales. The resulting number
        /// may be different so that values are "nice" (multiples of 2, 5, 10) and lie within the
        /// underlying scale's range.
        /// </summary>
        [JsonProperty("tickCount", NullValueHandling = NullValueHandling.Ignore)]
        public double? TickCount { get; set; }

        /// <summary>
        /// Boolean flag indicating if an extra axis tick should be added for the initial position of
        /// the axis. This flag is useful for styling axes for `band` scales such that ticks are
        /// placed on band boundaries rather in the middle of a band. Use in conjunction with
        /// `"bandPostion": 1` and an axis `"padding"` value of `0`.
        /// </summary>
        [JsonProperty("tickExtra", NullValueHandling = NullValueHandling.Ignore)]
        public bool? TickExtra { get; set; }

        /// <summary>
        /// Position offset in pixels to apply to ticks, labels, and gridlines.
        /// </summary>
        [JsonProperty("tickOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? TickOffset { get; set; }

        /// <summary>
        /// Opacity of the ticks.
        /// </summary>
        [JsonProperty("tickOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? TickOpacity { get; set; }

        /// <summary>
        /// Boolean flag indicating if pixel position values should be rounded to the nearest
        /// integer.
        ///
        /// __Default value:__ `true`
        /// </summary>
        [JsonProperty("tickRound", NullValueHandling = NullValueHandling.Ignore)]
        public bool? TickRound { get; set; }

        /// <summary>
        /// Boolean value that determines whether the axis should include ticks.
        ///
        /// __Default value:__ `true`
        /// </summary>
        [JsonProperty("ticks", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Ticks { get; set; }

        /// <summary>
        /// The size in pixels of axis ticks.
        ///
        /// __Default value:__ `5`
        /// </summary>
        [JsonProperty("tickSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? TickSize { get; set; }

        /// <summary>
        /// A desired step size for ticks. This property will generate the corresponding `tickCount`
        /// and `values`. It can be useful for [data that are binned before importing into
        /// Vega-Lite](https://vega.github.io/vega-lite/docs/bin.html#binned).
        ///
        /// __Default value__: `undefined`
        /// </summary>
        [JsonProperty("tickStep", NullValueHandling = NullValueHandling.Ignore)]
        public double? TickStep { get; set; }

        /// <summary>
        /// The width, in pixels, of ticks.
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("tickWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? TickWidth { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// Horizontal text alignment of axis titles.
        /// </summary>
        [JsonProperty("titleAlign", NullValueHandling = NullValueHandling.Ignore)]
        public Align? TitleAlign { get; set; }

        /// <summary>
        /// Angle in degrees of axis titles.
        /// </summary>
        [JsonProperty("titleAngle", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleAngle { get; set; }

        /// <summary>
        /// Vertical text baseline for axis titles.
        /// </summary>
        [JsonProperty("titleBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? TitleBaseline { get; set; }

        /// <summary>
        /// Color of the title, can be in hex color code or regular color name.
        /// </summary>
        [JsonProperty("titleColor", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleColor { get; set; }

        /// <summary>
        /// Font of the title. (e.g., `"Helvetica Neue"`).
        /// </summary>
        [JsonProperty("titleFont", NullValueHandling = NullValueHandling.Ignore)]
        public string TitleFont { get; set; }

        /// <summary>
        /// Font size of the title.
        /// </summary>
        [JsonProperty("titleFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleFontSize { get; set; }

        /// <summary>
        /// Font weight of the title.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("titleFontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? TitleFontWeight { get; set; }

        /// <summary>
        /// Maximum allowed pixel width of axis titles.
        /// </summary>
        [JsonProperty("titleLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleLimit { get; set; }

        /// <summary>
        /// Opacity of the axis title.
        /// </summary>
        [JsonProperty("titleOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleOpacity { get; set; }

        /// <summary>
        /// The padding, in pixels, between title and axis.
        /// </summary>
        [JsonProperty("titlePadding", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitlePadding { get; set; }

        /// <summary>
        /// X-coordinate of the axis title relative to the axis group.
        /// </summary>
        [JsonProperty("titleX", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleX { get; set; }

        /// <summary>
        /// Y-coordinate of the axis title relative to the axis group.
        /// </summary>
        [JsonProperty("titleY", NullValueHandling = NullValueHandling.Ignore)]
        public double? TitleY { get; set; }

        /// <summary>
        /// Explicitly set the visible axis tick values.
        /// </summary>
        [JsonProperty("values", NullValueHandling = NullValueHandling.Ignore)]
        public Equal[] Values { get; set; }

        /// <summary>
        /// A non-positive integer indicating z-index of the axis.
        /// If zindex is 0, axes should be drawn behind all chart elements.
        /// To put them in front, use `"zindex = 1"`.
        ///
        /// __Default value:__ `1` (in front of the marks) for actual axis and `0` (behind the marks)
        /// for grids.
        /// </summary>
        [JsonProperty("zindex", NullValueHandling = NullValueHandling.Ignore)]
        public double? Zindex { get; set; }
    }

    /// <summary>
    /// An object defining the properties of the Impute Operation to be applied.
    /// The field value of the other positional channel is taken as `key` of the `Impute`
    /// Operation.
    /// The field of the `color` channel if specified is used as `groupby` of the `Impute`
    /// Operation.
    /// </summary>
    public partial class ImputeParams
    {
        /// <summary>
        /// A frame specification as a two-element array used to control the window over which the
        /// specified method is applied. The array entries should either be a number indicating the
        /// offset from the current data object, or null to indicate unbounded rows preceding or
        /// following the current data object.  For example, the value `[-5, 5]` indicates that the
        /// window should include five objects preceding and five objects following the current
        /// object.
        ///
        /// __Default value:__:  `[null, null]` indicating that the window includes all objects.
        /// </summary>
        [JsonProperty("frame", NullValueHandling = NullValueHandling.Ignore)]
        public double?[] Frame { get; set; }

        /// <summary>
        /// Defines the key values that should be considered for imputation.
        /// An array of key values or an object defining a [number
        /// sequence](https://vega.github.io/vega-lite/docs/impute.html#sequence-def).
        ///
        /// If provided, this will be used in addition to the key values observed within the input
        /// data.  If not provided, the values will be derived from all unique values of the `key`
        /// field. For `impute` in `encoding`, the key field is the x-field if the y-field is
        /// imputed, or vice versa.
        ///
        /// If there is no impute grouping, this property _must_ be specified.
        /// </summary>
        [JsonProperty("keyvals", NullValueHandling = NullValueHandling.Ignore)]
        public Keyvals? Keyvals { get; set; }

        /// <summary>
        /// The imputation method to use for the field value of imputed data objects.
        /// One of `value`, `mean`, `median`, `max` or `min`.
        ///
        /// __Default value:__  `"value"`
        /// </summary>
        [JsonProperty("method", NullValueHandling = NullValueHandling.Ignore)]
        public ImputeMethod? Method { get; set; }

        /// <summary>
        /// The field value to use when the imputation `method` is `"value"`.
        /// </summary>
        [JsonProperty("value")]
        public object Value { get; set; }
    }

    public partial class ImputeSequence
    {
        /// <summary>
        /// The starting value of the sequence.
        /// __Default value:__ `0`
        /// </summary>
        [JsonProperty("start", NullValueHandling = NullValueHandling.Ignore)]
        public double? Start { get; set; }

        /// <summary>
        /// The step value between sequence entries.
        /// __Default value:__ `1` or `-1` if `stop < start`
        /// </summary>
        [JsonProperty("step", NullValueHandling = NullValueHandling.Ignore)]
        public double? Step { get; set; }

        /// <summary>
        /// The ending value(exclusive) of the sequence.
        /// </summary>
        [JsonProperty("stop")]
        public double Stop { get; set; }
    }

    /// <summary>
    /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    ///
    /// Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
    ///
    /// Secondary error value of x coordinates for error specified `"errorbar"` and
    /// `"errorband"`.
    ///
    /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
    ///
    /// Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
    ///
    /// Secondary error value of y coordinates for error specified `"errorbar"` and
    /// `"errorband"`.
    ///
    /// Field Def without scale (and without bin: "binned" support).
    ///
    /// A data field to use as a unique key for data binding. When a visualization’s data is
    /// updated, the key value will be used to match data elements to existing mark instances.
    /// Use a key channel to enable object constancy for transitions over dynamic data.
    ///
    /// Latitude position of geographically projected marks.
    ///
    /// Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and
    /// `"rule"`.
    ///
    /// Longitude position of geographically projected marks.
    ///
    /// Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`,
    /// and  `"rule"`.
    ///
    /// Definition object for a constant value of an encoding channel.
    /// </summary>
    public partial class X2Class
    {
        /// <summary>
        /// Aggregation function for the field
        /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregateOp? Aggregate { get; set; }

        /// <summary>
        /// A flag for binning a `quantitative` field, [an object defining binning
        /// parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that
        /// the data for `x` or `y` channel are binned before they are imported into Vega-Lite
        /// (`"binned"`).
        ///
        /// - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html)
        /// will be applied.
        ///
        /// - To indicate that the data for the `x` (or `y`) channel are already binned, you can set
        /// the `bin` property of the `x` (or `y`) channel to `"binned"` and map the bin-start field
        /// to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be
        /// formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin
        /// step, you can also set the axis's
        /// [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBin? Bin { get; set; }

        /// <summary>
        /// __Required.__ A string defining the name of the field from which to pull a data value
        /// or an object defining iterated values from the
        /// [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
        ///
        /// __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
        /// (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`).
        /// If field names contain dots or brackets but are not nested, you can use `\\` to escape
        /// dots and brackets (e.g., `"a\\.b"` and `"a\\[0\\]"`).
        /// See more details about escaping in the [field
        /// documentation](https://vega.github.io/vega-lite/docs/field.html).
        ///
        /// __Note:__ `field` is not required if `aggregate` is `count`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        /// <summary>
        /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
        /// or [a temporal field that gets casted as
        /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
        ///
        /// __Default value:__ `undefined` (None)
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A title for the field. If `null`, the title will be removed.
        ///
        /// __Default value:__  derived from the field's name and transformation function
        /// (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the
        /// function is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is
        /// binned or has a time unit applied, the applied function is shown in parentheses (e.g.,
        /// `"Profit (binned)"`, `"Transaction Date (year-month)"`).  Otherwise, the title is simply
        /// the field name.
        ///
        /// __Notes__:
        ///
        /// 1) You can customize the default field title format by providing the
        /// [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
        /// property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
        /// [`fieldTitle` function via the `compile` function's
        /// options](https://vega.github.io/vega-lite/docs/compile.html#field-title).
        ///
        /// 2) If both field definition's `title` and axis, header, or legend `title` are defined,
        /// axis/header/legend title will be used.
        /// </summary>
        [JsonProperty("title")]
        public string Title { get; set; }

        /// <summary>
        /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
        /// `"nominal"`).
        /// It can also be a `"geojson"` type for encoding
        /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleType? Type { get; set; }

        /// <summary>
        /// A constant value in visual domain (e.g., `"red"` / "#0099ff" for color, values between
        /// `0` to `1` for opacity).
        /// </summary>
        [JsonProperty("value")]
        public Value? Value { get; set; }
    }

    /// <summary>
    /// An object that describes mappings between `row` and `column` channels and their field
    /// definitions.
    /// </summary>
    public partial class FacetMapping
    {
        /// <summary>
        /// Horizontal facets for trellis plots.
        /// </summary>
        [JsonProperty("column", NullValueHandling = NullValueHandling.Ignore)]
        public FacetFieldDef Column { get; set; }

        /// <summary>
        /// Vertical facets for trellis plots.
        /// </summary>
        [JsonProperty("row", NullValueHandling = NullValueHandling.Ignore)]
        public FacetFieldDef Row { get; set; }
    }

    /// <summary>
    /// A specification of the view that gets faceted.
    ///
    /// Layer Spec with encoding and projection
    ///
    /// Unit spec that can have a composite mark and row or column channels.
    /// </summary>
    public partial class SpecClass
    {
        /// <summary>
        /// An object describing the data source
        /// </summary>
        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public Data Data { get; set; }

        /// <summary>
        /// Description of this mark for commenting purpose.
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A shared key-value mapping between encoding channels and definition of fields in the
        /// underlying layers.
        ///
        /// A key-value mapping between encoding channels and definition of fields.
        /// </summary>
        [JsonProperty("encoding", NullValueHandling = NullValueHandling.Ignore)]
        public Encoding Encoding { get; set; }

        /// <summary>
        /// The height of a visualization.
        ///
        /// __Default value:__
        /// - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type
        /// is `"fit"` or its y-channel has a [continuous
        /// scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the height will be
        /// the value of
        /// [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - For y-axis with a band or point scale: if
        /// [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value
        /// or unspecified, the height is [determined by the range step, paddings, and the
        /// cardinality of the field mapped to
        /// y-channel](https://vega.github.io/vega-lite/docs/scale.html#band). Otherwise, if the
        /// `rangeStep` is `null`, the height will be the value of
        /// [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - If no field is mapped to `y` channel, the `height` will be the value of `rangeStep`.
        ///
        /// __Note__: For plots with [`row` and `column`
        /// channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
        /// height of a single view.
        ///
        /// __See also:__ The documentation for [width and
        /// height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.
        /// </summary>
        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public double? Height { get; set; }

        /// <summary>
        /// Layer or single view specifications to be layered.
        ///
        /// __Note__: Specifications inside `layer` cannot use `row` and `column` channels as
        /// layering facet specifications is not allowed. Instead, use the [facet
        /// operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a
        /// facet.
        /// </summary>
        [JsonProperty("layer", NullValueHandling = NullValueHandling.Ignore)]
        public LayerSpec[] Layer { get; set; }

        /// <summary>
        /// Name of the visualization for later reference.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// An object defining properties of the geographic projection shared by underlying layers.
        ///
        /// An object defining properties of geographic projection, which will be applied to `shape`
        /// path for `"geoshape"` marks
        /// and to `latitude` and `"longitude"` channels for other marks.
        /// </summary>
        [JsonProperty("projection", NullValueHandling = NullValueHandling.Ignore)]
        public Projection Projection { get; set; }

        /// <summary>
        /// Scale, axis, and legend resolutions for layers.
        ///
        /// Scale, axis, and legend resolutions for facets.
        ///
        /// Scale and legend resolutions for repeated charts.
        ///
        /// Scale, axis, and legend resolutions for vertically concatenated charts.
        ///
        /// Scale, axis, and legend resolutions for horizontally concatenated charts.
        /// </summary>
        [JsonProperty("resolve", NullValueHandling = NullValueHandling.Ignore)]
        public Resolve Resolve { get; set; }

        /// <summary>
        /// Title for the plot.
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public Title? Title { get; set; }

        /// <summary>
        /// An array of data transformations such as filter and new field calculation.
        /// </summary>
        [JsonProperty("transform", NullValueHandling = NullValueHandling.Ignore)]
        public Transform[] Transform { get; set; }

        /// <summary>
        /// The width of a visualization.
        ///
        /// __Default value:__ This will be determined by the following rules:
        ///
        /// - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type
        /// is `"fit"` or its x-channel has a [continuous
        /// scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the width will be
        /// the value of
        /// [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - For x-axis with a band or point scale: if
        /// [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value
        /// or unspecified, the width is [determined by the range step, paddings, and the cardinality
        /// of the field mapped to
        /// x-channel](https://vega.github.io/vega-lite/docs/scale.html#band).   Otherwise, if the
        /// `rangeStep` is `null`, the width will be the value of
        /// [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - If no field is mapped to `x` channel, the `width` will be the value of
        /// [`config.scale.textXRangeStep`](https://vega.github.io/vega-lite/docs/size.html#default-width-and-height)
        /// for `text` mark and the value of `rangeStep` for other marks.
        ///
        /// __Note:__ For plots with [`row` and `column`
        /// channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
        /// width of a single view.
        ///
        /// __See also:__ The documentation for [width and
        /// height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.
        /// </summary>
        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public double? Width { get; set; }

        /// <summary>
        /// A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`,
        /// `"line"`,
        /// `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark definition
        /// object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
        /// </summary>
        [JsonProperty("mark", NullValueHandling = NullValueHandling.Ignore)]
        public AnyMark? Mark { get; set; }

        /// <summary>
        /// A key-value mapping between selection names and definitions.
        /// </summary>
        [JsonProperty("selection", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, SelectionDef> Selection { get; set; }

        /// <summary>
        /// The alignment to apply to grid rows and columns.
        /// The supported string values are `"all"`, `"each"`, and `"none"`.
        ///
        /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed
        /// one after the other.
        /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or
        /// column may be of variable size.
        /// - For `"all"`, subviews will be aligned and each row or column will be sized identically
        /// based on the maximum observed size. String values for this property will be applied to
        /// both grid rows and columns.
        ///
        /// Alternatively, an object value of the form `{"row": string, "column": string}` can be
        /// used to supply different alignments for rows and columns.
        ///
        /// __Default value:__ `"all"`.
        /// </summary>
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public AlignUnion? Align { get; set; }

        /// <summary>
        /// The bounds calculation method to use for determining the extent of a sub-plot. One of
        /// `full` (the default) or `flush`.
        ///
        /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will
        /// be used.
        /// - If set to `flush`, only the specified width and height values for the sub-view will be
        /// used. The `flush` setting can be useful when attempting to place sub-plots without axes
        /// or legends into a uniform grid structure.
        ///
        /// __Default value:__ `"full"`
        /// </summary>
        [JsonProperty("bounds", NullValueHandling = NullValueHandling.Ignore)]
        public Bounds? Bounds { get; set; }

        /// <summary>
        /// Boolean flag indicating if subviews should be centered relative to their respective rows
        /// or columns.
        ///
        /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply
        /// different centering values for rows and columns.
        ///
        /// __Default value:__ `false`
        ///
        /// Boolean flag indicating if subviews should be centered relative to their respective rows
        /// or columns.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("center", NullValueHandling = NullValueHandling.Ignore)]
        public Center? Center { get; set; }

        /// <summary>
        /// An object that describes mappings between `row` and `column` channels and their field
        /// definitions.
        /// </summary>
        [JsonProperty("facet", NullValueHandling = NullValueHandling.Ignore)]
        public FacetMapping Facet { get; set; }

        /// <summary>
        /// The spacing in pixels between sub-views of the composition operator.
        /// An object of the form `{"row": number, "column": number}` can be used to set
        /// different spacing values for rows and columns.
        ///
        /// __Default value__: `10`
        ///
        /// The spacing in pixels between sub-views of the concat operator.
        ///
        /// __Default value__: `10`
        /// </summary>
        [JsonProperty("spacing", NullValueHandling = NullValueHandling.Ignore)]
        public Spacing? Spacing { get; set; }

        /// <summary>
        /// A specification of the view that gets faceted.
        /// </summary>
        [JsonProperty("spec", NullValueHandling = NullValueHandling.Ignore)]
        public SpecClass Spec { get; set; }

        /// <summary>
        /// An object that describes what fields should be repeated into views that are laid out as a
        /// `row` or `column`.
        /// </summary>
        [JsonProperty("repeat", NullValueHandling = NullValueHandling.Ignore)]
        public Repeat Repeat { get; set; }

        /// <summary>
        /// A list of views that should be concatenated and put into a column.
        /// </summary>
        [JsonProperty("vconcat", NullValueHandling = NullValueHandling.Ignore)]
        public SpecElement[] Vconcat { get; set; }

        /// <summary>
        /// A list of views that should be concatenated and put into a row.
        /// </summary>
        [JsonProperty("hconcat", NullValueHandling = NullValueHandling.Ignore)]
        public SpecElement[] Hconcat { get; set; }
    }

    /// <summary>
    /// Unit spec that can have a composite mark and row or column channels.
    ///
    /// Layer Spec with encoding and projection
    /// </summary>
    public partial class SpecElement
    {
        /// <summary>
        /// An object describing the data source
        /// </summary>
        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public Data Data { get; set; }

        /// <summary>
        /// Description of this mark for commenting purpose.
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A key-value mapping between encoding channels and definition of fields.
        ///
        /// A shared key-value mapping between encoding channels and definition of fields in the
        /// underlying layers.
        /// </summary>
        [JsonProperty("encoding", NullValueHandling = NullValueHandling.Ignore)]
        public Encoding Encoding { get; set; }

        /// <summary>
        /// The height of a visualization.
        ///
        /// __Default value:__
        /// - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type
        /// is `"fit"` or its y-channel has a [continuous
        /// scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the height will be
        /// the value of
        /// [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - For y-axis with a band or point scale: if
        /// [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value
        /// or unspecified, the height is [determined by the range step, paddings, and the
        /// cardinality of the field mapped to
        /// y-channel](https://vega.github.io/vega-lite/docs/scale.html#band). Otherwise, if the
        /// `rangeStep` is `null`, the height will be the value of
        /// [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - If no field is mapped to `y` channel, the `height` will be the value of `rangeStep`.
        ///
        /// __Note__: For plots with [`row` and `column`
        /// channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
        /// height of a single view.
        ///
        /// __See also:__ The documentation for [width and
        /// height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.
        /// </summary>
        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public double? Height { get; set; }

        /// <summary>
        /// A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`,
        /// `"line"`,
        /// `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark definition
        /// object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
        /// </summary>
        [JsonProperty("mark", NullValueHandling = NullValueHandling.Ignore)]
        public AnyMark? Mark { get; set; }

        /// <summary>
        /// Name of the visualization for later reference.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// An object defining properties of geographic projection, which will be applied to `shape`
        /// path for `"geoshape"` marks
        /// and to `latitude` and `"longitude"` channels for other marks.
        ///
        /// An object defining properties of the geographic projection shared by underlying layers.
        /// </summary>
        [JsonProperty("projection", NullValueHandling = NullValueHandling.Ignore)]
        public Projection Projection { get; set; }

        /// <summary>
        /// A key-value mapping between selection names and definitions.
        /// </summary>
        [JsonProperty("selection", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, SelectionDef> Selection { get; set; }

        /// <summary>
        /// Title for the plot.
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public Title? Title { get; set; }

        /// <summary>
        /// An array of data transformations such as filter and new field calculation.
        /// </summary>
        [JsonProperty("transform", NullValueHandling = NullValueHandling.Ignore)]
        public Transform[] Transform { get; set; }

        /// <summary>
        /// The width of a visualization.
        ///
        /// __Default value:__ This will be determined by the following rules:
        ///
        /// - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type
        /// is `"fit"` or its x-channel has a [continuous
        /// scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the width will be
        /// the value of
        /// [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - For x-axis with a band or point scale: if
        /// [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value
        /// or unspecified, the width is [determined by the range step, paddings, and the cardinality
        /// of the field mapped to
        /// x-channel](https://vega.github.io/vega-lite/docs/scale.html#band).   Otherwise, if the
        /// `rangeStep` is `null`, the width will be the value of
        /// [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - If no field is mapped to `x` channel, the `width` will be the value of
        /// [`config.scale.textXRangeStep`](https://vega.github.io/vega-lite/docs/size.html#default-width-and-height)
        /// for `text` mark and the value of `rangeStep` for other marks.
        ///
        /// __Note:__ For plots with [`row` and `column`
        /// channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
        /// width of a single view.
        ///
        /// __See also:__ The documentation for [width and
        /// height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.
        /// </summary>
        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public double? Width { get; set; }

        /// <summary>
        /// Layer or single view specifications to be layered.
        ///
        /// __Note__: Specifications inside `layer` cannot use `row` and `column` channels as
        /// layering facet specifications is not allowed. Instead, use the [facet
        /// operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a
        /// facet.
        /// </summary>
        [JsonProperty("layer", NullValueHandling = NullValueHandling.Ignore)]
        public LayerSpec[] Layer { get; set; }

        /// <summary>
        /// Scale, axis, and legend resolutions for layers.
        ///
        /// Scale, axis, and legend resolutions for facets.
        ///
        /// Scale and legend resolutions for repeated charts.
        ///
        /// Scale, axis, and legend resolutions for vertically concatenated charts.
        ///
        /// Scale, axis, and legend resolutions for horizontally concatenated charts.
        /// </summary>
        [JsonProperty("resolve", NullValueHandling = NullValueHandling.Ignore)]
        public Resolve Resolve { get; set; }

        /// <summary>
        /// The alignment to apply to grid rows and columns.
        /// The supported string values are `"all"`, `"each"`, and `"none"`.
        ///
        /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed
        /// one after the other.
        /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or
        /// column may be of variable size.
        /// - For `"all"`, subviews will be aligned and each row or column will be sized identically
        /// based on the maximum observed size. String values for this property will be applied to
        /// both grid rows and columns.
        ///
        /// Alternatively, an object value of the form `{"row": string, "column": string}` can be
        /// used to supply different alignments for rows and columns.
        ///
        /// __Default value:__ `"all"`.
        /// </summary>
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public AlignUnion? Align { get; set; }

        /// <summary>
        /// The bounds calculation method to use for determining the extent of a sub-plot. One of
        /// `full` (the default) or `flush`.
        ///
        /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will
        /// be used.
        /// - If set to `flush`, only the specified width and height values for the sub-view will be
        /// used. The `flush` setting can be useful when attempting to place sub-plots without axes
        /// or legends into a uniform grid structure.
        ///
        /// __Default value:__ `"full"`
        /// </summary>
        [JsonProperty("bounds", NullValueHandling = NullValueHandling.Ignore)]
        public Bounds? Bounds { get; set; }

        /// <summary>
        /// Boolean flag indicating if subviews should be centered relative to their respective rows
        /// or columns.
        ///
        /// An object value of the form `{"row": boolean, "column": boolean}` can be used to supply
        /// different centering values for rows and columns.
        ///
        /// __Default value:__ `false`
        ///
        /// Boolean flag indicating if subviews should be centered relative to their respective rows
        /// or columns.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("center", NullValueHandling = NullValueHandling.Ignore)]
        public Center? Center { get; set; }

        /// <summary>
        /// An object that describes mappings between `row` and `column` channels and their field
        /// definitions.
        /// </summary>
        [JsonProperty("facet", NullValueHandling = NullValueHandling.Ignore)]
        public FacetMapping Facet { get; set; }

        /// <summary>
        /// The spacing in pixels between sub-views of the composition operator.
        /// An object of the form `{"row": number, "column": number}` can be used to set
        /// different spacing values for rows and columns.
        ///
        /// __Default value__: `10`
        ///
        /// The spacing in pixels between sub-views of the concat operator.
        ///
        /// __Default value__: `10`
        /// </summary>
        [JsonProperty("spacing", NullValueHandling = NullValueHandling.Ignore)]
        public Spacing? Spacing { get; set; }

        /// <summary>
        /// A specification of the view that gets faceted.
        /// </summary>
        [JsonProperty("spec", NullValueHandling = NullValueHandling.Ignore)]
        public SpecClass Spec { get; set; }

        /// <summary>
        /// An object that describes what fields should be repeated into views that are laid out as a
        /// `row` or `column`.
        /// </summary>
        [JsonProperty("repeat", NullValueHandling = NullValueHandling.Ignore)]
        public Repeat Repeat { get; set; }

        /// <summary>
        /// A list of views that should be concatenated and put into a column.
        /// </summary>
        [JsonProperty("vconcat", NullValueHandling = NullValueHandling.Ignore)]
        public SpecElement[] Vconcat { get; set; }

        /// <summary>
        /// A list of views that should be concatenated and put into a row.
        /// </summary>
        [JsonProperty("hconcat", NullValueHandling = NullValueHandling.Ignore)]
        public SpecElement[] Hconcat { get; set; }
    }

    /// <summary>
    /// Layer Spec with encoding and projection
    ///
    /// Unit spec that can have a composite mark.
    /// </summary>
    public partial class LayerSpec
    {
        /// <summary>
        /// An object describing the data source
        /// </summary>
        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public Data Data { get; set; }

        /// <summary>
        /// Description of this mark for commenting purpose.
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A shared key-value mapping between encoding channels and definition of fields in the
        /// underlying layers.
        ///
        /// A key-value mapping between encoding channels and definition of fields.
        /// </summary>
        [JsonProperty("encoding", NullValueHandling = NullValueHandling.Ignore)]
        public LayerEncoding Encoding { get; set; }

        /// <summary>
        /// The height of a visualization.
        ///
        /// __Default value:__
        /// - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type
        /// is `"fit"` or its y-channel has a [continuous
        /// scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the height will be
        /// the value of
        /// [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - For y-axis with a band or point scale: if
        /// [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value
        /// or unspecified, the height is [determined by the range step, paddings, and the
        /// cardinality of the field mapped to
        /// y-channel](https://vega.github.io/vega-lite/docs/scale.html#band). Otherwise, if the
        /// `rangeStep` is `null`, the height will be the value of
        /// [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - If no field is mapped to `y` channel, the `height` will be the value of `rangeStep`.
        ///
        /// __Note__: For plots with [`row` and `column`
        /// channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
        /// height of a single view.
        ///
        /// __See also:__ The documentation for [width and
        /// height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.
        /// </summary>
        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public double? Height { get; set; }

        /// <summary>
        /// Layer or single view specifications to be layered.
        ///
        /// __Note__: Specifications inside `layer` cannot use `row` and `column` channels as
        /// layering facet specifications is not allowed. Instead, use the [facet
        /// operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a
        /// facet.
        /// </summary>
        [JsonProperty("layer", NullValueHandling = NullValueHandling.Ignore)]
        public LayerSpec[] Layer { get; set; }

        /// <summary>
        /// Name of the visualization for later reference.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// An object defining properties of the geographic projection shared by underlying layers.
        ///
        /// An object defining properties of geographic projection, which will be applied to `shape`
        /// path for `"geoshape"` marks
        /// and to `latitude` and `"longitude"` channels for other marks.
        /// </summary>
        [JsonProperty("projection", NullValueHandling = NullValueHandling.Ignore)]
        public Projection Projection { get; set; }

        /// <summary>
        /// Scale, axis, and legend resolutions for layers.
        /// </summary>
        [JsonProperty("resolve", NullValueHandling = NullValueHandling.Ignore)]
        public Resolve Resolve { get; set; }

        /// <summary>
        /// Title for the plot.
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public Title? Title { get; set; }

        /// <summary>
        /// An array of data transformations such as filter and new field calculation.
        /// </summary>
        [JsonProperty("transform", NullValueHandling = NullValueHandling.Ignore)]
        public Transform[] Transform { get; set; }

        /// <summary>
        /// The width of a visualization.
        ///
        /// __Default value:__ This will be determined by the following rules:
        ///
        /// - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type
        /// is `"fit"` or its x-channel has a [continuous
        /// scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the width will be
        /// the value of
        /// [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - For x-axis with a band or point scale: if
        /// [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value
        /// or unspecified, the width is [determined by the range step, paddings, and the cardinality
        /// of the field mapped to
        /// x-channel](https://vega.github.io/vega-lite/docs/scale.html#band).   Otherwise, if the
        /// `rangeStep` is `null`, the width will be the value of
        /// [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).
        /// - If no field is mapped to `x` channel, the `width` will be the value of
        /// [`config.scale.textXRangeStep`](https://vega.github.io/vega-lite/docs/size.html#default-width-and-height)
        /// for `text` mark and the value of `rangeStep` for other marks.
        ///
        /// __Note:__ For plots with [`row` and `column`
        /// channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
        /// width of a single view.
        ///
        /// __See also:__ The documentation for [width and
        /// height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.
        /// </summary>
        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public double? Width { get; set; }

        /// <summary>
        /// A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`,
        /// `"line"`,
        /// `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark definition
        /// object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
        /// </summary>
        [JsonProperty("mark", NullValueHandling = NullValueHandling.Ignore)]
        public AnyMark? Mark { get; set; }

        /// <summary>
        /// A key-value mapping between selection names and definitions.
        /// </summary>
        [JsonProperty("selection", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, SelectionDef> Selection { get; set; }
    }

    /// <summary>
    /// A shared key-value mapping between encoding channels and definition of fields in the
    /// underlying layers.
    ///
    /// A key-value mapping between encoding channels and definition of fields.
    /// </summary>
    public partial class LayerEncoding
    {
        /// <summary>
        /// Color of the marks – either fill or stroke color based on  the `filled` property of mark
        /// definition.
        /// By default, `color` represents fill color for `"area"`, `"bar"`, `"tick"`,
        /// `"text"`, `"trail"`, `"circle"`, and `"square"` / stroke color for `"line"` and
        /// `"point"`.
        ///
        /// __Default value:__ If undefined, the default color depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.
        ///
        /// _Note:_
        /// 1) For fine-grained control over both fill and stroke colors of the marks, please use the
        /// `fill` and `stroke` channels.  If either `fill` or `stroke` channel is specified, `color`
        /// channel will be ignored.
        /// 2) See the scale documentation for more information about customizing [color
        /// scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition Color { get; set; }

        /// <summary>
        /// Additional levels of detail for grouping data in aggregate views and
        /// in line, trail, and area marks without mapping data to a specific visual channel.
        /// </summary>
        [JsonProperty("detail", NullValueHandling = NullValueHandling.Ignore)]
        public Detail? Detail { get; set; }

        /// <summary>
        /// Fill color of the marks.
        /// __Default value:__ If undefined, the default color depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.
        ///
        /// _Note:_ When using `fill` channel, `color ` channel will be ignored. To customize both
        /// fill and stroke, please use `fill` and `stroke` channels (not `fill` and `color`).
        /// </summary>
        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition Fill { get; set; }

        /// <summary>
        /// Fill opacity of the marks.
        ///
        /// __Default value:__ If undefined, the default opacity depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `fillOpacity` property.
        /// </summary>
        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition FillOpacity { get; set; }

        /// <summary>
        /// A URL to load upon mouse click.
        /// </summary>
        [JsonProperty("href", NullValueHandling = NullValueHandling.Ignore)]
        public ValueDefWithCondition Href { get; set; }

        /// <summary>
        /// A data field to use as a unique key for data binding. When a visualization’s data is
        /// updated, the key value will be used to match data elements to existing mark instances.
        /// Use a key channel to enable object constancy for transitions over dynamic data.
        /// </summary>
        [JsonProperty("key", NullValueHandling = NullValueHandling.Ignore)]
        public FieldDef Key { get; set; }

        /// <summary>
        /// Latitude position of geographically projected marks.
        /// </summary>
        [JsonProperty("latitude", NullValueHandling = NullValueHandling.Ignore)]
        public FieldDef Latitude { get; set; }

        /// <summary>
        /// Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and
        /// `"rule"`.
        /// </summary>
        [JsonProperty("latitude2", NullValueHandling = NullValueHandling.Ignore)]
        public FieldDef Latitude2 { get; set; }

        /// <summary>
        /// Longitude position of geographically projected marks.
        /// </summary>
        [JsonProperty("longitude", NullValueHandling = NullValueHandling.Ignore)]
        public FieldDef Longitude { get; set; }

        /// <summary>
        /// Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`,
        /// and  `"rule"`.
        /// </summary>
        [JsonProperty("longitude2", NullValueHandling = NullValueHandling.Ignore)]
        public FieldDef Longitude2 { get; set; }

        /// <summary>
        /// Opacity of the marks.
        ///
        /// __Default value:__ If undefined, the default opacity depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `opacity` property.
        /// </summary>
        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition Opacity { get; set; }

        /// <summary>
        /// Order of the marks.
        /// - For stacked marks, this `order` channel encodes [stack
        /// order](https://vega.github.io/vega-lite/docs/stack.html#order).
        /// - For line and trail marks, this `order` channel encodes order of data points in the
        /// lines. This can be useful for creating [a connected
        /// scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html).
        /// Setting `order` to `{"value": null}` makes the line marks use the original order in the
        /// data sources.
        /// - Otherwise, this `order` channel encodes layer order of the marks.
        ///
        /// __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating
        /// additional aggregation grouping.
        /// </summary>
        [JsonProperty("order", NullValueHandling = NullValueHandling.Ignore)]
        public Order? Order { get; set; }

        /// <summary>
        /// For `point` marks the supported values are
        /// `"circle"` (default), `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`,
        /// or `"triangle-down"`, or else a custom SVG path string.
        /// For `geoshape` marks it should be a field definition of the geojson data
        ///
        /// __Default value:__ If undefined, the default shape depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape`
        /// property.
        /// </summary>
        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition Shape { get; set; }

        /// <summary>
        /// Size of the mark.
        /// - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
        /// - For `"bar"` and `"tick"` – the bar and tick's size.
        /// - For `"text"` – the text's font size.
        /// - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of
        /// line with varying size)
        /// </summary>
        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition Size { get; set; }

        /// <summary>
        /// Stroke color of the marks.
        /// __Default value:__ If undefined, the default color depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.
        ///
        /// _Note:_ When using `stroke` channel, `color ` channel will be ignored. To customize both
        /// stroke and fill, please use `stroke` and `fill` channels (not `stroke` and `color`).
        /// </summary>
        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition Stroke { get; set; }

        /// <summary>
        /// Stroke opacity of the marks.
        ///
        /// __Default value:__ If undefined, the default opacity depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `strokeOpacity`
        /// property.
        /// </summary>
        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition StrokeOpacity { get; set; }

        /// <summary>
        /// Stroke width of the marks.
        ///
        /// __Default value:__ If undefined, the default stroke width depends on [mark
        /// config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `strokeWidth` property.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public MarkPropValueDefWithCondition StrokeWidth { get; set; }

        /// <summary>
        /// Text of the `text` mark.
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public TextValueDefWithCondition Text { get; set; }

        /// <summary>
        /// The tooltip text to show upon mouse hover.
        /// </summary>
        [JsonProperty("tooltip", NullValueHandling = NullValueHandling.Ignore)]
        public TooltipUnion? Tooltip { get; set; }

        /// <summary>
        /// X coordinates of the marks, or width of horizontal `"bar"` and `"area"`.
        /// </summary>
        [JsonProperty("x", NullValueHandling = NullValueHandling.Ignore)]
        public XClass X { get; set; }

        /// <summary>
        /// X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
        /// </summary>
        [JsonProperty("x2", NullValueHandling = NullValueHandling.Ignore)]
        public X2Class X2 { get; set; }

        /// <summary>
        /// Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
        /// </summary>
        [JsonProperty("xError", NullValueHandling = NullValueHandling.Ignore)]
        public X2Class XError { get; set; }

        /// <summary>
        /// Secondary error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
        /// </summary>
        [JsonProperty("xError2", NullValueHandling = NullValueHandling.Ignore)]
        public X2Class XError2 { get; set; }

        /// <summary>
        /// Y coordinates of the marks, or height of vertical `"bar"` and `"area"`.
        /// </summary>
        [JsonProperty("y", NullValueHandling = NullValueHandling.Ignore)]
        public XClass Y { get; set; }

        /// <summary>
        /// Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
        /// </summary>
        [JsonProperty("y2", NullValueHandling = NullValueHandling.Ignore)]
        public X2Class Y2 { get; set; }

        /// <summary>
        /// Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
        /// </summary>
        [JsonProperty("yError", NullValueHandling = NullValueHandling.Ignore)]
        public X2Class YError { get; set; }

        /// <summary>
        /// Secondary error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
        /// </summary>
        [JsonProperty("yError2", NullValueHandling = NullValueHandling.Ignore)]
        public X2Class YError2 { get; set; }
    }

    public partial class BoxPlotDefClass
    {
        [JsonProperty("box", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Box { get; set; }

        /// <summary>
        /// Whether a composite mark be clipped to the enclosing group’s width and height.
        ///
        /// Whether a mark be clipped to the enclosing group’s width and height.
        /// </summary>
        [JsonProperty("clip", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Clip { get; set; }

        /// <summary>
        /// Default color.  Note that `fill` and `stroke` have higher precedence than `color` and
        /// will override `color`.
        ///
        /// __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public string Color { get; set; }

        /// <summary>
        /// The extent of the whiskers. Available options include:
        /// - `"min-max"`: min and max are the lower and upper whiskers respectively.
        /// - A number representing multiple of the interquartile range (Q3-Q1).  This number will be
        /// multiplied by the IQR. The product will be added to the third quartile to get the upper
        /// whisker and subtracted from the first quartile to get the lower whisker.
        ///
        /// __Default value:__ `1.5`.
        ///
        /// The extent of the rule. Available options include:
        /// - `"ci"`: Extend the rule to the confidence interval of the mean.
        /// - `"stderr"`: The size of rule are set to the value of standard error, extending from the
        /// mean.
        /// - `"stdev"`: The size of rule are set to the value of standard deviation, extending from
        /// the mean.
        /// - `"iqr"`: Extend the rule to the q1 and q3.
        ///
        /// __Default value:__ `"stderr"`.
        ///
        /// The extent of the band. Available options include:
        /// - `"ci"`: Extend the band to the confidence interval of the mean.
        /// - `"stderr"`: The size of band are set to the value of standard error, extending from the
        /// mean.
        /// - `"stdev"`: The size of band are set to the value of standard deviation, extending from
        /// the mean.
        /// - `"iqr"`: Extend the band to the q1 and q3.
        ///
        /// __Default value:__ `"stderr"`.
        /// </summary>
        [JsonProperty("extent", NullValueHandling = NullValueHandling.Ignore)]
        public BoxPlotDefExtent? Extent { get; set; }

        [JsonProperty("median", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Median { get; set; }

        /// <summary>
        /// The opacity (value between [0,1]) of the mark.
        ///
        /// The overall opacity (value between [0,1]).
        ///
        /// __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
        /// `square` marks or layered `bar` charts and `1` otherwise.
        /// </summary>
        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? Opacity { get; set; }

        /// <summary>
        /// Orientation of the box plot.  This is normally automatically determined based on types of
        /// fields on x and y channels. However, an explicit `orient` be specified when the
        /// orientation is ambiguous.
        ///
        /// __Default value:__ `"vertical"`.
        ///
        /// Orientation of the error bar.  This is normally automatically determined, but can be
        /// specified when the orientation is ambiguous and cannot be automatically determined.
        ///
        /// Orientation of the error band. This is normally automatically determined, but can be
        /// specified when the orientation is ambiguous and cannot be automatically determined.
        ///
        /// The orientation of a non-stacked bar, tick, area, and line charts.
        /// The value is either horizontal (default) or vertical.
        /// - For bar, rule and tick, this determines whether the size of the bar and tick
        /// should be applied to x or y dimension.
        /// - For area, this property determines the orient property of the Vega output.
        /// - For line and trail marks, this property determines the sort order of the points in the
        /// line
        /// if `config.sortLineBy` is not specified.
        /// For stacked charts, this is always determined by the orientation of the stack;
        /// therefore explicitly specified value will be ignored.
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public Orient? Orient { get; set; }

        [JsonProperty("outliers", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Outliers { get; set; }

        [JsonProperty("rule", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Rule { get; set; }

        /// <summary>
        /// Size of the box and median tick of a box plot
        ///
        /// Default size for marks.
        /// - For `point`/`circle`/`square`, this represents the pixel area of the marks. For
        /// example: in the case of circles, the radius is determined in part by the square root of
        /// the size value.
        /// - For `bar`, this represents the band size of the bar, in pixels.
        /// - For `text`, this represents the font size, in pixels.
        ///
        /// __Default value:__ `30` for point, circle, square marks; `rangeStep` - 1 for bar marks
        /// with discrete dimensions; `5` for bar marks with continuous dimensions; `11` for text
        /// marks.
        /// </summary>
        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public double? Size { get; set; }

        [JsonProperty("ticks", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Ticks { get; set; }

        /// <summary>
        /// The mark type. This could a primitive mark type
        /// (one of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`,
        /// `"area"`, `"point"`, `"geoshape"`, `"rule"`, and `"text"`)
        /// or a composite mark type (`"boxplot"`, `"errorband"`, `"errorbar"`).
        ///
        /// The mark type.
        /// One of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`,
        /// `"area"`, `"point"`, `"geoshape"`, `"rule"`, and `"text"`.
        /// </summary>
        [JsonProperty("type")]
        public BoxPlot Type { get; set; }

        [JsonProperty("band", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Band { get; set; }

        [JsonProperty("borders", NullValueHandling = NullValueHandling.Ignore)]
        public Box? Borders { get; set; }

        /// <summary>
        /// The line interpolation method for the error band. One of the following:
        /// - `"linear"`: piecewise linear segments, as in a polyline.
        /// - `"linear-closed"`: close the linear segments to form a polygon.
        /// - `"step"`: alternate between horizontal and vertical segments, as in a step function.
        /// - `"step-before"`: alternate between vertical and horizontal segments, as in a step
        /// function.
        /// - `"step-after"`: alternate between horizontal and vertical segments, as in a step
        /// function.
        /// - `"basis"`: a B-spline, with control point duplication on the ends.
        /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
        /// - `"basis-closed"`: a closed B-spline, as in a loop.
        /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
        /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
        /// will intersect other control points.
        /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
        /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
        /// spline.
        /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
        ///
        /// The line interpolation method to use for line and area marks. One of the following:
        /// - `"linear"`: piecewise linear segments, as in a polyline.
        /// - `"linear-closed"`: close the linear segments to form a polygon.
        /// - `"step"`: alternate between horizontal and vertical segments, as in a step function.
        /// - `"step-before"`: alternate between vertical and horizontal segments, as in a step
        /// function.
        /// - `"step-after"`: alternate between horizontal and vertical segments, as in a step
        /// function.
        /// - `"basis"`: a B-spline, with control point duplication on the ends.
        /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
        /// - `"basis-closed"`: a closed B-spline, as in a loop.
        /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
        /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
        /// will intersect other control points.
        /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
        /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
        /// spline.
        /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
        /// </summary>
        [JsonProperty("interpolate", NullValueHandling = NullValueHandling.Ignore)]
        public Interpolate? Interpolate { get; set; }

        /// <summary>
        /// The tension parameter for the interpolation type of the error band.
        ///
        /// Depending on the interpolation type, sets the tension parameter (for line and area marks).
        /// </summary>
        [JsonProperty("tension", NullValueHandling = NullValueHandling.Ignore)]
        public double? Tension { get; set; }

        /// <summary>
        /// The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
        /// </summary>
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public Align? Align { get; set; }

        /// <summary>
        /// The rotation angle of the text, in degrees.
        /// </summary>
        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Angle { get; set; }

        /// <summary>
        /// The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
        ///
        /// __Default value:__ `"middle"`
        /// </summary>
        [JsonProperty("baseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? Baseline { get; set; }

        /// <summary>
        /// Offset between bars for binned field.  Ideal value for this is either 0 (Preferred by
        /// statisticians) or 1 (Vega-Lite Default, D3 example style).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("binSpacing", NullValueHandling = NullValueHandling.Ignore)]
        public double? BinSpacing { get; set; }

        /// <summary>
        /// The radius in pixels of rounded rectangle corners.
        ///
        /// __Default value:__ `0`
        /// </summary>
        [JsonProperty("cornerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? CornerRadius { get; set; }

        /// <summary>
        /// The mouse cursor used over the mark. Any valid [CSS cursor
        /// type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
        /// </summary>
        [JsonProperty("cursor", NullValueHandling = NullValueHandling.Ignore)]
        public Cursor? Cursor { get; set; }

        /// <summary>
        /// The direction of the text. One of `"ltr"` (left-to-right) or `"rtl"` (right-to-left).
        /// This property determines on which side is truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"ltr"`
        /// </summary>
        [JsonProperty("dir", NullValueHandling = NullValueHandling.Ignore)]
        public Dir? Dir { get; set; }

        /// <summary>
        /// The horizontal offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dx", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dx { get; set; }

        /// <summary>
        /// The vertical offset, in pixels, between the text label and its anchor point. The offset
        /// is applied after rotation by the _angle_ property.
        /// </summary>
        [JsonProperty("dy", NullValueHandling = NullValueHandling.Ignore)]
        public double? Dy { get; set; }

        /// <summary>
        /// The ellipsis string for text truncated in response to the limit parameter.
        ///
        /// __Default value:__ `"…"`
        /// </summary>
        [JsonProperty("ellipsis", NullValueHandling = NullValueHandling.Ignore)]
        public string Ellipsis { get; set; }

        /// <summary>
        /// Default Fill Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public string Fill { get; set; }

        /// <summary>
        /// Whether the mark's color should be used as fill color instead of stroke color.
        ///
        /// __Default value:__ `false` for `point`, `line` and `rule`; otherwise, `true`.
        ///
        /// __Note:__ This property cannot be used in a [style
        /// config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
        /// </summary>
        [JsonProperty("filled", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Filled { get; set; }

        /// <summary>
        /// The fill opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? FillOpacity { get; set; }

        /// <summary>
        /// The typeface to set the text in (e.g., `"Helvetica Neue"`).
        /// </summary>
        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public string Font { get; set; }

        /// <summary>
        /// The font size, in pixels.
        /// </summary>
        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? FontSize { get; set; }

        /// <summary>
        /// The font style (e.g., `"italic"`).
        /// </summary>
        [JsonProperty("fontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public FontStyle? FontStyle { get; set; }

        /// <summary>
        /// The font weight.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? FontWeight { get; set; }

        /// <summary>
        /// A URL to load upon mouse click. If defined, the mark acts as a hyperlink.
        /// </summary>
        [JsonProperty("href", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Href { get; set; }

        /// <summary>
        /// The maximum length of the text mark in pixels. The text value will be automatically
        /// truncated if the rendered size exceeds the limit.
        ///
        /// __Default value:__ `0`, indicating no limit
        /// </summary>
        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public double? Limit { get; set; }

        /// <summary>
        /// A flag for overlaying line on top of area marks, or an object defining the properties of
        /// the overlayed lines.
        ///
        /// - If this value is an empty object (`{}`) or `true`, lines with default properties will
        /// be used.
        ///
        /// - If this value is `false`, no lines would be automatically added to area marks.
        ///
        /// __Default value:__ `false`.
        /// </summary>
        [JsonProperty("line", NullValueHandling = NullValueHandling.Ignore)]
        public Line? Line { get; set; }

        /// <summary>
        /// A flag for overlaying points on top of line or area marks, or an object defining the
        /// properties of the overlayed points.
        ///
        /// - If this property is `"transparent"`, transparent points will be used (for enhancing
        /// tooltips and selections).
        ///
        /// - If this property is an empty object (`{}`) or `true`, filled points with default
        /// properties will be used.
        ///
        /// - If this property is `false`, no points would be automatically added to line or area
        /// marks.
        ///
        /// __Default value:__ `false`.
        /// </summary>
        [JsonProperty("point", NullValueHandling = NullValueHandling.Ignore)]
        public PointUnion? Point { get; set; }

        /// <summary>
        /// Polar coordinate radial offset, in pixels, of the text label from the origin determined
        /// by the `x` and `y` properties.
        /// </summary>
        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        /// <summary>
        /// The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`,
        /// `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
        ///
        /// __Default value:__ `"circle"`
        /// </summary>
        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public string Shape { get; set; }

        /// <summary>
        /// Default Stroke Color.  This has higher precedence than `config.color`
        ///
        /// __Default value:__ (None)
        /// </summary>
        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public string Stroke { get; set; }

        /// <summary>
        /// The stroke cap for line ending style. One of `"butt"`, `"round"`, or `"square"`.
        ///
        /// __Default value:__ `"square"`
        /// </summary>
        [JsonProperty("strokeCap", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeCap? StrokeCap { get; set; }

        /// <summary>
        /// An array of alternating stroke, space lengths for creating dashed or dotted lines.
        /// </summary>
        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public double[] StrokeDash { get; set; }

        /// <summary>
        /// The offset (in pixels) into which to begin drawing with the stroke dash array.
        /// </summary>
        [JsonProperty("strokeDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeDashOffset { get; set; }

        /// <summary>
        /// The stroke line join method. One of `"miter"`, `"round"` or `"bevel"`.
        ///
        /// __Default value:__ `"miter"`
        /// </summary>
        [JsonProperty("strokeJoin", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeJoin? StrokeJoin { get; set; }

        /// <summary>
        /// The miter limit at which to bevel a line join.
        /// </summary>
        [JsonProperty("strokeMiterLimit", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeMiterLimit { get; set; }

        /// <summary>
        /// The stroke opacity (value between [0,1]).
        ///
        /// __Default value:__ `1`
        /// </summary>
        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeOpacity { get; set; }

        /// <summary>
        /// The stroke width, in pixels.
        /// </summary>
        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? StrokeWidth { get; set; }

        /// <summary>
        /// A string or array of strings indicating the name of custom styles to apply to the mark. A
        /// style is a named collection of mark property defaults defined within the [style
        /// configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is
        /// an array, later styles will override earlier styles. Any [mark
        /// properties](https://vega.github.io/vega-lite/docs/encoding.html#mark-prop) explicitly
        /// defined within the `encoding` will override a style default.
        ///
        /// __Default value:__ The mark's name.  For example, a bar mark will have style `"bar"` by
        /// default.
        /// __Note:__ Any specified style will augment the default style. For example, a bar mark
        /// with `"style": "foo"` will receive from `config.style.bar` and `config.style.foo` (the
        /// specified style `"foo"` has higher precedence).
        /// </summary>
        [JsonProperty("style", NullValueHandling = NullValueHandling.Ignore)]
        public Style? Style { get; set; }

        /// <summary>
        /// Placeholder text if the `text` channel is not specified
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        /// <summary>
        /// Polar coordinate angle, in radians, of the text label from the origin determined by the
        /// `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark
        /// `startAngle` and `endAngle` properties: angles are measured in radians, with `0`
        /// indicating "north".
        /// </summary>
        [JsonProperty("theta", NullValueHandling = NullValueHandling.Ignore)]
        public double? Theta { get; set; }

        /// <summary>
        /// Thickness of the tick mark.
        ///
        /// __Default value:__  `1`
        /// </summary>
        [JsonProperty("thickness", NullValueHandling = NullValueHandling.Ignore)]
        public double? Thickness { get; set; }

        /// <summary>
        /// The tooltip text string to show upon mouse hover or an object defining which fields
        /// should the tooltip be derived from.
        ///
        /// - If `tooltip` is `{"content": "encoding"}`, then all fields from `encoding` will be
        /// used.
        /// - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
        /// data point will be used.
        /// </summary>
        [JsonProperty("tooltip", NullValueHandling = NullValueHandling.Ignore)]
        public Tooltip? Tooltip { get; set; }

        /// <summary>
        /// Offset for x2-position.
        /// </summary>
        [JsonProperty("x2Offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? X2Offset { get; set; }

        /// <summary>
        /// Offset for x-position.
        /// </summary>
        [JsonProperty("xOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? XOffset { get; set; }

        /// <summary>
        /// Offset for y2-position.
        /// </summary>
        [JsonProperty("y2Offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? Y2Offset { get; set; }

        /// <summary>
        /// Offset for y-position.
        /// </summary>
        [JsonProperty("yOffset", NullValueHandling = NullValueHandling.Ignore)]
        public double? YOffset { get; set; }
    }

    /// <summary>
    /// Scale, axis, and legend resolutions for facets.
    ///
    /// Defines how scales, axes, and legends from different specs should be combined. Resolve is
    /// a mapping from `scale`, `axis`, and `legend` to a mapping from channels to resolutions.
    ///
    /// Scale, axis, and legend resolutions for layers.
    ///
    /// Scale and legend resolutions for repeated charts.
    ///
    /// Scale, axis, and legend resolutions for vertically concatenated charts.
    ///
    /// Scale, axis, and legend resolutions for horizontally concatenated charts.
    /// </summary>
    public partial class Resolve
    {
        [JsonProperty("axis", NullValueHandling = NullValueHandling.Ignore)]
        public AxisResolveMap Axis { get; set; }

        [JsonProperty("legend", NullValueHandling = NullValueHandling.Ignore)]
        public LegendResolveMap Legend { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public ScaleResolveMap Scale { get; set; }
    }

    public partial class AxisResolveMap
    {
        [JsonProperty("x", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? X { get; set; }

        [JsonProperty("y", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Y { get; set; }
    }

    public partial class LegendResolveMap
    {
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Color { get; set; }

        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Fill { get; set; }

        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? FillOpacity { get; set; }

        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Opacity { get; set; }

        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Shape { get; set; }

        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Size { get; set; }

        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Stroke { get; set; }

        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? StrokeOpacity { get; set; }

        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? StrokeWidth { get; set; }
    }

    public partial class ScaleResolveMap
    {
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Color { get; set; }

        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Fill { get; set; }

        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? FillOpacity { get; set; }

        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Opacity { get; set; }

        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Shape { get; set; }

        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Size { get; set; }

        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Stroke { get; set; }

        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? StrokeOpacity { get; set; }

        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? StrokeWidth { get; set; }

        [JsonProperty("x", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? X { get; set; }

        [JsonProperty("y", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveMode? Y { get; set; }
    }

    public partial class SelectionDef
    {
        /// <summary>
        /// Establish a two-way binding between a single selection and input elements
        /// (also known as dynamic query widgets). A binding takes the form of
        /// Vega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind)
        /// or can be a mapping between projected field/encodings and binding definitions.
        ///
        /// See the [bind transform](https://vega.github.io/vega-lite/docs/bind.html) documentation
        /// for more information.
        ///
        /// Establishes a two-way binding between the interval selection and the scales
        /// used within the same view. This allows a user to interactively pan and
        /// zoom the view.
        /// </summary>
        [JsonProperty("bind", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionDefBind? Bind { get; set; }

        /// <summary>
        /// By default, all data values are considered to lie within an empty selection.
        /// When set to `none`, empty selections contain no data values.
        /// </summary>
        [JsonProperty("empty", NullValueHandling = NullValueHandling.Ignore)]
        public Empty? Empty { get; set; }

        /// <summary>
        /// An array of encoding channels. The corresponding data field values
        /// must match for a data tuple to fall within the selection.
        /// </summary>
        [JsonProperty("encodings", NullValueHandling = NullValueHandling.Ignore)]
        public SingleDefChannel[] Encodings { get; set; }

        /// <summary>
        /// An array of field names whose values must match for a data tuple to
        /// fall within the selection.
        /// </summary>
        [JsonProperty("fields", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Fields { get; set; }

        /// <summary>
        /// When true, an invisible voronoi diagram is computed to accelerate discrete
        /// selection. The data value _nearest_ the mouse cursor is added to the selection.
        ///
        /// See the [nearest transform](https://vega.github.io/vega-lite/docs/nearest.html)
        /// documentation for more information.
        /// </summary>
        [JsonProperty("nearest", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Nearest { get; set; }

        /// <summary>
        /// A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or
        /// selector) that triggers the selection.
        /// For interval selections, the event stream must specify a [start and
        /// end](https://vega.github.io/vega/docs/event-streams/#between-filters).
        /// </summary>
        [JsonProperty("on")]
        public object On { get; set; }

        /// <summary>
        /// With layered and multi-view displays, a strategy that determines how
        /// selections' data queries are resolved when applied in a filter transform,
        /// conditional encoding rule, or scale domain.
        /// </summary>
        [JsonProperty("resolve", NullValueHandling = NullValueHandling.Ignore)]
        public SelectionResolution? Resolve { get; set; }

        [JsonProperty("type")]
        public SelectionDefType Type { get; set; }

        /// <summary>
        /// Controls whether data values should be toggled or only ever inserted into
        /// multi selections. Can be `true`, `false` (for insertion only), or a
        /// [Vega expression](https://vega.github.io/vega/docs/expressions/).
        ///
        /// __Default value:__ `true`, which corresponds to `event.shiftKey` (i.e.,
        /// data values are toggled when a user interacts with the shift-key pressed).
        ///
        /// See the [toggle transform](https://vega.github.io/vega-lite/docs/toggle.html)
        /// documentation for more information.
        /// </summary>
        [JsonProperty("toggle", NullValueHandling = NullValueHandling.Ignore)]
        public Translate? Toggle { get; set; }

        /// <summary>
        /// An interval selection also adds a rectangle mark to depict the
        /// extents of the interval. The `mark` property can be used to customize the
        /// appearance of the mark.
        /// </summary>
        [JsonProperty("mark", NullValueHandling = NullValueHandling.Ignore)]
        public BrushConfig Mark { get; set; }

        /// <summary>
        /// When truthy, allows a user to interactively move an interval selection
        /// back-and-forth. Can be `true`, `false` (to disable panning), or a
        /// [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/)
        /// which must include a start and end event to trigger continuous panning.
        ///
        /// __Default value:__ `true`, which corresponds to
        /// `[mousedown, window:mouseup] > window:mousemove!` which corresponds to
        /// clicks and dragging within an interval selection to reposition it.
        /// </summary>
        [JsonProperty("translate", NullValueHandling = NullValueHandling.Ignore)]
        public Translate? Translate { get; set; }

        /// <summary>
        /// When truthy, allows a user to interactively resize an interval selection.
        /// Can be `true`, `false` (to disable zooming), or a [Vega event stream
        /// definition](https://vega.github.io/vega/docs/event-streams/). Currently,
        /// only `wheel` events are supported.
        ///
        ///
        /// __Default value:__ `true`, which corresponds to `wheel!`.
        /// </summary>
        [JsonProperty("zoom", NullValueHandling = NullValueHandling.Ignore)]
        public Translate? Zoom { get; set; }
    }

    public partial class TitleParams
    {
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public Align? Align { get; set; }

        /// <summary>
        /// The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For
        /// example, with an orientation of top these anchor positions map to a left-, center-, or
        /// right-aligned title.
        ///
        /// __Default value:__ `"middle"` for
        /// [single](https://vega.github.io/vega-lite/docs/spec.html) and
        /// [layered](https://vega.github.io/vega-lite/docs/layer.html) views.
        /// `"start"` for other composite views.
        ///
        /// __Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only
        /// customizable only for [single](https://vega.github.io/vega-lite/docs/spec.html) and
        /// [layered](https://vega.github.io/vega-lite/docs/layer.html) views.  For other composite
        /// views, `anchor` is always `"start"`.
        /// </summary>
        [JsonProperty("anchor", NullValueHandling = NullValueHandling.Ignore)]
        public TitleAnchor? Anchor { get; set; }

        /// <summary>
        /// Angle in degrees of title text.
        /// </summary>
        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Angle { get; set; }

        /// <summary>
        /// Vertical text baseline for title text. One of `"top"`, `"middle"`, `"bottom"`, or
        /// `"alphabetic"`.
        /// </summary>
        [JsonProperty("baseline", NullValueHandling = NullValueHandling.Ignore)]
        public TextBaseline? Baseline { get; set; }

        /// <summary>
        /// Text color for title text.
        /// </summary>
        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public string Color { get; set; }

        /// <summary>
        /// Font name for title text.
        /// </summary>
        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public string Font { get; set; }

        /// <summary>
        /// Font size in pixels for title text.
        ///
        /// __Default value:__ `10`.
        /// </summary>
        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? FontSize { get; set; }

        /// <summary>
        /// Font weight for title text.
        /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
        /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
        /// </summary>
        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeight? FontWeight { get; set; }

        /// <summary>
        /// The reference frame for the anchor position, one of `"bounds"` (to anchor relative to the
        /// full bounding box) or `"group"` (to anchor relative to the group width or height).
        /// </summary>
        [JsonProperty("frame", NullValueHandling = NullValueHandling.Ignore)]
        public TitleFrame? Frame { get; set; }

        /// <summary>
        /// The maximum allowed length in pixels of legend labels.
        /// </summary>
        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public double? Limit { get; set; }

        /// <summary>
        /// The orthogonal offset in pixels by which to displace the title from its position along
        /// the edge of the chart.
        /// </summary>
        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public double? Offset { get; set; }

        /// <summary>
        /// Default title orientation (`"top"`, `"bottom"`, `"left"`, or `"right"`)
        /// </summary>
        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public TitleOrient? Orient { get; set; }

        /// <summary>
        /// A [mark style property](https://vega.github.io/vega-lite/docs/config.html#style) to apply
        /// to the title text mark.
        ///
        /// __Default value:__ `"group-title"`.
        /// </summary>
        [JsonProperty("style", NullValueHandling = NullValueHandling.Ignore)]
        public Style? Style { get; set; }

        /// <summary>
        /// The title text.
        /// </summary>
        [JsonProperty("text")]
        public string Text { get; set; }

        /// <summary>
        /// The integer z-index indicating the layering of the title group relative to other axis,
        /// mark and legend groups.
        ///
        /// __Default value:__ `0`.
        /// </summary>
        [JsonProperty("zindex", NullValueHandling = NullValueHandling.Ignore)]
        public double? Zindex { get; set; }
    }

    public partial class Transform
    {
        /// <summary>
        /// The `filter` property must be one of the predicate definitions:
        ///
        /// 1) an [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string,
        /// where `datum` can be used to refer to the current data object
        ///
        /// 2) one of the field predicates:
        /// [`equal`](https://vega.github.io/vega-lite/docs/filter.html#equal-predicate),
        /// [`lt`](https://vega.github.io/vega-lite/docs/filter.html#lt-predicate),
        /// [`lte`](https://vega.github.io/vega-lite/docs/filter.html#lte-predicate),
        /// [`gt`](https://vega.github.io/vega-lite/docs/filter.html#gt-predicate),
        /// [`gte`](https://vega.github.io/vega-lite/docs/filter.html#gte-predicate),
        /// [`range`](https://vega.github.io/vega-lite/docs/filter.html#range-predicate),
        /// [`oneOf`](https://vega.github.io/vega-lite/docs/filter.html#one-of-predicate),
        /// or [`valid`](https://vega.github.io/vega-lite/docs/filter.html#valid-predicate),
        ///
        /// 3) a [selection
        /// predicate](https://vega.github.io/vega-lite/docs/filter.html#selection-predicate)
        ///
        /// 4) a logical operand that combines (1), (2), or (3).
        /// </summary>
        [JsonProperty("filter", NullValueHandling = NullValueHandling.Ignore)]
        public LogicalOperandPredicate? Filter { get; set; }

        /// <summary>
        /// The field for storing the computed formula value.
        ///
        /// The field or fields for storing the computed formula value.
        /// If `from.fields` is specified, the transform will use the same names for `as`.
        /// If `from.fields` is not specified, `as` has to be a string and we put the whole object
        /// into the data under the specified name.
        ///
        /// The output fields at which to write the start and end bin values.
        ///
        /// The output field to write the timeUnit value.
        ///
        /// Output field names. This can be either a string or an array of strings with
        /// two elements denoting the name for the fields for stack start and stack end
        /// respectively.
        /// If a single string(eg."val") is provided, the end field will be "val_end".
        ///
        /// The output field names for extracted array values.
        ///
        /// __Default value:__ The field name of the corresponding array field
        ///
        /// The output field names for the key and value properties produced by the fold transform.
        /// __Default value:__ `["key", "value"]`
        /// </summary>
        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public Style? As { get; set; }

        /// <summary>
        /// A [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string. Use
        /// the variable `datum` to refer to the current data object.
        /// </summary>
        [JsonProperty("calculate", NullValueHandling = NullValueHandling.Ignore)]
        public string Calculate { get; set; }

        /// <summary>
        /// The default value to use if lookup fails.
        ///
        /// __Default value:__ `null`
        /// </summary>
        [JsonProperty("default", NullValueHandling = NullValueHandling.Ignore)]
        public string Default { get; set; }

        /// <summary>
        /// Secondary data reference.
        /// </summary>
        [JsonProperty("from", NullValueHandling = NullValueHandling.Ignore)]
        public LookupData From { get; set; }

        /// <summary>
        /// Key in primary data source.
        /// </summary>
        [JsonProperty("lookup", NullValueHandling = NullValueHandling.Ignore)]
        public string Lookup { get; set; }

        /// <summary>
        /// An object indicating bin properties, or simply `true` for using default bin parameters.
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public TransformBin? Bin { get; set; }

        /// <summary>
        /// The data field to bin.
        ///
        /// The data field to apply time unit.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }

        /// <summary>
        /// The timeUnit.
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// A frame specification as a two-element array used to control the window over which the
        /// specified method is applied. The array entries should either be a number indicating the
        /// offset from the current data object, or null to indicate unbounded rows preceding or
        /// following the current data object.  For example, the value `[-5, 5]` indicates that the
        /// window should include five objects preceding and five objects following the current
        /// object.
        ///
        /// __Default value:__:  `[null, null]` indicating that the window includes all objects.
        ///
        /// A frame specification as a two-element array indicating how the sliding window should
        /// proceed. The array entries should either be a number indicating the offset from the
        /// current data object, or null to indicate unbounded rows preceding or following the
        /// current data object. The default value is `[null, 0]`, indicating that the sliding window
        /// includes the current object and all preceding objects. The value `[-5, 5]` indicates that
        /// the window should include five objects preceding and five objects following the current
        /// object. Finally, `[null, null]` indicates that the window frame should always include all
        /// data objects. The only operators affected are the aggregation operations and the
        /// `first_value`, `last_value`, and `nth_value` window operations. The other window
        /// operations are not affected by this.
        ///
        /// __Default value:__:  `[null, 0]` (includes the current object and all preceding objects)
        /// </summary>
        [JsonProperty("frame", NullValueHandling = NullValueHandling.Ignore)]
        public double?[] Frame { get; set; }

        /// <summary>
        /// An optional array of fields by which to group the values.
        /// Imputation will then be performed on a per-group basis.
        ///
        /// The data fields to group by. If not specified, a single group containing all data objects
        /// will be used.
        ///
        /// The data fields for partitioning the data objects into separate windows. If unspecified,
        /// all data points will be in a single group.
        ///
        /// The data fields to group by.
        /// </summary>
        [JsonProperty("groupby", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Groupby { get; set; }

        /// <summary>
        /// The data field for which the missing values should be imputed.
        /// </summary>
        [JsonProperty("impute", NullValueHandling = NullValueHandling.Ignore)]
        public string Impute { get; set; }

        /// <summary>
        /// A key field that uniquely identifies data objects within a group.
        /// Missing key values (those occurring in the data but not in the current group) will be
        /// imputed.
        /// </summary>
        [JsonProperty("key", NullValueHandling = NullValueHandling.Ignore)]
        public string Key { get; set; }

        /// <summary>
        /// Defines the key values that should be considered for imputation.
        /// An array of key values or an object defining a [number
        /// sequence](https://vega.github.io/vega-lite/docs/impute.html#sequence-def).
        ///
        /// If provided, this will be used in addition to the key values observed within the input
        /// data.  If not provided, the values will be derived from all unique values of the `key`
        /// field. For `impute` in `encoding`, the key field is the x-field if the y-field is
        /// imputed, or vice versa.
        ///
        /// If there is no impute grouping, this property _must_ be specified.
        /// </summary>
        [JsonProperty("keyvals", NullValueHandling = NullValueHandling.Ignore)]
        public Keyvals? Keyvals { get; set; }

        /// <summary>
        /// The imputation method to use for the field value of imputed data objects.
        /// One of `value`, `mean`, `median`, `max` or `min`.
        ///
        /// __Default value:__  `"value"`
        /// </summary>
        [JsonProperty("method", NullValueHandling = NullValueHandling.Ignore)]
        public ImputeMethod? Method { get; set; }

        /// <summary>
        /// The field value to use when the imputation `method` is `"value"`.
        /// </summary>
        [JsonProperty("value")]
        public object Value { get; set; }

        /// <summary>
        /// Array of objects that define fields to aggregate.
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public AggregatedFieldDef[] Aggregate { get; set; }

        /// <summary>
        /// Indicates if the sliding window frame should ignore peer values. (Peer values are those
        /// considered identical by the sort criteria). The default is false, causing the window
        /// frame to expand to include all peer values. If set to true, the window frame will be
        /// defined by offset values only. This setting only affects those operations that depend on
        /// the window frame, namely aggregation operations and the first_value, last_value, and
        /// nth_value window operations.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("ignorePeers", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IgnorePeers { get; set; }

        /// <summary>
        /// A sort field definition for sorting data objects within a window. If two data objects are
        /// considered equal by the comparator, they are considered “peer” values of equal rank. If
        /// sort is not specified, the order is undefined: data objects are processed in the order
        /// they are observed and none are considered peers (the ignorePeers parameter is ignored and
        /// treated as if set to `true`).
        ///
        /// Field that determines the order of leaves in the stacked charts.
        /// </summary>
        [JsonProperty("sort", NullValueHandling = NullValueHandling.Ignore)]
        public SortField[] Sort { get; set; }

        /// <summary>
        /// The definition of the fields in the window, and what calculations to use.
        /// </summary>
        [JsonProperty("window", NullValueHandling = NullValueHandling.Ignore)]
        public WindowFieldDef[] Window { get; set; }

        /// <summary>
        /// Mode for stacking marks.
        /// __Default value:__ `"zero"`
        /// </summary>
        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public StackOffset? Offset { get; set; }

        /// <summary>
        /// The field which is stacked.
        /// </summary>
        [JsonProperty("stack", NullValueHandling = NullValueHandling.Ignore)]
        public string Stack { get; set; }

        /// <summary>
        /// An array of one or more data fields containing arrays to flatten.
        /// If multiple fields are specified, their array values should have a parallel structure,
        /// ideally with the same length.
        /// If the lengths of parallel arrays do not match,
        /// the longest array will be used with `null` values added for missing entries.
        /// </summary>
        [JsonProperty("flatten", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Flatten { get; set; }

        /// <summary>
        /// An array of data fields indicating the properties to fold.
        /// </summary>
        [JsonProperty("fold", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Fold { get; set; }

        /// <summary>
        /// The maximum number of data objects to include in the sample.
        ///
        /// __Default value:__ `1000`
        /// </summary>
        [JsonProperty("sample", NullValueHandling = NullValueHandling.Ignore)]
        public double? Sample { get; set; }
    }

    public partial class AggregatedFieldDef
    {
        /// <summary>
        /// The output field names to use for each aggregated field.
        /// </summary>
        [JsonProperty("as")]
        public string As { get; set; }

        /// <summary>
        /// The data field for which to compute aggregate function. This is required for all
        /// aggregation operations except `"count"`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }

        /// <summary>
        /// The aggregation operations to apply to the fields, such as sum, average or count.
        /// See the [full list of supported aggregation
        /// operations](https://vega.github.io/vega-lite/docs/aggregate.html#ops)
        /// for more information.
        /// </summary>
        [JsonProperty("op")]
        public AggregateOp Op { get; set; }
    }

    /// <summary>
    /// Secondary data reference.
    /// </summary>
    public partial class LookupData
    {
        /// <summary>
        /// Secondary data source to lookup in.
        /// </summary>
        [JsonProperty("data")]
        public Data Data { get; set; }

        /// <summary>
        /// Fields in foreign data to lookup.
        /// If not specified, the entire object is queried.
        /// </summary>
        [JsonProperty("fields", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Fields { get; set; }

        /// <summary>
        /// Key in data to lookup.
        /// </summary>
        [JsonProperty("key")]
        public string Key { get; set; }
    }

    /// <summary>
    /// A sort definition for transform
    /// </summary>
    public partial class SortField
    {
        /// <summary>
        /// The name of the field to sort.
        /// </summary>
        [JsonProperty("field")]
        public string Field { get; set; }

        /// <summary>
        /// Whether to sort the field in ascending or descending order.
        /// </summary>
        [JsonProperty("order", NullValueHandling = NullValueHandling.Ignore)]
        public VgComparatorOrder? Order { get; set; }
    }

    public partial class WindowFieldDef
    {
        /// <summary>
        /// The output name for the window operation.
        /// </summary>
        [JsonProperty("as")]
        public string As { get; set; }

        /// <summary>
        /// The data field for which to compute the aggregate or window function. This can be omitted
        /// for window functions that do not operate over a field such as `count`, `rank`,
        /// `dense_rank`.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }

        /// <summary>
        /// The window or aggregation operations to apply within a window, including `rank`, `lead`,
        /// `sum`, `average` or `count`. See the list of all supported operations
        /// [here](https://vega.github.io/vega-lite/docs/window.html#ops).
        /// </summary>
        [JsonProperty("op")]
        public Op Op { get; set; }

        /// <summary>
        /// Parameter values for the window functions. Parameter values can be omitted for operations
        /// that do not accept a parameter.
        ///
        /// See the list of all supported operations and their parameters
        /// [here](https://vega.github.io/vega-lite/docs/transforms/window.html).
        /// </summary>
        [JsonProperty("param", NullValueHandling = NullValueHandling.Ignore)]
        public double? Param { get; set; }
    }

    /// <summary>
    /// An object that describes what fields should be repeated into views that are laid out as a
    /// `row` or `column`.
    /// </summary>
    public partial class Repeat
    {
        /// <summary>
        /// Horizontal repeated views.
        /// </summary>
        [JsonProperty("column", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Column { get; set; }

        /// <summary>
        /// Vertical repeated views.
        /// </summary>
        [JsonProperty("row", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Row { get; set; }
    }

    public partial class RowColNumber
    {
        [JsonProperty("column", NullValueHandling = NullValueHandling.Ignore)]
        public double? Column { get; set; }

        [JsonProperty("row", NullValueHandling = NullValueHandling.Ignore)]
        public double? Row { get; set; }
    }

    /// <summary>
    /// The alignment to apply to symbol legends rows and columns. The supported string values
    /// are `"all"`, `"each"` (the default), and `none`. For more information, see the [grid
    /// layout documentation](https://vega.github.io/vega/docs/layout).
    ///
    /// __Default value:__ `"each"`.
    /// </summary>
    public enum VgLayoutAlign { All, Each, None };

    /// <summary>
    /// The sizing format type. One of `"pad"`, `"fit"` or `"none"`. See the [autosize
    /// type](https://vega.github.io/vega-lite/docs/size.html#autosize) documentation for
    /// descriptions of each.
    ///
    /// __Default value__: `"pad"`
    /// </summary>
    public enum AutosizeType { Fit, None, Pad };

    /// <summary>
    /// Determines how size calculation should be performed, one of `"content"` or `"padding"`.
    /// The default setting (`"content"`) interprets the width and height settings as the data
    /// rectangle (plotting) dimensions, to which padding is then added. In contrast, the
    /// `"padding"` setting includes the padding within the view size calculations, such that the
    /// width and height settings indicate the **total** intended size of the view.
    ///
    /// __Default value__: `"content"`
    /// </summary>
    public enum Contains { Content, Padding };

    /// <summary>
    /// The bounds calculation method to use for determining the extent of a sub-plot. One of
    /// `full` (the default) or `flush`.
    ///
    /// - If set to `full`, the entire calculated bounds (including axes, title, and legend) will
    /// be used.
    /// - If set to `flush`, only the specified width and height values for the sub-view will be
    /// used. The `flush` setting can be useful when attempting to place sub-plots without axes
    /// or legends into a uniform grid structure.
    ///
    /// __Default value:__ `"full"`
    /// </summary>
    public enum Bounds { Flush, Full };

    /// <summary>
    /// The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
    ///
    /// Horizontal text alignment of axis tick labels, overriding the default setting for the
    /// current axis orientation.
    ///
    /// Horizontal text alignment of axis titles.
    ///
    /// The alignment of the legend label, can be left, center, or right.
    ///
    /// Horizontal text alignment for legend titles.
    ///
    /// __Default value:__ `"left"`.
    /// </summary>
    public enum Align { Center, Left, Right };

    /// <summary>
    /// The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
    ///
    /// __Default value:__ `"middle"`
    ///
    /// Vertical text baseline of axis tick labels, overriding the default setting for the
    /// current axis orientation. Can be `"top"`, `"middle"`, `"bottom"`, or `"alphabetic"`.
    ///
    /// Vertical text baseline for axis titles.
    ///
    /// Vertical text baseline for the header title. One of `"top"`, `"bottom"`, `"middle"`.
    ///
    /// __Default value:__ `"middle"`
    ///
    /// The position of the baseline of legend label, can be `"top"`, `"middle"`, `"bottom"`, or
    /// `"alphabetic"`.
    ///
    /// __Default value:__ `"middle"`.
    ///
    /// Vertical text baseline for legend titles.
    ///
    /// __Default value:__ `"top"`.
    ///
    /// Vertical text baseline for title text. One of `"top"`, `"middle"`, `"bottom"`, or
    /// `"alphabetic"`.
    /// </summary>
    public enum TextBaseline { Alphabetic, Bottom, Middle, Top };

    /// <summary>
    /// The mouse cursor used over the mark. Any valid [CSS cursor
    /// type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
    /// </summary>
    public enum Cursor { Alias, AllScroll, Auto, Cell, ColResize, ContextMenu, Copy, Crosshair, Default, EResize, EwResize, Grab, Grabbing, Help, Move, NResize, NeResize, NeswResize, NoDrop, None, NotAllowed, NsResize, NwResize, NwseResize, Pointer, Progress, RowResize, SResize, SeResize, SwResize, Text, VerticalText, WResize, Wait, ZoomIn, ZoomOut };

    /// <summary>
    /// The direction of the text. One of `"ltr"` (left-to-right) or `"rtl"` (right-to-left).
    /// This property determines on which side is truncated in response to the limit parameter.
    ///
    /// __Default value:__ `"ltr"`
    /// </summary>
    public enum Dir { Ltr, Rtl };

    /// <summary>
    /// The font style (e.g., `"italic"`).
    /// </summary>
    public enum FontStyle { Italic, Normal };

    public enum FontWeightEnum { Bold, Bolder, Lighter, Normal };

    /// <summary>
    /// The line interpolation method to use for line and area marks. One of the following:
    /// - `"linear"`: piecewise linear segments, as in a polyline.
    /// - `"linear-closed"`: close the linear segments to form a polygon.
    /// - `"step"`: alternate between horizontal and vertical segments, as in a step function.
    /// - `"step-before"`: alternate between vertical and horizontal segments, as in a step
    /// function.
    /// - `"step-after"`: alternate between horizontal and vertical segments, as in a step
    /// function.
    /// - `"basis"`: a B-spline, with control point duplication on the ends.
    /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
    /// - `"basis-closed"`: a closed B-spline, as in a loop.
    /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
    /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
    /// will intersect other control points.
    /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
    /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
    /// spline.
    /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
    ///
    /// The line interpolation method for the error band. One of the following:
    /// - `"linear"`: piecewise linear segments, as in a polyline.
    /// - `"linear-closed"`: close the linear segments to form a polygon.
    /// - `"step"`: alternate between horizontal and vertical segments, as in a step function.
    /// - `"step-before"`: alternate between vertical and horizontal segments, as in a step
    /// function.
    /// - `"step-after"`: alternate between horizontal and vertical segments, as in a step
    /// function.
    /// - `"basis"`: a B-spline, with control point duplication on the ends.
    /// - `"basis-open"`: an open B-spline; may not intersect the start or end.
    /// - `"basis-closed"`: a closed B-spline, as in a loop.
    /// - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
    /// - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
    /// will intersect other control points.
    /// - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
    /// - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
    /// spline.
    /// - `"monotone"`: cubic interpolation that preserves monotonicity in y.
    /// </summary>
    public enum Interpolate { Basis, BasisClosed, BasisOpen, Bundle, Cardinal, CardinalClosed, CardinalOpen, Linear, LinearClosed, Monotone, Step, StepAfter, StepBefore };

    /// <summary>
    /// The orientation of a non-stacked bar, tick, area, and line charts.
    /// The value is either horizontal (default) or vertical.
    /// - For bar, rule and tick, this determines whether the size of the bar and tick
    /// should be applied to x or y dimension.
    /// - For area, this property determines the orient property of the Vega output.
    /// - For line and trail marks, this property determines the sort order of the points in the
    /// line
    /// if `config.sortLineBy` is not specified.
    /// For stacked charts, this is always determined by the orientation of the stack;
    /// therefore explicitly specified value will be ignored.
    ///
    /// Orientation of the box plot.  This is normally automatically determined based on types of
    /// fields on x and y channels. However, an explicit `orient` be specified when the
    /// orientation is ambiguous.
    ///
    /// __Default value:__ `"vertical"`.
    ///
    /// Orientation of the error bar.  This is normally automatically determined, but can be
    /// specified when the orientation is ambiguous and cannot be automatically determined.
    ///
    /// Orientation of the error band. This is normally automatically determined, but can be
    /// specified when the orientation is ambiguous and cannot be automatically determined.
    ///
    /// The default direction (`"horizontal"` or `"vertical"`) for gradient legends.
    ///
    /// __Default value:__ `"vertical"`.
    ///
    /// The default direction (`"horizontal"` or `"vertical"`) for symbol legends.
    ///
    /// __Default value:__ `"vertical"`.
    ///
    /// The direction of the legend, one of `"vertical"` or `"horizontal"`.
    ///
    /// __Default value:__ "vertical"`
    /// *
    /// </summary>
    public enum Orient { Horizontal, Vertical };

    /// <summary>
    /// The stroke cap for line ending style. One of `"butt"`, `"round"`, or `"square"`.
    ///
    /// __Default value:__ `"square"`
    /// </summary>
    public enum StrokeCap { Butt, Round, Square };

    /// <summary>
    /// The stroke line join method. One of `"miter"`, `"round"` or `"bevel"`.
    ///
    /// __Default value:__ `"miter"`
    ///
    /// The stroke line join method. One of miter (default), round or bevel.
    ///
    /// __Default value:__ 'miter'
    /// </summary>
    public enum StrokeJoin { Bevel, Miter, Round };

    public enum Content { Data, Encoding };

    public enum PointEnum { Transparent };

    public enum LabelOverlapEnum { Greedy, Parity };

    public enum ExtentEnum { MinMax };

    /// <summary>
    /// The extent of the band. Available options include:
    /// - `"ci"`: Extend the band to the confidence interval of the mean.
    /// - `"stderr"`: The size of band are set to the value of standard error, extending from the
    /// mean.
    /// - `"stdev"`: The size of band are set to the value of standard deviation, extending from
    /// the mean.
    /// - `"iqr"`: Extend the band to the q1 and q3.
    ///
    /// __Default value:__ `"stderr"`.
    ///
    /// The extent of the rule. Available options include:
    /// - `"ci"`: Extend the rule to the confidence interval of the mean.
    /// - `"stderr"`: The size of rule are set to the value of standard error, extending from the
    /// mean.
    /// - `"stdev"`: The size of rule are set to the value of standard deviation, extending from
    /// the mean.
    /// - `"iqr"`: Extend the rule to the q1 and q3.
    ///
    /// __Default value:__ `"stderr"`.
    /// </summary>
    public enum ErrorbandExtent { Ci, Iqr, Stderr, Stdev };

    /// <summary>
    /// Defines how Vega-Lite generates title for fields.  There are three possible styles:
    /// - `"verbal"` (Default) - displays function in a verbal style (e.g., "Sum of field",
    /// "Year-month of date", "field (binned)").
    /// - `"function"` - displays function using parentheses and capitalized texts (e.g.,
    /// "SUM(field)", "YEARMONTH(date)", "BIN(field)").
    /// - `"plain"` - displays only the field name without functions (e.g., "field", "date",
    /// "field").
    /// </summary>
    public enum FieldTitle { Functional, Plain, Verbal };

    public enum InvalidValues { Filter };

    /// <summary>
    /// The orientation of the legend, which determines how the legend is positioned within the
    /// scene. One of "left", "right", "top-left", "top-right", "bottom-left", "bottom-right",
    /// "none".
    ///
    /// __Default value:__ `"right"`
    /// </summary>
    public enum LegendOrient { Bottom, BottomLeft, BottomRight, Left, None, Right, Top, TopLeft, TopRight };

    /// <summary>
    /// The cartographic projection to use. This value is case-insensitive, for example
    /// `"albers"` and `"Albers"` indicate the same projection type. You can find all valid
    /// projection types [in the
    /// documentation](https://vega.github.io/vega-lite/docs/projection.html#projection-types).
    ///
    /// __Default value:__ `mercator`
    /// </summary>
    public enum VgProjectionType { Albers, AlbersUsa, AzimuthalEqualArea, AzimuthalEquidistant, ConicConformal, ConicEqualArea, ConicEquidistant, Equirectangular, Gnomonic, Mercator, Orthographic, Stereographic, TransverseMercator };

    /// <summary>
    /// Establishes a two-way binding between the interval selection and the scales
    /// used within the same view. This allows a user to interactively pan and
    /// zoom the view.
    /// </summary>
    public enum BindEnum { Scales };

    /// <summary>
    /// By default, all data values are considered to lie within an empty selection.
    /// When set to `none`, empty selections contain no data values.
    /// </summary>
    public enum Empty { All, None };

    public enum SingleDefChannel { Color, Column, Fill, FillOpacity, Href, Key, Latitude, Latitude2, Longitude, Longitude2, Opacity, Row, Shape, Size, Stroke, StrokeOpacity, StrokeWidth, Text, Tooltip, X, X2, XError, XError2, Y, Y2, YError, YError2 };

    /// <summary>
    /// With layered and multi-view displays, a strategy that determines how
    /// selections' data queries are resolved when applied in a filter transform,
    /// conditional encoding rule, or scale domain.
    /// </summary>
    public enum SelectionResolution { Global, Intersect, Union };

    public enum Input { Checkbox, Radio, Range, Select };

    /// <summary>
    /// Default stack offset for stackable mark.
    ///
    /// Mode for stacking marks.
    /// __Default value:__ `"zero"`
    /// </summary>
    public enum StackOffset { Center, Normalize, Zero };

    /// <summary>
    /// The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For
    /// example, with an orientation of top these anchor positions map to a left-, center-, or
    /// right-aligned title.
    ///
    /// The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For
    /// example, with an orientation of top these anchor positions map to a left-, center-, or
    /// right-aligned title.
    ///
    /// __Default value:__ `"middle"` for
    /// [single](https://vega.github.io/vega-lite/docs/spec.html) and
    /// [layered](https://vega.github.io/vega-lite/docs/layer.html) views.
    /// `"start"` for other composite views.
    ///
    /// __Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only
    /// customizable only for [single](https://vega.github.io/vega-lite/docs/spec.html) and
    /// [layered](https://vega.github.io/vega-lite/docs/layer.html) views.  For other composite
    /// views, `anchor` is always `"start"`.
    /// </summary>
    public enum TitleAnchor { End, Middle, Start };

    /// <summary>
    /// The reference frame for the anchor position, one of `"bounds"` (to anchor relative to the
    /// full bounding box) or `"group"` (to anchor relative to the group width or height).
    /// </summary>
    public enum TitleFrame { Bounds, Group };

    /// <summary>
    /// Default title orientation (`"top"`, `"bottom"`, `"left"`, or `"right"`)
    /// </summary>
    public enum TitleOrient { Bottom, Left, None, Right, Top };

    /// <summary>
    /// Type of input data: `"json"`, `"csv"`, `"tsv"`, `"dsv"`.
    /// The default format type is determined by the extension of the file URL.
    /// If no extension is detected, `"json"` will be used by default.
    /// </summary>
    public enum DataFormatType { Csv, Dsv, Json, Topojson, Tsv };

    /// <summary>
    /// Aggregation function for the field
    /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
    ///
    /// __Default value:__ `undefined` (None)
    ///
    /// An [aggregate operation](https://vega.github.io/vega-lite/docs/aggregate.html#ops) to
    /// perform on the field prior to sorting (e.g., `"count"`, `"mean"` and `"median"`).
    /// This property is required in cases where the sort field and the data reference field do
    /// not match.
    /// The input data objects will be aggregated, grouped by the encoded data field.
    ///
    /// For a full list of operations, please see the documentation for
    /// [aggregate](https://vega.github.io/vega-lite/docs/aggregate.html#ops).
    ///
    /// The aggregation operations to apply to the fields, such as sum, average or count.
    /// See the [full list of supported aggregation
    /// operations](https://vega.github.io/vega-lite/docs/aggregate.html#ops)
    /// for more information.
    /// </summary>
    public enum AggregateOp { Argmax, Argmin, Average, Ci0, Ci1, Count, Distinct, Max, Mean, Median, Min, Missing, Q1, Q3, Stderr, Stdev, Stdevp, Sum, Valid, Values, Variance, Variancep };

    public enum BinEnum { Binned };

    /// <summary>
    /// Time unit for the field to be filtered.
    ///
    /// Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.
    /// or [a temporal field that gets casted as
    /// ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
    ///
    /// __Default value:__ `undefined` (None)
    ///
    /// The timeUnit.
    /// </summary>
    public enum TimeUnit { Date, Day, Hours, Hoursminutes, Hoursminutesseconds, Milliseconds, Minutes, Minutesseconds, Month, Monthdate, Monthdatehours, Quarter, Quartermonth, Seconds, Secondsmilliseconds, Utcdate, Utcday, Utchours, Utchoursminutes, Utchoursminutesseconds, Utcmilliseconds, Utcminutes, Utcminutesseconds, Utcmonth, Utcmonthdate, Utcmonthdatehours, Utcquarter, Utcquartermonth, Utcseconds, Utcsecondsmilliseconds, Utcyear, Utcyearmonth, Utcyearmonthdate, Utcyearmonthdatehours, Utcyearmonthdatehoursminutes, Utcyearmonthdatehoursminutesseconds, Utcyearquarter, Utcyearquartermonth, Year, Yearmonth, Yearmonthdate, Yearmonthdatehours, Yearmonthdatehoursminutes, Yearmonthdatehoursminutesseconds, Yearquarter, Yearquartermonth };

    public enum RepeatEnum { Column, Row };

    /// <summary>
    /// The type of the legend. Use `"symbol"` to create a discrete legend and `"gradient"` for a
    /// continuous color gradient.
    ///
    /// __Default value:__ `"gradient"` for non-binned quantitative fields and temporal fields;
    /// `"symbol"` otherwise.
    /// </summary>
    public enum LegendType { Gradient, Symbol };

    public enum Domain { Unaggregated };

    public enum ScaleInterpolate { Cubehelix, CubehelixLong, Hcl, HclLong, Hsl, HslLong, Lab, Rgb };

    public enum ScaleInterpolateParamsType { Cubehelix, CubehelixLong, Rgb };

    public enum NiceTime { Day, Hour, Minute, Month, Second, Week, Year };

    /// <summary>
    /// The type of scale.  Vega-Lite supports the following categories of scale types:
    ///
    /// 1) [**Continuous Scales**](https://vega.github.io/vega-lite/docs/scale.html#continuous)
    /// -- mapping continuous domains to continuous output ranges
    /// ([`"linear"`](https://vega.github.io/vega-lite/docs/scale.html#linear),
    /// [`"pow"`](https://vega.github.io/vega-lite/docs/scale.html#pow),
    /// [`"sqrt"`](https://vega.github.io/vega-lite/docs/scale.html#sqrt),
    /// [`"log"`](https://vega.github.io/vega-lite/docs/scale.html#log),
    /// [`"time"`](https://vega.github.io/vega-lite/docs/scale.html#time),
    /// [`"utc"`](https://vega.github.io/vega-lite/docs/scale.html#utc),
    /// [`"sequential"`](https://vega.github.io/vega-lite/docs/scale.html#sequential)).
    ///
    /// 2) [**Discrete Scales**](https://vega.github.io/vega-lite/docs/scale.html#discrete) --
    /// mapping discrete domains to discrete
    /// ([`"ordinal"`](https://vega.github.io/vega-lite/docs/scale.html#ordinal)) or continuous
    /// ([`"band"`](https://vega.github.io/vega-lite/docs/scale.html#band) and
    /// [`"point"`](https://vega.github.io/vega-lite/docs/scale.html#point)) output ranges.
    ///
    /// 3) [**Discretizing
    /// Scales**](https://vega.github.io/vega-lite/docs/scale.html#discretizing) -- mapping
    /// continuous domains to discrete output ranges
    /// ([`"bin-linear"`](https://vega.github.io/vega-lite/docs/scale.html#bin-linear),
    /// [`"bin-ordinal"`](https://vega.github.io/vega-lite/docs/scale.html#bin-ordinal),
    /// [`"quantile"`](https://vega.github.io/vega-lite/docs/scale.html#quantile),
    /// [`"quantize"`](https://vega.github.io/vega-lite/docs/scale.html#quantize) and
    /// [`"threshold"`](https://vega.github.io/vega-lite/docs/scale.html#threshold).
    ///
    /// __Default value:__ please see the [scale type
    /// table](https://vega.github.io/vega-lite/docs/scale.html#type).
    /// </summary>
    public enum ScaleType { Band, BinLinear, BinOrdinal, Linear, Log, Ordinal, Point, Pow, Quantile, Quantize, Sequential, Sqrt, Threshold, Time, Utc };

    /// <summary>
    /// Whether to sort the field in ascending or descending order.
    /// </summary>
    public enum VgComparatorOrder { Ascending, Descending };

    /// <summary>
    /// The encoded field's type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or
    /// `"nominal"`).
    /// It can also be a `"geojson"` type for encoding
    /// ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
    ///
    /// Constants and utilities for data type
    /// Data type based on level of measurement
    /// </summary>
    public enum PurpleType { Geojson, Nominal, Ordinal, Quantitative, Temporal };

    /// <summary>
    /// The orientation of the axis. One of `"top"`, `"bottom"`, `"left"` or `"right"`. The
    /// orientation can be used to further specialize the axis type (e.g., a y axis oriented for
    /// the right edge of the chart).
    ///
    /// __Default value:__ `"bottom"` for x-axes and `"left"` for y-axes.
    /// </summary>
    public enum AxisOrient { Bottom, Left, Right, Top };

    /// <summary>
    /// The imputation method to use for the field value of imputed data objects.
    /// One of `value`, `mean`, `median`, `max` or `min`.
    ///
    /// __Default value:__  `"value"`
    /// </summary>
    public enum ImputeMethod { Max, Mean, Median, Min, Value };

    /// <summary>
    /// The mark type. This could a primitive mark type
    /// (one of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`,
    /// `"area"`, `"point"`, `"geoshape"`, `"rule"`, and `"text"`)
    /// or a composite mark type (`"boxplot"`, `"errorband"`, `"errorbar"`).
    ///
    /// All types of primitive marks.
    ///
    /// The mark type.
    /// One of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`,
    /// `"area"`, `"point"`, `"geoshape"`, `"rule"`, and `"text"`.
    /// </summary>
    public enum BoxPlot { Area, Bar, Boxplot, Circle, Errorband, Errorbar, Geoshape, Line, Point, Rect, Rule, Square, Text, Tick, Trail };

    /// <summary>
    /// The extent of the band. Available options include:
    /// - `"ci"`: Extend the band to the confidence interval of the mean.
    /// - `"stderr"`: The size of band are set to the value of standard error, extending from the
    /// mean.
    /// - `"stdev"`: The size of band are set to the value of standard deviation, extending from
    /// the mean.
    /// - `"iqr"`: Extend the band to the q1 and q3.
    ///
    /// __Default value:__ `"stderr"`.
    ///
    /// The extent of the rule. Available options include:
    /// - `"ci"`: Extend the rule to the confidence interval of the mean.
    /// - `"stderr"`: The size of rule are set to the value of standard error, extending from the
    /// mean.
    /// - `"stdev"`: The size of rule are set to the value of standard deviation, extending from
    /// the mean.
    /// - `"iqr"`: Extend the rule to the q1 and q3.
    ///
    /// __Default value:__ `"stderr"`.
    /// </summary>
    public enum ExtentExtent { Ci, Iqr, MinMax, Stderr, Stdev };

    public enum ResolveMode { Independent, Shared };

    public enum SelectionDefType { Interval, Multi, Single };

    /// <summary>
    /// The window or aggregation operations to apply within a window, including `rank`, `lead`,
    /// `sum`, `average` or `count`. See the list of all supported operations
    /// [here](https://vega.github.io/vega-lite/docs/window.html#ops).
    ///
    /// Aggregation function for the field
    /// (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
    ///
    /// __Default value:__ `undefined` (None)
    ///
    /// An [aggregate operation](https://vega.github.io/vega-lite/docs/aggregate.html#ops) to
    /// perform on the field prior to sorting (e.g., `"count"`, `"mean"` and `"median"`).
    /// This property is required in cases where the sort field and the data reference field do
    /// not match.
    /// The input data objects will be aggregated, grouped by the encoded data field.
    ///
    /// For a full list of operations, please see the documentation for
    /// [aggregate](https://vega.github.io/vega-lite/docs/aggregate.html#ops).
    ///
    /// The aggregation operations to apply to the fields, such as sum, average or count.
    /// See the [full list of supported aggregation
    /// operations](https://vega.github.io/vega-lite/docs/aggregate.html#ops)
    /// for more information.
    /// </summary>
    public enum Op { Argmax, Argmin, Average, Ci0, Ci1, Count, CumeDist, DenseRank, Distinct, FirstValue, Lag, LastValue, Lead, Max, Mean, Median, Min, Missing, NthValue, Ntile, PercentRank, Q1, Q3, Rank, RowNumber, Stderr, Stdev, Stdevp, Sum, Valid, Values, Variance, Variancep };

    /// <summary>
    /// The alignment to apply to grid rows and columns.
    /// The supported string values are `"all"`, `"each"`, and `"none"`.
    ///
    /// - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed
    /// one after the other.
    /// - For `"each"`, subviews will be aligned into a clean grid structure, but each row or
    /// column may be of variable size.
    /// - For `"all"`, subviews will be aligned and each row or column will be sized identically
    /// based on the maximum observed size. String values for this property will be applied to
    /// both grid rows and columns.
    ///
    /// Alternatively, an object value of the form `{"row": string, "column": string}` can be
    /// used to supply different alignments for rows and columns.
    ///
    /// __Default value:__ `"all"`.
    /// </summary>
    public partial struct AlignUnion
    {
        public VgLayoutAlign? Enum;
        public RowColVgLayoutAlign RowColVgLayoutAlign;

        public static implicit operator AlignUnion(VgLayoutAlign Enum) => new AlignUnion { Enum = Enum };
        public static implicit operator AlignUnion(RowColVgLayoutAlign RowColVgLayoutAlign) => new AlignUnion { RowColVgLayoutAlign = RowColVgLayoutAlign };
    }

    /// <summary>
    /// Sets how the visualization size should be determined. If a string, should be one of
    /// `"pad"`, `"fit"` or `"none"`.
    /// Object values can additionally specify parameters for content sizing and automatic
    /// resizing.
    /// `"fit"` is only supported for single and layered views that don't use `rangeStep`.
    ///
    /// __Default value__: `pad`
    /// </summary>
    public partial struct Autosize
    {
        public AutoSizeParams AutoSizeParams;
        public AutosizeType? Enum;

        public static implicit operator Autosize(AutoSizeParams AutoSizeParams) => new Autosize { AutoSizeParams = AutoSizeParams };
        public static implicit operator Autosize(AutosizeType Enum) => new Autosize { Enum = Enum };
    }

    public partial struct Center
    {
        public bool? Bool;
        public RowColBoolean RowColBoolean;

        public static implicit operator Center(bool Bool) => new Center { Bool = Bool };
        public static implicit operator Center(RowColBoolean RowColBoolean) => new Center { RowColBoolean = RowColBoolean };
    }

    /// <summary>
    /// The font weight.
    /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
    /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
    ///
    /// Font weight of axis tick labels.
    ///
    /// Font weight of the title.
    /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
    /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
    ///
    /// Font weight of the header title.
    /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
    /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
    ///
    /// The font weight of legend label.
    ///
    /// The font weight of the legend title.
    /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
    /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
    ///
    /// Font weight for title text.
    /// This can be either a string (e.g `"bold"`, `"normal"`) or a number (`100`, `200`, `300`,
    /// ..., `900` where `"normal"` = `400` and `"bold"` = `700`).
    /// </summary>
    public partial struct FontWeight
    {
        public double? Double;
        public FontWeightEnum? Enum;

        public static implicit operator FontWeight(double Double) => new FontWeight { Double = Double };
        public static implicit operator FontWeight(FontWeightEnum Enum) => new FontWeight { Enum = Enum };
    }

    /// <summary>
    /// A string or array of strings indicating the name of custom styles to apply to the mark. A
    /// style is a named collection of mark property defaults defined within the [style
    /// configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is
    /// an array, later styles will override earlier styles. Any [mark
    /// properties](https://vega.github.io/vega-lite/docs/encoding.html#mark-prop) explicitly
    /// defined within the `encoding` will override a style default.
    ///
    /// __Default value:__ The mark's name.  For example, a bar mark will have style `"bar"` by
    /// default.
    /// __Note:__ Any specified style will augment the default style. For example, a bar mark
    /// with `"style": "foo"` will receive from `config.style.bar` and `config.style.foo` (the
    /// specified style `"foo"` has higher precedence).
    ///
    /// A [mark style property](https://vega.github.io/vega-lite/docs/config.html#style) to apply
    /// to the title text mark.
    ///
    /// __Default value:__ `"group-title"`.
    ///
    /// The field or fields for storing the computed formula value.
    /// If `from.fields` is specified, the transform will use the same names for `as`.
    /// If `from.fields` is not specified, `as` has to be a string and we put the whole object
    /// into the data under the specified name.
    ///
    /// The output fields at which to write the start and end bin values.
    ///
    /// Output field names. This can be either a string or an array of strings with
    /// two elements denoting the name for the fields for stack start and stack end
    /// respectively.
    /// If a single string(eg."val") is provided, the end field will be "val_end".
    /// </summary>
    public partial struct Style
    {
        public string String;
        public string[] StringArray;

        public static implicit operator Style(string String) => new Style { String = String };
        public static implicit operator Style(string[] StringArray) => new Style { StringArray = StringArray };
    }

    public partial struct Tooltip
    {
        public string String;
        public TooltipContent TooltipContent;

        public static implicit operator Tooltip(string String) => new Tooltip { String = String };
        public static implicit operator Tooltip(TooltipContent TooltipContent) => new Tooltip { TooltipContent = TooltipContent };
    }

    public partial struct Line
    {
        public bool? Bool;
        public OverlayMarkDef OverlayMarkDef;

        public static implicit operator Line(bool Bool) => new Line { Bool = Bool };
        public static implicit operator Line(OverlayMarkDef OverlayMarkDef) => new Line { OverlayMarkDef = OverlayMarkDef };
    }

    public partial struct PointUnion
    {
        public bool? Bool;
        public PointEnum? Enum;
        public OverlayMarkDef OverlayMarkDef;

        public static implicit operator PointUnion(bool Bool) => new PointUnion { Bool = Bool };
        public static implicit operator PointUnion(PointEnum Enum) => new PointUnion { Enum = Enum };
        public static implicit operator PointUnion(OverlayMarkDef OverlayMarkDef) => new PointUnion { OverlayMarkDef = OverlayMarkDef };
    }

    /// <summary>
    /// Indicates if labels should be hidden if they exceed the axis range. If `false` (the
    /// default) no bounds overlap analysis is performed. If `true`, labels will be hidden if
    /// they exceed the axis range by more than 1 pixel. If this property is a number, it
    /// specifies the pixel tolerance: the maximum amount by which a label bounding box may
    /// exceed the axis range.
    ///
    /// __Default value:__ `false`.
    ///
    /// Indicates if the first and last axis labels should be aligned flush with the scale range.
    /// Flush alignment for a horizontal axis will left-align the first label and right-align the
    /// last label. For vertical axes, bottom and top text baselines are applied instead. If this
    /// property is a number, it also indicates the number of pixels by which to offset the first
    /// and last labels; for example, a value of 2 will flush-align the first and last labels and
    /// also push them 2 pixels outward from the center of the axis. The additional adjustment
    /// can sometimes help the labels better visually group with corresponding axis ticks.
    ///
    /// __Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.
    /// </summary>
    public partial struct Label
    {
        public bool? Bool;
        public double? Double;

        public static implicit operator Label(bool Bool) => new Label { Bool = Bool };
        public static implicit operator Label(double Double) => new Label { Double = Double };
    }

    /// <summary>
    /// The strategy to use for resolving overlap of axis labels. If `false` (the default), no
    /// overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing
    /// every other label is used (this works well for standard linear axes). If set to
    /// `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps
    /// with the last visible label (this often works better for log-scaled axes).
    ///
    /// __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log
    /// scales; otherwise `false`.
    ///
    /// The strategy to use for resolving overlap of labels in gradient legends. If `false`, no
    /// overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing
    /// every other label is used. If set to `"greedy"`, a linear scan of the labels is
    /// performed, removing any label that overlaps with the last visible label (this often works
    /// better for log-scaled axes).
    ///
    /// __Default value:__ `"greedy"` for `log scales otherwise `true`.
    /// *
    ///
    /// The strategy to use for resolving overlap of labels in gradient legends. If `false`, no
    /// overlap reduction is attempted. If set to `true` (default) or `"parity"`, a strategy of
    /// removing every other label is used. If set to `"greedy"`, a linear scan of the labels is
    /// performed, removing any label that overlaps with the last visible label (this often works
    /// better for log-scaled axes).
    ///
    /// __Default value:__ `true`.
    /// </summary>
    public partial struct LabelOverlap
    {
        public bool? Bool;
        public LabelOverlapEnum? Enum;

        public static implicit operator LabelOverlap(bool Bool) => new LabelOverlap { Bool = Bool };
        public static implicit operator LabelOverlap(LabelOverlapEnum Enum) => new LabelOverlap { Enum = Enum };
    }

    public partial struct Box
    {
        public bool? Bool;
        public MarkConfig MarkConfig;

        public static implicit operator Box(bool Bool) => new Box { Bool = Bool };
        public static implicit operator Box(MarkConfig MarkConfig) => new Box { MarkConfig = MarkConfig };
    }

    /// <summary>
    /// The extent of the whiskers. Available options include:
    /// - `"min-max"`: min and max are the lower and upper whiskers respectively.
    /// - A number representing multiple of the interquartile range (Q3-Q1).  This number will be
    /// multiplied by the IQR. The product will be added to the third quartile to get the upper
    /// whisker and subtracted from the first quartile to get the lower whisker.
    ///
    /// __Default value:__ `1.5`.
    /// </summary>
    public partial struct BoxplotExtent
    {
        public double? Double;
        public ExtentEnum? Enum;

        public static implicit operator BoxplotExtent(double Double) => new BoxplotExtent { Double = Double };
        public static implicit operator BoxplotExtent(ExtentEnum Enum) => new BoxplotExtent { Enum = Enum };
    }

    /// <summary>
    /// The default visualization padding, in pixels, from the edge of the visualization canvas
    /// to the data rectangle.  If a number, specifies padding for all sides.
    /// If an object, the value should have the format `{"left": 5, "top": 5, "right": 5,
    /// "bottom": 5}` to specify padding for each side of the visualization.
    ///
    /// __Default value__: `5`
    /// </summary>
    public partial struct Padding
    {
        public double? Double;
        public PaddingClass PaddingClass;

        public static implicit operator Padding(double Double) => new Padding { Double = Double };
        public static implicit operator Padding(PaddingClass PaddingClass) => new Padding { PaddingClass = PaddingClass };
    }

    public partial struct RangeElement
    {
        public double? Double;
        public string String;

        public static implicit operator RangeElement(double Double) => new RangeElement { Double = Double };
        public static implicit operator RangeElement(string String) => new RangeElement { String = String };
    }

    public partial struct RangeValue
    {
        public RangeElement[] AnythingArray;
        public VgScheme VgScheme;

        public static implicit operator RangeValue(RangeElement[] AnythingArray) => new RangeValue { AnythingArray = AnythingArray };
        public static implicit operator RangeValue(VgScheme VgScheme) => new RangeValue { VgScheme = VgScheme };
    }

    /// <summary>
    /// When truthy, allows a user to interactively move an interval selection
    /// back-and-forth. Can be `true`, `false` (to disable panning), or a
    /// [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/)
    /// which must include a start and end event to trigger continuous panning.
    ///
    /// __Default value:__ `true`, which corresponds to
    /// `[mousedown, window:mouseup] > window:mousemove!` which corresponds to
    /// clicks and dragging within an interval selection to reposition it.
    ///
    /// When truthy, allows a user to interactively resize an interval selection.
    /// Can be `true`, `false` (to disable zooming), or a [Vega event stream
    /// definition](https://vega.github.io/vega/docs/event-streams/). Currently,
    /// only `wheel` events are supported.
    ///
    ///
    /// __Default value:__ `true`, which corresponds to `wheel!`.
    ///
    /// Controls whether data values should be toggled or only ever inserted into
    /// multi selections. Can be `true`, `false` (for insertion only), or a
    /// [Vega expression](https://vega.github.io/vega/docs/expressions/).
    ///
    /// __Default value:__ `true`, which corresponds to `event.shiftKey` (i.e.,
    /// data values are toggled when a user interacts with the shift-key pressed).
    ///
    /// See the [toggle transform](https://vega.github.io/vega-lite/docs/toggle.html)
    /// documentation for more information.
    /// </summary>
    public partial struct Translate
    {
        public bool? Bool;
        public string String;

        public static implicit operator Translate(bool Bool) => new Translate { Bool = Bool };
        public static implicit operator Translate(string String) => new Translate { String = String };
    }

    public partial struct BindValue
    {
        public object[] AnythingArray;
        public Binding Binding;
        public double? Double;
        public string String;

        public static implicit operator BindValue(object[] AnythingArray) => new BindValue { AnythingArray = AnythingArray };
        public static implicit operator BindValue(Binding Binding) => new BindValue { Binding = Binding };
        public static implicit operator BindValue(double Double) => new BindValue { Double = Double };
        public static implicit operator BindValue(string String) => new BindValue { String = String };
    }

    public partial struct InlineDatasetElement
    {
        public Dictionary<string, object> AnythingMap;
        public bool? Bool;
        public double? Double;
        public string String;

        public static implicit operator InlineDatasetElement(Dictionary<string, object> AnythingMap) => new InlineDatasetElement { AnythingMap = AnythingMap };
        public static implicit operator InlineDatasetElement(bool Bool) => new InlineDatasetElement { Bool = Bool };
        public static implicit operator InlineDatasetElement(double Double) => new InlineDatasetElement { Double = Double };
        public static implicit operator InlineDatasetElement(string String) => new InlineDatasetElement { String = String };
    }

    /// <summary>
    /// The full data set, included inline. This can be an array of objects or primitive values,
    /// an object, or a string.
    /// Arrays of primitive values are ingested as objects with a `data` property. Strings are
    /// parsed according to the specified format type.
    /// </summary>
    public partial struct InlineDataset
    {
        public InlineDatasetElement[] AnythingArray;
        public Dictionary<string, object> AnythingMap;
        public string String;

        public static implicit operator InlineDataset(InlineDatasetElement[] AnythingArray) => new InlineDataset { AnythingArray = AnythingArray };
        public static implicit operator InlineDataset(Dictionary<string, object> AnythingMap) => new InlineDataset { AnythingMap = AnythingMap };
        public static implicit operator InlineDataset(string String) => new InlineDataset { String = String };
    }

    public partial struct PurpleBin
    {
        public BinParams BinParams;
        public bool? Bool;
        public BinEnum? Enum;

        public static implicit operator PurpleBin(BinParams BinParams) => new PurpleBin { BinParams = BinParams };
        public static implicit operator PurpleBin(bool Bool) => new PurpleBin { Bool = Bool };
        public static implicit operator PurpleBin(BinEnum Enum) => new PurpleBin { Enum = Enum };
    }

    /// <summary>
    /// Filter using a selection name.
    ///
    /// A [selection name](https://vega.github.io/vega-lite/docs/selection.html), or a series of
    /// [composed selections](https://vega.github.io/vega-lite/docs/selection.html#compose).
    /// </summary>
    public partial struct SelectionOperand
    {
        public Selection Selection;
        public string String;

        public static implicit operator SelectionOperand(Selection Selection) => new SelectionOperand { Selection = Selection };
        public static implicit operator SelectionOperand(string String) => new SelectionOperand { String = String };
    }

    /// <summary>
    /// The `filter` property must be one of the predicate definitions:
    ///
    /// 1) an [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string,
    /// where `datum` can be used to refer to the current data object
    ///
    /// 2) one of the field predicates:
    /// [`equal`](https://vega.github.io/vega-lite/docs/filter.html#equal-predicate),
    /// [`lt`](https://vega.github.io/vega-lite/docs/filter.html#lt-predicate),
    /// [`lte`](https://vega.github.io/vega-lite/docs/filter.html#lte-predicate),
    /// [`gt`](https://vega.github.io/vega-lite/docs/filter.html#gt-predicate),
    /// [`gte`](https://vega.github.io/vega-lite/docs/filter.html#gte-predicate),
    /// [`range`](https://vega.github.io/vega-lite/docs/filter.html#range-predicate),
    /// [`oneOf`](https://vega.github.io/vega-lite/docs/filter.html#one-of-predicate),
    /// or [`valid`](https://vega.github.io/vega-lite/docs/filter.html#valid-predicate),
    ///
    /// 3) a [selection
    /// predicate](https://vega.github.io/vega-lite/docs/filter.html#selection-predicate)
    ///
    /// 4) a logical operand that combines (1), (2), or (3).
    /// </summary>
    public partial struct LogicalOperandPredicate
    {
        public Predicate Predicate;
        public string String;

        public static implicit operator LogicalOperandPredicate(Predicate Predicate) => new LogicalOperandPredicate { Predicate = Predicate };
        public static implicit operator LogicalOperandPredicate(string String) => new LogicalOperandPredicate { String = String };
    }

    /// <summary>
    /// Value representing the day of a week.  This can be one of: (1) integer value -- `1`
    /// represents Monday; (2) case-insensitive day name (e.g., `"Monday"`);  (3)
    /// case-insensitive, 3-character short day name (e.g., `"Mon"`).   <br/> **Warning:** A
    /// DateTime definition object with `day`** should not be combined with `year`, `quarter`,
    /// `month`, or `date`.
    /// </summary>
    public partial struct Day
    {
        public double? Double;
        public string String;

        public static implicit operator Day(double Double) => new Day { Double = Double };
        public static implicit operator Day(string String) => new Day { String = String };
    }

    /// <summary>
    /// One of: (1) integer value representing the month from `1`-`12`. `1` represents January;
    /// (2) case-insensitive month name (e.g., `"January"`);  (3) case-insensitive, 3-character
    /// short month name (e.g., `"Jan"`).
    /// </summary>
    public partial struct Month
    {
        public double? Double;
        public string String;

        public static implicit operator Month(double Double) => new Month { Double = Double };
        public static implicit operator Month(string String) => new Month { String = String };
    }

    public partial struct Equal
    {
        public bool? Bool;
        public DateTime DateTime;
        public double? Double;
        public string String;

        public static implicit operator Equal(bool Bool) => new Equal { Bool = Bool };
        public static implicit operator Equal(DateTime DateTime) => new Equal { DateTime = DateTime };
        public static implicit operator Equal(double Double) => new Equal { Double = Double };
        public static implicit operator Equal(string String) => new Equal { String = String };
    }

    public partial struct Lt
    {
        public DateTime DateTime;
        public double? Double;
        public string String;

        public static implicit operator Lt(DateTime DateTime) => new Lt { DateTime = DateTime };
        public static implicit operator Lt(double Double) => new Lt { Double = Double };
        public static implicit operator Lt(string String) => new Lt { String = String };
    }

    public partial struct PurpleRange
    {
        public DateTime DateTime;
        public double? Double;

        public static implicit operator PurpleRange(DateTime DateTime) => new PurpleRange { DateTime = DateTime };
        public static implicit operator PurpleRange(double Double) => new PurpleRange { Double = Double };
        public bool IsNull => DateTime == null && Double == null;
    }

    /// <summary>
    /// A constant value in visual domain (e.g., `"red"` / "#0099ff" for color, values between
    /// `0` to `1` for opacity).
    ///
    /// A constant value in visual domain.
    /// </summary>
    public partial struct Value
    {
        public bool? Bool;
        public double? Double;
        public string String;

        public static implicit operator Value(bool Bool) => new Value { Bool = Bool };
        public static implicit operator Value(double Double) => new Value { Double = Double };
        public static implicit operator Value(string String) => new Value { String = String };
        public bool IsNull => Bool == null && Double == null && String == null;
    }

    public partial struct Field
    {
        public RepeatRef RepeatRef;
        public string String;

        public static implicit operator Field(RepeatRef RepeatRef) => new Field { RepeatRef = RepeatRef };
        public static implicit operator Field(string String) => new Field { String = String };
    }

    /// <summary>
    /// Customized domain values.
    ///
    /// For _quantitative_ fields, `domain` can take the form of a two-element array with minimum
    /// and maximum values.  [Piecewise
    /// scales](https://vega.github.io/vega-lite/docs/scale.html#piecewise) can be created by
    /// providing a `domain` with more than two entries.
    /// If the input field is aggregated, `domain` can also be a string value `"unaggregated"`,
    /// indicating that the domain should include the raw data values prior to the aggregation.
    ///
    /// For _temporal_ fields, `domain` can be a two-element array minimum and maximum values, in
    /// the form of either timestamps or the [DateTime definition
    /// objects](https://vega.github.io/vega-lite/docs/types.html#datetime).
    ///
    /// For _ordinal_ and _nominal_ fields, `domain` can be an array that lists valid input
    /// values.
    ///
    /// The `selection` property can be used to [interactively
    /// determine](https://vega.github.io/vega-lite/docs/selection.html#scale-domains) the scale
    /// domain.
    /// </summary>
    public partial struct DomainUnion
    {
        public Equal[] AnythingArray;
        public DomainClass DomainClass;
        public Domain? Enum;

        public static implicit operator DomainUnion(Equal[] AnythingArray) => new DomainUnion { AnythingArray = AnythingArray };
        public static implicit operator DomainUnion(DomainClass DomainClass) => new DomainUnion { DomainClass = DomainClass };
        public static implicit operator DomainUnion(Domain Enum) => new DomainUnion { Enum = Enum };
    }

    /// <summary>
    /// The interpolation method for range values. By default, a general interpolator for
    /// numbers, dates, strings and colors (in HCL space) is used. For color ranges, this
    /// property allows interpolation in alternative color spaces. Legal values include `rgb`,
    /// `hsl`, `hsl-long`, `lab`, `hcl`, `hcl-long`, `cubehelix` and `cubehelix-long` ('-long'
    /// variants use longer paths in polar coordinate spaces). If object-valued, this property
    /// accepts an object with a string-valued _type_ property and an optional numeric _gamma_
    /// property applicable to rgb and cubehelix interpolators. For more, see the [d3-interpolate
    /// documentation](https://github.com/d3/d3-interpolate).
    ///
    /// * __Default value:__ `hcl`
    ///
    /// __Note:__ Sequential scales do not support `interpolate` as they have a fixed
    /// interpolator.  Since Vega-Lite uses sequential scales for quantitative fields by default,
    /// you have to set the scale `type` to other quantitative scale type such as `"linear"` to
    /// customize `interpolate`.
    /// </summary>
    public partial struct InterpolateUnion
    {
        public ScaleInterpolate? Enum;
        public ScaleInterpolateParams ScaleInterpolateParams;

        public static implicit operator InterpolateUnion(ScaleInterpolate Enum) => new InterpolateUnion { Enum = Enum };
        public static implicit operator InterpolateUnion(ScaleInterpolateParams ScaleInterpolateParams) => new InterpolateUnion { ScaleInterpolateParams = ScaleInterpolateParams };
    }

    /// <summary>
    /// Extending the domain so that it starts and ends on nice round values. This method
    /// typically modifies the scale’s domain, and may only extend the bounds to the nearest
    /// round value. Nicing is useful if the domain is computed from data and may be irregular.
    /// For example, for a domain of _[0.201479…, 0.996679…]_, a nice domain might be _[0.2,
    /// 1.0]_.
    ///
    /// For quantitative scales such as linear, `nice` can be either a boolean flag or a number.
    /// If `nice` is a number, it will represent a desired tick count. This allows greater
    /// control over the step size used to extend the bounds, guaranteeing that the returned
    /// ticks will exactly cover the domain.
    ///
    /// For temporal fields with time and utc scales, the `nice` value can be a string indicating
    /// the desired time interval. Legal values are `"millisecond"`, `"second"`, `"minute"`,
    /// `"hour"`, `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, `time` and `utc`
    /// scales can accept an object-valued interval specifier of the form `{"interval": "month",
    /// "step": 3}`, which includes a desired number of interval steps. Here, the domain would
    /// snap to quarter (Jan, Apr, Jul, Oct) boundaries.
    ///
    /// __Default value:__ `true` for unbinned _quantitative_ fields; `false` otherwise.
    /// </summary>
    public partial struct NiceUnion
    {
        public bool? Bool;
        public double? Double;
        public NiceTime? Enum;
        public NiceClass NiceClass;

        public static implicit operator NiceUnion(bool Bool) => new NiceUnion { Bool = Bool };
        public static implicit operator NiceUnion(double Double) => new NiceUnion { Double = Double };
        public static implicit operator NiceUnion(NiceTime Enum) => new NiceUnion { Enum = Enum };
        public static implicit operator NiceUnion(NiceClass NiceClass) => new NiceUnion { NiceClass = NiceClass };
    }

    /// <summary>
    /// The range of the scale. One of:
    ///
    /// - A string indicating a [pre-defined named scale
    /// range](https://vega.github.io/vega-lite/docs/scale.html#range-config) (e.g., example,
    /// `"symbol"`, or `"diverging"`).
    ///
    /// - For [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous),
    /// two-element array indicating  minimum and maximum values, or an array with more than two
    /// entries for specifying a [piecewise
    /// scale](https://vega.github.io/vega-lite/docs/scale.html#piecewise).
    ///
    /// - For [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) and
    /// [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales, an
    /// array of desired output values.
    ///
    /// __Notes:__
    ///
    /// 1) For [sequential](https://vega.github.io/vega-lite/docs/scale.html#sequential),
    /// [ordinal](https://vega.github.io/vega-lite/docs/scale.html#ordinal), and discretizing
    /// color scales, you can also specify a color
    /// [`scheme`](https://vega.github.io/vega-lite/docs/scale.html#scheme) instead of `range`.
    ///
    /// 2) Any directly specified `range` for `x` and `y` channels will be ignored. Range can be
    /// customized via the view's corresponding
    /// [size](https://vega.github.io/vega-lite/docs/size.html) (`width` and `height`) or via
    /// [range steps and paddings properties](#range-step) for [band](#band) and [point](#point)
    /// scales.
    /// </summary>
    public partial struct ScaleRange
    {
        public RangeElement[] AnythingArray;
        public string String;

        public static implicit operator ScaleRange(RangeElement[] AnythingArray) => new ScaleRange { AnythingArray = AnythingArray };
        public static implicit operator ScaleRange(string String) => new ScaleRange { String = String };
    }

    /// <summary>
    /// A string indicating a color
    /// [scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme) name (e.g.,
    /// `"category10"` or `"viridis"`) or a [scheme parameter
    /// object](https://vega.github.io/vega-lite/docs/scale.html#scheme-params).
    ///
    /// Discrete color schemes may be used with
    /// [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) or
    /// [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales.
    /// Continuous color schemes are intended for use with
    /// [sequential](https://vega.github.io/vega-lite/docs/scales.html#sequential) scales.
    ///
    /// For the full list of supported schemes, please refer to the [Vega
    /// Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.
    /// </summary>
    public partial struct Scheme
    {
        public SchemeParams SchemeParams;
        public string String;

        public static implicit operator Scheme(SchemeParams SchemeParams) => new Scheme { SchemeParams = SchemeParams };
        public static implicit operator Scheme(string String) => new Scheme { String = String };
    }

    /// <summary>
    /// Sort order for the encoded field.
    ///
    /// For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
    /// `"descending"`.
    ///
    /// For discrete fields, `sort` can be one of the following:
    /// - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
    /// Javascript.
    /// - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
    /// for sorting by another field.
    /// - [An array specifying the field values in preferred
    /// order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
    /// sort order will obey the values in the array, followed by any unspecified values in their
    /// original order.  For discrete time field, values in the sort array can be [date-time
    /// definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
    /// the values can be the month or day names (case insensitive) or their 3-letter initials
    /// (e.g., `"Mon"`, `"Tue"`).
    /// - `null` indicating no sort.
    ///
    /// __Default value:__ `"ascending"`
    ///
    /// __Note:__ `null` is not supported for `row` and `column`.
    /// </summary>
    public partial struct Sort
    {
        public Equal[] AnythingArray;
        public EncodingSortField EncodingSortField;
        public VgComparatorOrder? Enum;

        public static implicit operator Sort(Equal[] AnythingArray) => new Sort { AnythingArray = AnythingArray };
        public static implicit operator Sort(EncodingSortField EncodingSortField) => new Sort { EncodingSortField = EncodingSortField };
        public static implicit operator Sort(VgComparatorOrder Enum) => new Sort { Enum = Enum };
        public bool IsNull => AnythingArray == null && EncodingSortField == null && Enum == null;
    }

    public partial struct ColorCondition
    {
        public ConditionalPredicateMarkPropFieldDefClass ConditionalPredicateMarkPropFieldDefClass;
        public ConditionalValueDef[] ConditionalValueDefArray;

        public static implicit operator ColorCondition(ConditionalPredicateMarkPropFieldDefClass ConditionalPredicateMarkPropFieldDefClass) => new ColorCondition { ConditionalPredicateMarkPropFieldDefClass = ConditionalPredicateMarkPropFieldDefClass };
        public static implicit operator ColorCondition(ConditionalValueDef[] ConditionalValueDefArray) => new ColorCondition { ConditionalValueDefArray = ConditionalValueDefArray };
    }

    public partial struct Detail
    {
        public FieldDef FieldDef;
        public FieldDef[] FieldDefArray;

        public static implicit operator Detail(FieldDef FieldDef) => new Detail { FieldDef = FieldDef };
        public static implicit operator Detail(FieldDef[] FieldDefArray) => new Detail { FieldDefArray = FieldDefArray };
    }

    public partial struct HrefCondition
    {
        public ConditionalPredicateFieldDefClass ConditionalPredicateFieldDefClass;
        public ConditionalValueDef[] ConditionalValueDefArray;

        public static implicit operator HrefCondition(ConditionalPredicateFieldDefClass ConditionalPredicateFieldDefClass) => new HrefCondition { ConditionalPredicateFieldDefClass = ConditionalPredicateFieldDefClass };
        public static implicit operator HrefCondition(ConditionalValueDef[] ConditionalValueDefArray) => new HrefCondition { ConditionalValueDefArray = ConditionalValueDefArray };
    }

    public partial struct Order
    {
        public OrderFieldDef[] OrderFieldDefArray;
        public OrderFieldDefClass OrderFieldDefClass;

        public static implicit operator Order(OrderFieldDef[] OrderFieldDefArray) => new Order { OrderFieldDefArray = OrderFieldDefArray };
        public static implicit operator Order(OrderFieldDefClass OrderFieldDefClass) => new Order { OrderFieldDefClass = OrderFieldDefClass };
    }

    public partial struct TextCondition
    {
        public ConditionalPredicateTextFieldDefClass ConditionalPredicateTextFieldDefClass;
        public ConditionalValueDef[] ConditionalValueDefArray;

        public static implicit operator TextCondition(ConditionalPredicateTextFieldDefClass ConditionalPredicateTextFieldDefClass) => new TextCondition { ConditionalPredicateTextFieldDefClass = ConditionalPredicateTextFieldDefClass };
        public static implicit operator TextCondition(ConditionalValueDef[] ConditionalValueDefArray) => new TextCondition { ConditionalValueDefArray = ConditionalValueDefArray };
    }

    public partial struct TooltipUnion
    {
        public TextFieldDef[] TextFieldDefArray;
        public TextFieldDefWithCondition TextFieldDefWithCondition;

        public static implicit operator TooltipUnion(TextFieldDef[] TextFieldDefArray) => new TooltipUnion { TextFieldDefArray = TextFieldDefArray };
        public static implicit operator TooltipUnion(TextFieldDefWithCondition TextFieldDefWithCondition) => new TooltipUnion { TextFieldDefWithCondition = TextFieldDefWithCondition };
    }

    public partial struct Keyvals
    {
        public object[] AnythingArray;
        public ImputeSequence ImputeSequence;

        public static implicit operator Keyvals(object[] AnythingArray) => new Keyvals { AnythingArray = AnythingArray };
        public static implicit operator Keyvals(ImputeSequence ImputeSequence) => new Keyvals { ImputeSequence = ImputeSequence };
    }

    public partial struct BoxPlotDefExtent
    {
        public double? Double;
        public ExtentExtent? Enum;

        public static implicit operator BoxPlotDefExtent(double Double) => new BoxPlotDefExtent { Double = Double };
        public static implicit operator BoxPlotDefExtent(ExtentExtent Enum) => new BoxPlotDefExtent { Enum = Enum };
    }

    /// <summary>
    /// A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`,
    /// `"line"`,
    /// `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark definition
    /// object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
    /// </summary>
    public partial struct AnyMark
    {
        public BoxPlotDefClass BoxPlotDefClass;
        public BoxPlot? Enum;

        public static implicit operator AnyMark(BoxPlotDefClass BoxPlotDefClass) => new AnyMark { BoxPlotDefClass = BoxPlotDefClass };
        public static implicit operator AnyMark(BoxPlot Enum) => new AnyMark { Enum = Enum };
    }

    public partial struct SelectionDefBind
    {
        public Dictionary<string, BindValue> AnythingMap;
        public BindEnum? Enum;

        public static implicit operator SelectionDefBind(Dictionary<string, BindValue> AnythingMap) => new SelectionDefBind { AnythingMap = AnythingMap };
        public static implicit operator SelectionDefBind(BindEnum Enum) => new SelectionDefBind { Enum = Enum };
    }

    public partial struct Title
    {
        public string String;
        public TitleParams TitleParams;

        public static implicit operator Title(string String) => new Title { String = String };
        public static implicit operator Title(TitleParams TitleParams) => new Title { TitleParams = TitleParams };
    }

    /// <summary>
    /// An object indicating bin properties, or simply `true` for using default bin parameters.
    /// </summary>
    public partial struct TransformBin
    {
        public BinParams BinParams;
        public bool? Bool;

        public static implicit operator TransformBin(BinParams BinParams) => new TransformBin { BinParams = BinParams };
        public static implicit operator TransformBin(bool Bool) => new TransformBin { Bool = Bool };
    }

    public partial struct Spacing
    {
        public double? Double;
        public RowColNumber RowColNumber;

        public static implicit operator Spacing(double Double) => new Spacing { Double = Double };
        public static implicit operator Spacing(RowColNumber RowColNumber) => new Spacing { RowColNumber = RowColNumber };
    }

    public partial class Spec
    {
        public static Spec FromJson(string json) => JsonConvert.DeserializeObject<Spec>(json, QuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Spec self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                AlignUnionConverter.Singleton,
                VgLayoutAlignConverter.Singleton,
                AutosizeConverter.Singleton,
                ContainsConverter.Singleton,
                AutosizeTypeConverter.Singleton,
                BoundsConverter.Singleton,
                CenterConverter.Singleton,
                AlignConverter.Singleton,
                TextBaselineConverter.Singleton,
                CursorConverter.Singleton,
                DirConverter.Singleton,
                FontStyleConverter.Singleton,
                FontWeightConverter.Singleton,
                FontWeightEnumConverter.Singleton,
                InterpolateConverter.Singleton,
                LineConverter.Singleton,
                OrientConverter.Singleton,
                StrokeCapConverter.Singleton,
                StrokeJoinConverter.Singleton,
                StyleConverter.Singleton,
                TooltipConverter.Singleton,
                ContentConverter.Singleton,
                PointUnionConverter.Singleton,
                PointEnumConverter.Singleton,
                LabelConverter.Singleton,
                LabelOverlapConverter.Singleton,
                LabelOverlapEnumConverter.Singleton,
                BoxConverter.Singleton,
                BoxplotExtentConverter.Singleton,
                ExtentEnumConverter.Singleton,
                ErrorbandExtentConverter.Singleton,
                FieldTitleConverter.Singleton,
                InvalidValuesConverter.Singleton,
                LegendOrientConverter.Singleton,
                PaddingConverter.Singleton,
                VgProjectionTypeConverter.Singleton,
                RangeValueConverter.Singleton,
                RangeElementConverter.Singleton,
                BindEnumConverter.Singleton,
                EmptyConverter.Singleton,
                SingleDefChannelConverter.Singleton,
                SelectionResolutionConverter.Singleton,
                TranslateConverter.Singleton,
                BindValueConverter.Singleton,
                InputConverter.Singleton,
                StackOffsetConverter.Singleton,
                TitleAnchorConverter.Singleton,
                TitleFrameConverter.Singleton,
                TitleOrientConverter.Singleton,
                DataFormatTypeConverter.Singleton,
                InlineDatasetConverter.Singleton,
                InlineDatasetElementConverter.Singleton,
                AggregateOpConverter.Singleton,
                PurpleBinConverter.Singleton,
                BinEnumConverter.Singleton,
                ColorConditionConverter.Singleton,
                SelectionOperandConverter.Singleton,
                LogicalOperandPredicateConverter.Singleton,
                EqualConverter.Singleton,
                DayConverter.Singleton,
                MonthConverter.Singleton,
                LtConverter.Singleton,
                PurpleRangeConverter.Singleton,
                TimeUnitConverter.Singleton,
                ValueConverter.Singleton,
                FieldConverter.Singleton,
                RepeatEnumConverter.Singleton,
                LegendTypeConverter.Singleton,
                DomainUnionConverter.Singleton,
                DomainConverter.Singleton,
                InterpolateUnionConverter.Singleton,
                ScaleInterpolateParamsTypeConverter.Singleton,
                ScaleInterpolateConverter.Singleton,
                NiceUnionConverter.Singleton,
                NiceTimeConverter.Singleton,
                ScaleRangeConverter.Singleton,
                SchemeConverter.Singleton,
                ScaleTypeConverter.Singleton,
                SortConverter.Singleton,
                VgComparatorOrderConverter.Singleton,
                PurpleTypeConverter.Singleton,
                DetailConverter.Singleton,
                HrefConditionConverter.Singleton,
                OrderConverter.Singleton,
                TextConditionConverter.Singleton,
                TooltipUnionConverter.Singleton,
                AxisOrientConverter.Singleton,
                KeyvalsConverter.Singleton,
                ImputeMethodConverter.Singleton,
                AnyMarkConverter.Singleton,
                BoxPlotDefExtentConverter.Singleton,
                ExtentExtentConverter.Singleton,
                BoxPlotConverter.Singleton,
                ResolveModeConverter.Singleton,
                SelectionDefBindConverter.Singleton,
                SelectionDefTypeConverter.Singleton,
                TitleConverter.Singleton,
                TransformBinConverter.Singleton,
                OpConverter.Singleton,
                SpacingConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class AlignUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AlignUnion) || t == typeof(AlignUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "all":
                            return new AlignUnion { Enum = VgLayoutAlign.All };
                        case "each":
                            return new AlignUnion { Enum = VgLayoutAlign.Each };
                        case "none":
                            return new AlignUnion { Enum = VgLayoutAlign.None };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<RowColVgLayoutAlign>(reader);
                    return new AlignUnion { RowColVgLayoutAlign = objectValue };
            }
            throw new Exception("Cannot unmarshal type AlignUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AlignUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case VgLayoutAlign.All:
                        serializer.Serialize(writer, "all");
                        return;
                    case VgLayoutAlign.Each:
                        serializer.Serialize(writer, "each");
                        return;
                    case VgLayoutAlign.None:
                        serializer.Serialize(writer, "none");
                        return;
                }
            }
            if (value.RowColVgLayoutAlign != null)
            {
                serializer.Serialize(writer, value.RowColVgLayoutAlign);
                return;
            }
            throw new Exception("Cannot marshal type AlignUnion");
        }

        public static readonly AlignUnionConverter Singleton = new AlignUnionConverter();
    }

    internal class VgLayoutAlignConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(VgLayoutAlign) || t == typeof(VgLayoutAlign?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "all":
                    return VgLayoutAlign.All;
                case "each":
                    return VgLayoutAlign.Each;
                case "none":
                    return VgLayoutAlign.None;
            }
            throw new Exception("Cannot unmarshal type VgLayoutAlign");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (VgLayoutAlign)untypedValue;
            switch (value)
            {
                case VgLayoutAlign.All:
                    serializer.Serialize(writer, "all");
                    return;
                case VgLayoutAlign.Each:
                    serializer.Serialize(writer, "each");
                    return;
                case VgLayoutAlign.None:
                    serializer.Serialize(writer, "none");
                    return;
            }
            throw new Exception("Cannot marshal type VgLayoutAlign");
        }

        public static readonly VgLayoutAlignConverter Singleton = new VgLayoutAlignConverter();
    }

    internal class AutosizeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Autosize) || t == typeof(Autosize?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "fit":
                            return new Autosize { Enum = AutosizeType.Fit };
                        case "none":
                            return new Autosize { Enum = AutosizeType.None };
                        case "pad":
                            return new Autosize { Enum = AutosizeType.Pad };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<AutoSizeParams>(reader);
                    return new Autosize { AutoSizeParams = objectValue };
            }
            throw new Exception("Cannot unmarshal type Autosize");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Autosize)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case AutosizeType.Fit:
                        serializer.Serialize(writer, "fit");
                        return;
                    case AutosizeType.None:
                        serializer.Serialize(writer, "none");
                        return;
                    case AutosizeType.Pad:
                        serializer.Serialize(writer, "pad");
                        return;
                }
            }
            if (value.AutoSizeParams != null)
            {
                serializer.Serialize(writer, value.AutoSizeParams);
                return;
            }
            throw new Exception("Cannot marshal type Autosize");
        }

        public static readonly AutosizeConverter Singleton = new AutosizeConverter();
    }

    internal class ContainsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Contains) || t == typeof(Contains?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "content":
                    return Contains.Content;
                case "padding":
                    return Contains.Padding;
            }
            throw new Exception("Cannot unmarshal type Contains");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Contains)untypedValue;
            switch (value)
            {
                case Contains.Content:
                    serializer.Serialize(writer, "content");
                    return;
                case Contains.Padding:
                    serializer.Serialize(writer, "padding");
                    return;
            }
            throw new Exception("Cannot marshal type Contains");
        }

        public static readonly ContainsConverter Singleton = new ContainsConverter();
    }

    internal class AutosizeTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AutosizeType) || t == typeof(AutosizeType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "fit":
                    return AutosizeType.Fit;
                case "none":
                    return AutosizeType.None;
                case "pad":
                    return AutosizeType.Pad;
            }
            throw new Exception("Cannot unmarshal type AutosizeType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AutosizeType)untypedValue;
            switch (value)
            {
                case AutosizeType.Fit:
                    serializer.Serialize(writer, "fit");
                    return;
                case AutosizeType.None:
                    serializer.Serialize(writer, "none");
                    return;
                case AutosizeType.Pad:
                    serializer.Serialize(writer, "pad");
                    return;
            }
            throw new Exception("Cannot marshal type AutosizeType");
        }

        public static readonly AutosizeTypeConverter Singleton = new AutosizeTypeConverter();
    }

    internal class BoundsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Bounds) || t == typeof(Bounds?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "flush":
                    return Bounds.Flush;
                case "full":
                    return Bounds.Full;
            }
            throw new Exception("Cannot unmarshal type Bounds");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Bounds)untypedValue;
            switch (value)
            {
                case Bounds.Flush:
                    serializer.Serialize(writer, "flush");
                    return;
                case Bounds.Full:
                    serializer.Serialize(writer, "full");
                    return;
            }
            throw new Exception("Cannot marshal type Bounds");
        }

        public static readonly BoundsConverter Singleton = new BoundsConverter();
    }

    internal class CenterConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Center) || t == typeof(Center?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Center { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<RowColBoolean>(reader);
                    return new Center { RowColBoolean = objectValue };
            }
            throw new Exception("Cannot unmarshal type Center");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Center)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.RowColBoolean != null)
            {
                serializer.Serialize(writer, value.RowColBoolean);
                return;
            }
            throw new Exception("Cannot marshal type Center");
        }

        public static readonly CenterConverter Singleton = new CenterConverter();
    }

    internal class AlignConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Align) || t == typeof(Align?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "center":
                    return Align.Center;
                case "left":
                    return Align.Left;
                case "right":
                    return Align.Right;
            }
            throw new Exception("Cannot unmarshal type Align");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Align)untypedValue;
            switch (value)
            {
                case Align.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case Align.Left:
                    serializer.Serialize(writer, "left");
                    return;
                case Align.Right:
                    serializer.Serialize(writer, "right");
                    return;
            }
            throw new Exception("Cannot marshal type Align");
        }

        public static readonly AlignConverter Singleton = new AlignConverter();
    }

    internal class TextBaselineConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextBaseline) || t == typeof(TextBaseline?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "alphabetic":
                    return TextBaseline.Alphabetic;
                case "bottom":
                    return TextBaseline.Bottom;
                case "middle":
                    return TextBaseline.Middle;
                case "top":
                    return TextBaseline.Top;
            }
            throw new Exception("Cannot unmarshal type TextBaseline");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextBaseline)untypedValue;
            switch (value)
            {
                case TextBaseline.Alphabetic:
                    serializer.Serialize(writer, "alphabetic");
                    return;
                case TextBaseline.Bottom:
                    serializer.Serialize(writer, "bottom");
                    return;
                case TextBaseline.Middle:
                    serializer.Serialize(writer, "middle");
                    return;
                case TextBaseline.Top:
                    serializer.Serialize(writer, "top");
                    return;
            }
            throw new Exception("Cannot marshal type TextBaseline");
        }

        public static readonly TextBaselineConverter Singleton = new TextBaselineConverter();
    }

    internal class CursorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Cursor) || t == typeof(Cursor?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "alias":
                    return Cursor.Alias;
                case "all-scroll":
                    return Cursor.AllScroll;
                case "auto":
                    return Cursor.Auto;
                case "cell":
                    return Cursor.Cell;
                case "col-resize":
                    return Cursor.ColResize;
                case "context-menu":
                    return Cursor.ContextMenu;
                case "copy":
                    return Cursor.Copy;
                case "crosshair":
                    return Cursor.Crosshair;
                case "default":
                    return Cursor.Default;
                case "e-resize":
                    return Cursor.EResize;
                case "ew-resize":
                    return Cursor.EwResize;
                case "grab":
                    return Cursor.Grab;
                case "grabbing":
                    return Cursor.Grabbing;
                case "help":
                    return Cursor.Help;
                case "move":
                    return Cursor.Move;
                case "n-resize":
                    return Cursor.NResize;
                case "ne-resize":
                    return Cursor.NeResize;
                case "nesw-resize":
                    return Cursor.NeswResize;
                case "no-drop":
                    return Cursor.NoDrop;
                case "none":
                    return Cursor.None;
                case "not-allowed":
                    return Cursor.NotAllowed;
                case "ns-resize":
                    return Cursor.NsResize;
                case "nw-resize":
                    return Cursor.NwResize;
                case "nwse-resize":
                    return Cursor.NwseResize;
                case "pointer":
                    return Cursor.Pointer;
                case "progress":
                    return Cursor.Progress;
                case "row-resize":
                    return Cursor.RowResize;
                case "s-resize":
                    return Cursor.SResize;
                case "se-resize":
                    return Cursor.SeResize;
                case "sw-resize":
                    return Cursor.SwResize;
                case "text":
                    return Cursor.Text;
                case "vertical-text":
                    return Cursor.VerticalText;
                case "w-resize":
                    return Cursor.WResize;
                case "wait":
                    return Cursor.Wait;
                case "zoom-in":
                    return Cursor.ZoomIn;
                case "zoom-out":
                    return Cursor.ZoomOut;
            }
            throw new Exception("Cannot unmarshal type Cursor");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Cursor)untypedValue;
            switch (value)
            {
                case Cursor.Alias:
                    serializer.Serialize(writer, "alias");
                    return;
                case Cursor.AllScroll:
                    serializer.Serialize(writer, "all-scroll");
                    return;
                case Cursor.Auto:
                    serializer.Serialize(writer, "auto");
                    return;
                case Cursor.Cell:
                    serializer.Serialize(writer, "cell");
                    return;
                case Cursor.ColResize:
                    serializer.Serialize(writer, "col-resize");
                    return;
                case Cursor.ContextMenu:
                    serializer.Serialize(writer, "context-menu");
                    return;
                case Cursor.Copy:
                    serializer.Serialize(writer, "copy");
                    return;
                case Cursor.Crosshair:
                    serializer.Serialize(writer, "crosshair");
                    return;
                case Cursor.Default:
                    serializer.Serialize(writer, "default");
                    return;
                case Cursor.EResize:
                    serializer.Serialize(writer, "e-resize");
                    return;
                case Cursor.EwResize:
                    serializer.Serialize(writer, "ew-resize");
                    return;
                case Cursor.Grab:
                    serializer.Serialize(writer, "grab");
                    return;
                case Cursor.Grabbing:
                    serializer.Serialize(writer, "grabbing");
                    return;
                case Cursor.Help:
                    serializer.Serialize(writer, "help");
                    return;
                case Cursor.Move:
                    serializer.Serialize(writer, "move");
                    return;
                case Cursor.NResize:
                    serializer.Serialize(writer, "n-resize");
                    return;
                case Cursor.NeResize:
                    serializer.Serialize(writer, "ne-resize");
                    return;
                case Cursor.NeswResize:
                    serializer.Serialize(writer, "nesw-resize");
                    return;
                case Cursor.NoDrop:
                    serializer.Serialize(writer, "no-drop");
                    return;
                case Cursor.None:
                    serializer.Serialize(writer, "none");
                    return;
                case Cursor.NotAllowed:
                    serializer.Serialize(writer, "not-allowed");
                    return;
                case Cursor.NsResize:
                    serializer.Serialize(writer, "ns-resize");
                    return;
                case Cursor.NwResize:
                    serializer.Serialize(writer, "nw-resize");
                    return;
                case Cursor.NwseResize:
                    serializer.Serialize(writer, "nwse-resize");
                    return;
                case Cursor.Pointer:
                    serializer.Serialize(writer, "pointer");
                    return;
                case Cursor.Progress:
                    serializer.Serialize(writer, "progress");
                    return;
                case Cursor.RowResize:
                    serializer.Serialize(writer, "row-resize");
                    return;
                case Cursor.SResize:
                    serializer.Serialize(writer, "s-resize");
                    return;
                case Cursor.SeResize:
                    serializer.Serialize(writer, "se-resize");
                    return;
                case Cursor.SwResize:
                    serializer.Serialize(writer, "sw-resize");
                    return;
                case Cursor.Text:
                    serializer.Serialize(writer, "text");
                    return;
                case Cursor.VerticalText:
                    serializer.Serialize(writer, "vertical-text");
                    return;
                case Cursor.WResize:
                    serializer.Serialize(writer, "w-resize");
                    return;
                case Cursor.Wait:
                    serializer.Serialize(writer, "wait");
                    return;
                case Cursor.ZoomIn:
                    serializer.Serialize(writer, "zoom-in");
                    return;
                case Cursor.ZoomOut:
                    serializer.Serialize(writer, "zoom-out");
                    return;
            }
            throw new Exception("Cannot marshal type Cursor");
        }

        public static readonly CursorConverter Singleton = new CursorConverter();
    }

    internal class DirConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Dir) || t == typeof(Dir?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ltr":
                    return Dir.Ltr;
                case "rtl":
                    return Dir.Rtl;
            }
            throw new Exception("Cannot unmarshal type Dir");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Dir)untypedValue;
            switch (value)
            {
                case Dir.Ltr:
                    serializer.Serialize(writer, "ltr");
                    return;
                case Dir.Rtl:
                    serializer.Serialize(writer, "rtl");
                    return;
            }
            throw new Exception("Cannot marshal type Dir");
        }

        public static readonly DirConverter Singleton = new DirConverter();
    }

    internal class FontStyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FontStyle) || t == typeof(FontStyle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "italic":
                    return FontStyle.Italic;
                case "normal":
                    return FontStyle.Normal;
            }
            throw new Exception("Cannot unmarshal type FontStyle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FontStyle)untypedValue;
            switch (value)
            {
                case FontStyle.Italic:
                    serializer.Serialize(writer, "italic");
                    return;
                case FontStyle.Normal:
                    serializer.Serialize(writer, "normal");
                    return;
            }
            throw new Exception("Cannot marshal type FontStyle");
        }

        public static readonly FontStyleConverter Singleton = new FontStyleConverter();
    }

    internal class FontWeightConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FontWeight) || t == typeof(FontWeight?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new FontWeight { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "bold":
                            return new FontWeight { Enum = FontWeightEnum.Bold };
                        case "bolder":
                            return new FontWeight { Enum = FontWeightEnum.Bolder };
                        case "lighter":
                            return new FontWeight { Enum = FontWeightEnum.Lighter };
                        case "normal":
                            return new FontWeight { Enum = FontWeightEnum.Normal };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type FontWeight");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FontWeight)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case FontWeightEnum.Bold:
                        serializer.Serialize(writer, "bold");
                        return;
                    case FontWeightEnum.Bolder:
                        serializer.Serialize(writer, "bolder");
                        return;
                    case FontWeightEnum.Lighter:
                        serializer.Serialize(writer, "lighter");
                        return;
                    case FontWeightEnum.Normal:
                        serializer.Serialize(writer, "normal");
                        return;
                }
            }
            throw new Exception("Cannot marshal type FontWeight");
        }

        public static readonly FontWeightConverter Singleton = new FontWeightConverter();
    }

    internal class FontWeightEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FontWeightEnum) || t == typeof(FontWeightEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bold":
                    return FontWeightEnum.Bold;
                case "bolder":
                    return FontWeightEnum.Bolder;
                case "lighter":
                    return FontWeightEnum.Lighter;
                case "normal":
                    return FontWeightEnum.Normal;
            }
            throw new Exception("Cannot unmarshal type FontWeightEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FontWeightEnum)untypedValue;
            switch (value)
            {
                case FontWeightEnum.Bold:
                    serializer.Serialize(writer, "bold");
                    return;
                case FontWeightEnum.Bolder:
                    serializer.Serialize(writer, "bolder");
                    return;
                case FontWeightEnum.Lighter:
                    serializer.Serialize(writer, "lighter");
                    return;
                case FontWeightEnum.Normal:
                    serializer.Serialize(writer, "normal");
                    return;
            }
            throw new Exception("Cannot marshal type FontWeightEnum");
        }

        public static readonly FontWeightEnumConverter Singleton = new FontWeightEnumConverter();
    }

    internal class InterpolateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Interpolate) || t == typeof(Interpolate?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "basis":
                    return Interpolate.Basis;
                case "basis-closed":
                    return Interpolate.BasisClosed;
                case "basis-open":
                    return Interpolate.BasisOpen;
                case "bundle":
                    return Interpolate.Bundle;
                case "cardinal":
                    return Interpolate.Cardinal;
                case "cardinal-closed":
                    return Interpolate.CardinalClosed;
                case "cardinal-open":
                    return Interpolate.CardinalOpen;
                case "linear":
                    return Interpolate.Linear;
                case "linear-closed":
                    return Interpolate.LinearClosed;
                case "monotone":
                    return Interpolate.Monotone;
                case "step":
                    return Interpolate.Step;
                case "step-after":
                    return Interpolate.StepAfter;
                case "step-before":
                    return Interpolate.StepBefore;
            }
            throw new Exception("Cannot unmarshal type Interpolate");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Interpolate)untypedValue;
            switch (value)
            {
                case Interpolate.Basis:
                    serializer.Serialize(writer, "basis");
                    return;
                case Interpolate.BasisClosed:
                    serializer.Serialize(writer, "basis-closed");
                    return;
                case Interpolate.BasisOpen:
                    serializer.Serialize(writer, "basis-open");
                    return;
                case Interpolate.Bundle:
                    serializer.Serialize(writer, "bundle");
                    return;
                case Interpolate.Cardinal:
                    serializer.Serialize(writer, "cardinal");
                    return;
                case Interpolate.CardinalClosed:
                    serializer.Serialize(writer, "cardinal-closed");
                    return;
                case Interpolate.CardinalOpen:
                    serializer.Serialize(writer, "cardinal-open");
                    return;
                case Interpolate.Linear:
                    serializer.Serialize(writer, "linear");
                    return;
                case Interpolate.LinearClosed:
                    serializer.Serialize(writer, "linear-closed");
                    return;
                case Interpolate.Monotone:
                    serializer.Serialize(writer, "monotone");
                    return;
                case Interpolate.Step:
                    serializer.Serialize(writer, "step");
                    return;
                case Interpolate.StepAfter:
                    serializer.Serialize(writer, "step-after");
                    return;
                case Interpolate.StepBefore:
                    serializer.Serialize(writer, "step-before");
                    return;
            }
            throw new Exception("Cannot marshal type Interpolate");
        }

        public static readonly InterpolateConverter Singleton = new InterpolateConverter();
    }

    internal class LineConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Line) || t == typeof(Line?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Line { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<OverlayMarkDef>(reader);
                    return new Line { OverlayMarkDef = objectValue };
            }
            throw new Exception("Cannot unmarshal type Line");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Line)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.OverlayMarkDef != null)
            {
                serializer.Serialize(writer, value.OverlayMarkDef);
                return;
            }
            throw new Exception("Cannot marshal type Line");
        }

        public static readonly LineConverter Singleton = new LineConverter();
    }

    internal class OrientConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Orient) || t == typeof(Orient?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "horizontal":
                    return Orient.Horizontal;
                case "vertical":
                    return Orient.Vertical;
            }
            throw new Exception("Cannot unmarshal type Orient");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Orient)untypedValue;
            switch (value)
            {
                case Orient.Horizontal:
                    serializer.Serialize(writer, "horizontal");
                    return;
                case Orient.Vertical:
                    serializer.Serialize(writer, "vertical");
                    return;
            }
            throw new Exception("Cannot marshal type Orient");
        }

        public static readonly OrientConverter Singleton = new OrientConverter();
    }

    internal class StrokeCapConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StrokeCap) || t == typeof(StrokeCap?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "butt":
                    return StrokeCap.Butt;
                case "round":
                    return StrokeCap.Round;
                case "square":
                    return StrokeCap.Square;
            }
            throw new Exception("Cannot unmarshal type StrokeCap");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (StrokeCap)untypedValue;
            switch (value)
            {
                case StrokeCap.Butt:
                    serializer.Serialize(writer, "butt");
                    return;
                case StrokeCap.Round:
                    serializer.Serialize(writer, "round");
                    return;
                case StrokeCap.Square:
                    serializer.Serialize(writer, "square");
                    return;
            }
            throw new Exception("Cannot marshal type StrokeCap");
        }

        public static readonly StrokeCapConverter Singleton = new StrokeCapConverter();
    }

    internal class StrokeJoinConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StrokeJoin) || t == typeof(StrokeJoin?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bevel":
                    return StrokeJoin.Bevel;
                case "miter":
                    return StrokeJoin.Miter;
                case "round":
                    return StrokeJoin.Round;
            }
            throw new Exception("Cannot unmarshal type StrokeJoin");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (StrokeJoin)untypedValue;
            switch (value)
            {
                case StrokeJoin.Bevel:
                    serializer.Serialize(writer, "bevel");
                    return;
                case StrokeJoin.Miter:
                    serializer.Serialize(writer, "miter");
                    return;
                case StrokeJoin.Round:
                    serializer.Serialize(writer, "round");
                    return;
            }
            throw new Exception("Cannot marshal type StrokeJoin");
        }

        public static readonly StrokeJoinConverter Singleton = new StrokeJoinConverter();
    }

    internal class StyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Style) || t == typeof(Style?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Style { String = stringValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<string[]>(reader);
                    return new Style { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Style");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Style)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            throw new Exception("Cannot marshal type Style");
        }

        public static readonly StyleConverter Singleton = new StyleConverter();
    }

    internal class TooltipConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Tooltip) || t == typeof(Tooltip?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Tooltip { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TooltipContent>(reader);
                    return new Tooltip { TooltipContent = objectValue };
            }
            throw new Exception("Cannot unmarshal type Tooltip");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Tooltip)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.TooltipContent != null)
            {
                serializer.Serialize(writer, value.TooltipContent);
                return;
            }
            throw new Exception("Cannot marshal type Tooltip");
        }

        public static readonly TooltipConverter Singleton = new TooltipConverter();
    }

    internal class ContentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Content) || t == typeof(Content?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "data":
                    return Content.Data;
                case "encoding":
                    return Content.Encoding;
            }
            throw new Exception("Cannot unmarshal type Content");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Content)untypedValue;
            switch (value)
            {
                case Content.Data:
                    serializer.Serialize(writer, "data");
                    return;
                case Content.Encoding:
                    serializer.Serialize(writer, "encoding");
                    return;
            }
            throw new Exception("Cannot marshal type Content");
        }

        public static readonly ContentConverter Singleton = new ContentConverter();
    }

    internal class PointUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PointUnion) || t == typeof(PointUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new PointUnion { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue == "transparent")
                    {
                        return new PointUnion { Enum = PointEnum.Transparent };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<OverlayMarkDef>(reader);
                    return new PointUnion { OverlayMarkDef = objectValue };
            }
            throw new Exception("Cannot unmarshal type PointUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PointUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.Enum != null)
            {
                if (value.Enum == PointEnum.Transparent)
                {
                    serializer.Serialize(writer, "transparent");
                    return;
                }
            }
            if (value.OverlayMarkDef != null)
            {
                serializer.Serialize(writer, value.OverlayMarkDef);
                return;
            }
            throw new Exception("Cannot marshal type PointUnion");
        }

        public static readonly PointUnionConverter Singleton = new PointUnionConverter();
    }

    internal class PointEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PointEnum) || t == typeof(PointEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "transparent")
            {
                return PointEnum.Transparent;
            }
            throw new Exception("Cannot unmarshal type PointEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PointEnum)untypedValue;
            if (value == PointEnum.Transparent)
            {
                serializer.Serialize(writer, "transparent");
                return;
            }
            throw new Exception("Cannot marshal type PointEnum");
        }

        public static readonly PointEnumConverter Singleton = new PointEnumConverter();
    }

    internal class LabelConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Label) || t == typeof(Label?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Label { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Label { Bool = boolValue };
            }
            throw new Exception("Cannot unmarshal type Label");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Label)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            throw new Exception("Cannot marshal type Label");
        }

        public static readonly LabelConverter Singleton = new LabelConverter();
    }

    internal class LabelOverlapConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LabelOverlap) || t == typeof(LabelOverlap?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new LabelOverlap { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "greedy":
                            return new LabelOverlap { Enum = LabelOverlapEnum.Greedy };
                        case "parity":
                            return new LabelOverlap { Enum = LabelOverlapEnum.Parity };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type LabelOverlap");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LabelOverlap)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case LabelOverlapEnum.Greedy:
                        serializer.Serialize(writer, "greedy");
                        return;
                    case LabelOverlapEnum.Parity:
                        serializer.Serialize(writer, "parity");
                        return;
                }
            }
            throw new Exception("Cannot marshal type LabelOverlap");
        }

        public static readonly LabelOverlapConverter Singleton = new LabelOverlapConverter();
    }

    internal class LabelOverlapEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LabelOverlapEnum) || t == typeof(LabelOverlapEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "greedy":
                    return LabelOverlapEnum.Greedy;
                case "parity":
                    return LabelOverlapEnum.Parity;
            }
            throw new Exception("Cannot unmarshal type LabelOverlapEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LabelOverlapEnum)untypedValue;
            switch (value)
            {
                case LabelOverlapEnum.Greedy:
                    serializer.Serialize(writer, "greedy");
                    return;
                case LabelOverlapEnum.Parity:
                    serializer.Serialize(writer, "parity");
                    return;
            }
            throw new Exception("Cannot marshal type LabelOverlapEnum");
        }

        public static readonly LabelOverlapEnumConverter Singleton = new LabelOverlapEnumConverter();
    }

    internal class BoxConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Box) || t == typeof(Box?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Box { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<MarkConfig>(reader);
                    return new Box { MarkConfig = objectValue };
            }
            throw new Exception("Cannot unmarshal type Box");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Box)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.MarkConfig != null)
            {
                serializer.Serialize(writer, value.MarkConfig);
                return;
            }
            throw new Exception("Cannot marshal type Box");
        }

        public static readonly BoxConverter Singleton = new BoxConverter();
    }

    internal class BoxplotExtentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BoxplotExtent) || t == typeof(BoxplotExtent?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new BoxplotExtent { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue == "min-max")
                    {
                        return new BoxplotExtent { Enum = ExtentEnum.MinMax };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type BoxplotExtent");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BoxplotExtent)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Enum != null)
            {
                if (value.Enum == ExtentEnum.MinMax)
                {
                    serializer.Serialize(writer, "min-max");
                    return;
                }
            }
            throw new Exception("Cannot marshal type BoxplotExtent");
        }

        public static readonly BoxplotExtentConverter Singleton = new BoxplotExtentConverter();
    }

    internal class ExtentEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ExtentEnum) || t == typeof(ExtentEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "min-max")
            {
                return ExtentEnum.MinMax;
            }
            throw new Exception("Cannot unmarshal type ExtentEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ExtentEnum)untypedValue;
            if (value == ExtentEnum.MinMax)
            {
                serializer.Serialize(writer, "min-max");
                return;
            }
            throw new Exception("Cannot marshal type ExtentEnum");
        }

        public static readonly ExtentEnumConverter Singleton = new ExtentEnumConverter();
    }

    internal class ErrorbandExtentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ErrorbandExtent) || t == typeof(ErrorbandExtent?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ci":
                    return ErrorbandExtent.Ci;
                case "iqr":
                    return ErrorbandExtent.Iqr;
                case "stderr":
                    return ErrorbandExtent.Stderr;
                case "stdev":
                    return ErrorbandExtent.Stdev;
            }
            throw new Exception("Cannot unmarshal type ErrorbandExtent");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ErrorbandExtent)untypedValue;
            switch (value)
            {
                case ErrorbandExtent.Ci:
                    serializer.Serialize(writer, "ci");
                    return;
                case ErrorbandExtent.Iqr:
                    serializer.Serialize(writer, "iqr");
                    return;
                case ErrorbandExtent.Stderr:
                    serializer.Serialize(writer, "stderr");
                    return;
                case ErrorbandExtent.Stdev:
                    serializer.Serialize(writer, "stdev");
                    return;
            }
            throw new Exception("Cannot marshal type ErrorbandExtent");
        }

        public static readonly ErrorbandExtentConverter Singleton = new ErrorbandExtentConverter();
    }

    internal class FieldTitleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FieldTitle) || t == typeof(FieldTitle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "functional":
                    return FieldTitle.Functional;
                case "plain":
                    return FieldTitle.Plain;
                case "verbal":
                    return FieldTitle.Verbal;
            }
            throw new Exception("Cannot unmarshal type FieldTitle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FieldTitle)untypedValue;
            switch (value)
            {
                case FieldTitle.Functional:
                    serializer.Serialize(writer, "functional");
                    return;
                case FieldTitle.Plain:
                    serializer.Serialize(writer, "plain");
                    return;
                case FieldTitle.Verbal:
                    serializer.Serialize(writer, "verbal");
                    return;
            }
            throw new Exception("Cannot marshal type FieldTitle");
        }

        public static readonly FieldTitleConverter Singleton = new FieldTitleConverter();
    }

    internal class InvalidValuesConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(InvalidValues) || t == typeof(InvalidValues?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "filter")
            {
                return InvalidValues.Filter;
            }
            throw new Exception("Cannot unmarshal type InvalidValues");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (InvalidValues)untypedValue;
            if (value == InvalidValues.Filter)
            {
                serializer.Serialize(writer, "filter");
                return;
            }
            throw new Exception("Cannot marshal type InvalidValues");
        }

        public static readonly InvalidValuesConverter Singleton = new InvalidValuesConverter();
    }

    internal class LegendOrientConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LegendOrient) || t == typeof(LegendOrient?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bottom":
                    return LegendOrient.Bottom;
                case "bottom-left":
                    return LegendOrient.BottomLeft;
                case "bottom-right":
                    return LegendOrient.BottomRight;
                case "left":
                    return LegendOrient.Left;
                case "none":
                    return LegendOrient.None;
                case "right":
                    return LegendOrient.Right;
                case "top":
                    return LegendOrient.Top;
                case "top-left":
                    return LegendOrient.TopLeft;
                case "top-right":
                    return LegendOrient.TopRight;
            }
            throw new Exception("Cannot unmarshal type LegendOrient");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LegendOrient)untypedValue;
            switch (value)
            {
                case LegendOrient.Bottom:
                    serializer.Serialize(writer, "bottom");
                    return;
                case LegendOrient.BottomLeft:
                    serializer.Serialize(writer, "bottom-left");
                    return;
                case LegendOrient.BottomRight:
                    serializer.Serialize(writer, "bottom-right");
                    return;
                case LegendOrient.Left:
                    serializer.Serialize(writer, "left");
                    return;
                case LegendOrient.None:
                    serializer.Serialize(writer, "none");
                    return;
                case LegendOrient.Right:
                    serializer.Serialize(writer, "right");
                    return;
                case LegendOrient.Top:
                    serializer.Serialize(writer, "top");
                    return;
                case LegendOrient.TopLeft:
                    serializer.Serialize(writer, "top-left");
                    return;
                case LegendOrient.TopRight:
                    serializer.Serialize(writer, "top-right");
                    return;
            }
            throw new Exception("Cannot marshal type LegendOrient");
        }

        public static readonly LegendOrientConverter Singleton = new LegendOrientConverter();
    }

    internal class PaddingConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Padding) || t == typeof(Padding?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Padding { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PaddingClass>(reader);
                    return new Padding { PaddingClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type Padding");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Padding)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.PaddingClass != null)
            {
                serializer.Serialize(writer, value.PaddingClass);
                return;
            }
            throw new Exception("Cannot marshal type Padding");
        }

        public static readonly PaddingConverter Singleton = new PaddingConverter();
    }

    internal class VgProjectionTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(VgProjectionType) || t == typeof(VgProjectionType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "albers":
                    return VgProjectionType.Albers;
                case "albersUsa":
                    return VgProjectionType.AlbersUsa;
                case "azimuthalEqualArea":
                    return VgProjectionType.AzimuthalEqualArea;
                case "azimuthalEquidistant":
                    return VgProjectionType.AzimuthalEquidistant;
                case "conicConformal":
                    return VgProjectionType.ConicConformal;
                case "conicEqualArea":
                    return VgProjectionType.ConicEqualArea;
                case "conicEquidistant":
                    return VgProjectionType.ConicEquidistant;
                case "equirectangular":
                    return VgProjectionType.Equirectangular;
                case "gnomonic":
                    return VgProjectionType.Gnomonic;
                case "mercator":
                    return VgProjectionType.Mercator;
                case "orthographic":
                    return VgProjectionType.Orthographic;
                case "stereographic":
                    return VgProjectionType.Stereographic;
                case "transverseMercator":
                    return VgProjectionType.TransverseMercator;
            }
            throw new Exception("Cannot unmarshal type VgProjectionType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (VgProjectionType)untypedValue;
            switch (value)
            {
                case VgProjectionType.Albers:
                    serializer.Serialize(writer, "albers");
                    return;
                case VgProjectionType.AlbersUsa:
                    serializer.Serialize(writer, "albersUsa");
                    return;
                case VgProjectionType.AzimuthalEqualArea:
                    serializer.Serialize(writer, "azimuthalEqualArea");
                    return;
                case VgProjectionType.AzimuthalEquidistant:
                    serializer.Serialize(writer, "azimuthalEquidistant");
                    return;
                case VgProjectionType.ConicConformal:
                    serializer.Serialize(writer, "conicConformal");
                    return;
                case VgProjectionType.ConicEqualArea:
                    serializer.Serialize(writer, "conicEqualArea");
                    return;
                case VgProjectionType.ConicEquidistant:
                    serializer.Serialize(writer, "conicEquidistant");
                    return;
                case VgProjectionType.Equirectangular:
                    serializer.Serialize(writer, "equirectangular");
                    return;
                case VgProjectionType.Gnomonic:
                    serializer.Serialize(writer, "gnomonic");
                    return;
                case VgProjectionType.Mercator:
                    serializer.Serialize(writer, "mercator");
                    return;
                case VgProjectionType.Orthographic:
                    serializer.Serialize(writer, "orthographic");
                    return;
                case VgProjectionType.Stereographic:
                    serializer.Serialize(writer, "stereographic");
                    return;
                case VgProjectionType.TransverseMercator:
                    serializer.Serialize(writer, "transverseMercator");
                    return;
            }
            throw new Exception("Cannot marshal type VgProjectionType");
        }

        public static readonly VgProjectionTypeConverter Singleton = new VgProjectionTypeConverter();
    }

    internal class RangeValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RangeValue) || t == typeof(RangeValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<VgScheme>(reader);
                    return new RangeValue { VgScheme = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<RangeElement[]>(reader);
                    return new RangeValue { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type RangeValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (RangeValue)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.VgScheme != null)
            {
                serializer.Serialize(writer, value.VgScheme);
                return;
            }
            throw new Exception("Cannot marshal type RangeValue");
        }

        public static readonly RangeValueConverter Singleton = new RangeValueConverter();
    }

    internal class RangeElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RangeElement) || t == typeof(RangeElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new RangeElement { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new RangeElement { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type RangeElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (RangeElement)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type RangeElement");
        }

        public static readonly RangeElementConverter Singleton = new RangeElementConverter();
    }

    internal class BindEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BindEnum) || t == typeof(BindEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "scales")
            {
                return BindEnum.Scales;
            }
            throw new Exception("Cannot unmarshal type BindEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BindEnum)untypedValue;
            if (value == BindEnum.Scales)
            {
                serializer.Serialize(writer, "scales");
                return;
            }
            throw new Exception("Cannot marshal type BindEnum");
        }

        public static readonly BindEnumConverter Singleton = new BindEnumConverter();
    }

    internal class EmptyConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Empty) || t == typeof(Empty?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "all":
                    return Empty.All;
                case "none":
                    return Empty.None;
            }
            throw new Exception("Cannot unmarshal type Empty");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Empty)untypedValue;
            switch (value)
            {
                case Empty.All:
                    serializer.Serialize(writer, "all");
                    return;
                case Empty.None:
                    serializer.Serialize(writer, "none");
                    return;
            }
            throw new Exception("Cannot marshal type Empty");
        }

        public static readonly EmptyConverter Singleton = new EmptyConverter();
    }

    internal class SingleDefChannelConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SingleDefChannel) || t == typeof(SingleDefChannel?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "color":
                    return SingleDefChannel.Color;
                case "column":
                    return SingleDefChannel.Column;
                case "fill":
                    return SingleDefChannel.Fill;
                case "fillOpacity":
                    return SingleDefChannel.FillOpacity;
                case "href":
                    return SingleDefChannel.Href;
                case "key":
                    return SingleDefChannel.Key;
                case "latitude":
                    return SingleDefChannel.Latitude;
                case "latitude2":
                    return SingleDefChannel.Latitude2;
                case "longitude":
                    return SingleDefChannel.Longitude;
                case "longitude2":
                    return SingleDefChannel.Longitude2;
                case "opacity":
                    return SingleDefChannel.Opacity;
                case "row":
                    return SingleDefChannel.Row;
                case "shape":
                    return SingleDefChannel.Shape;
                case "size":
                    return SingleDefChannel.Size;
                case "stroke":
                    return SingleDefChannel.Stroke;
                case "strokeOpacity":
                    return SingleDefChannel.StrokeOpacity;
                case "strokeWidth":
                    return SingleDefChannel.StrokeWidth;
                case "text":
                    return SingleDefChannel.Text;
                case "tooltip":
                    return SingleDefChannel.Tooltip;
                case "x":
                    return SingleDefChannel.X;
                case "x2":
                    return SingleDefChannel.X2;
                case "xError":
                    return SingleDefChannel.XError;
                case "xError2":
                    return SingleDefChannel.XError2;
                case "y":
                    return SingleDefChannel.Y;
                case "y2":
                    return SingleDefChannel.Y2;
                case "yError":
                    return SingleDefChannel.YError;
                case "yError2":
                    return SingleDefChannel.YError2;
            }
            throw new Exception("Cannot unmarshal type SingleDefChannel");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SingleDefChannel)untypedValue;
            switch (value)
            {
                case SingleDefChannel.Color:
                    serializer.Serialize(writer, "color");
                    return;
                case SingleDefChannel.Column:
                    serializer.Serialize(writer, "column");
                    return;
                case SingleDefChannel.Fill:
                    serializer.Serialize(writer, "fill");
                    return;
                case SingleDefChannel.FillOpacity:
                    serializer.Serialize(writer, "fillOpacity");
                    return;
                case SingleDefChannel.Href:
                    serializer.Serialize(writer, "href");
                    return;
                case SingleDefChannel.Key:
                    serializer.Serialize(writer, "key");
                    return;
                case SingleDefChannel.Latitude:
                    serializer.Serialize(writer, "latitude");
                    return;
                case SingleDefChannel.Latitude2:
                    serializer.Serialize(writer, "latitude2");
                    return;
                case SingleDefChannel.Longitude:
                    serializer.Serialize(writer, "longitude");
                    return;
                case SingleDefChannel.Longitude2:
                    serializer.Serialize(writer, "longitude2");
                    return;
                case SingleDefChannel.Opacity:
                    serializer.Serialize(writer, "opacity");
                    return;
                case SingleDefChannel.Row:
                    serializer.Serialize(writer, "row");
                    return;
                case SingleDefChannel.Shape:
                    serializer.Serialize(writer, "shape");
                    return;
                case SingleDefChannel.Size:
                    serializer.Serialize(writer, "size");
                    return;
                case SingleDefChannel.Stroke:
                    serializer.Serialize(writer, "stroke");
                    return;
                case SingleDefChannel.StrokeOpacity:
                    serializer.Serialize(writer, "strokeOpacity");
                    return;
                case SingleDefChannel.StrokeWidth:
                    serializer.Serialize(writer, "strokeWidth");
                    return;
                case SingleDefChannel.Text:
                    serializer.Serialize(writer, "text");
                    return;
                case SingleDefChannel.Tooltip:
                    serializer.Serialize(writer, "tooltip");
                    return;
                case SingleDefChannel.X:
                    serializer.Serialize(writer, "x");
                    return;
                case SingleDefChannel.X2:
                    serializer.Serialize(writer, "x2");
                    return;
                case SingleDefChannel.XError:
                    serializer.Serialize(writer, "xError");
                    return;
                case SingleDefChannel.XError2:
                    serializer.Serialize(writer, "xError2");
                    return;
                case SingleDefChannel.Y:
                    serializer.Serialize(writer, "y");
                    return;
                case SingleDefChannel.Y2:
                    serializer.Serialize(writer, "y2");
                    return;
                case SingleDefChannel.YError:
                    serializer.Serialize(writer, "yError");
                    return;
                case SingleDefChannel.YError2:
                    serializer.Serialize(writer, "yError2");
                    return;
            }
            throw new Exception("Cannot marshal type SingleDefChannel");
        }

        public static readonly SingleDefChannelConverter Singleton = new SingleDefChannelConverter();
    }

    internal class SelectionResolutionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SelectionResolution) || t == typeof(SelectionResolution?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "global":
                    return SelectionResolution.Global;
                case "intersect":
                    return SelectionResolution.Intersect;
                case "union":
                    return SelectionResolution.Union;
            }
            throw new Exception("Cannot unmarshal type SelectionResolution");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SelectionResolution)untypedValue;
            switch (value)
            {
                case SelectionResolution.Global:
                    serializer.Serialize(writer, "global");
                    return;
                case SelectionResolution.Intersect:
                    serializer.Serialize(writer, "intersect");
                    return;
                case SelectionResolution.Union:
                    serializer.Serialize(writer, "union");
                    return;
            }
            throw new Exception("Cannot marshal type SelectionResolution");
        }

        public static readonly SelectionResolutionConverter Singleton = new SelectionResolutionConverter();
    }

    internal class TranslateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Translate) || t == typeof(Translate?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Translate { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Translate { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Translate");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Translate)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type Translate");
        }

        public static readonly TranslateConverter Singleton = new TranslateConverter();
    }

    internal class BindValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BindValue) || t == typeof(BindValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new BindValue { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new BindValue { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Binding>(reader);
                    return new BindValue { Binding = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<object[]>(reader);
                    return new BindValue { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type BindValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BindValue)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.Binding != null)
            {
                serializer.Serialize(writer, value.Binding);
                return;
            }
            throw new Exception("Cannot marshal type BindValue");
        }

        public static readonly BindValueConverter Singleton = new BindValueConverter();
    }

    internal class InputConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Input) || t == typeof(Input?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "checkbox":
                    return Input.Checkbox;
                case "radio":
                    return Input.Radio;
                case "range":
                    return Input.Range;
                case "select":
                    return Input.Select;
            }
            throw new Exception("Cannot unmarshal type Input");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Input)untypedValue;
            switch (value)
            {
                case Input.Checkbox:
                    serializer.Serialize(writer, "checkbox");
                    return;
                case Input.Radio:
                    serializer.Serialize(writer, "radio");
                    return;
                case Input.Range:
                    serializer.Serialize(writer, "range");
                    return;
                case Input.Select:
                    serializer.Serialize(writer, "select");
                    return;
            }
            throw new Exception("Cannot marshal type Input");
        }

        public static readonly InputConverter Singleton = new InputConverter();
    }

    internal class StackOffsetConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StackOffset) || t == typeof(StackOffset?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "center":
                    return StackOffset.Center;
                case "normalize":
                    return StackOffset.Normalize;
                case "zero":
                    return StackOffset.Zero;
            }
            throw new Exception("Cannot unmarshal type StackOffset");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (StackOffset)untypedValue;
            switch (value)
            {
                case StackOffset.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case StackOffset.Normalize:
                    serializer.Serialize(writer, "normalize");
                    return;
                case StackOffset.Zero:
                    serializer.Serialize(writer, "zero");
                    return;
            }
            throw new Exception("Cannot marshal type StackOffset");
        }

        public static readonly StackOffsetConverter Singleton = new StackOffsetConverter();
    }

    internal class TitleAnchorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TitleAnchor) || t == typeof(TitleAnchor?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "end":
                    return TitleAnchor.End;
                case "middle":
                    return TitleAnchor.Middle;
                case "start":
                    return TitleAnchor.Start;
            }
            throw new Exception("Cannot unmarshal type TitleAnchor");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TitleAnchor)untypedValue;
            switch (value)
            {
                case TitleAnchor.End:
                    serializer.Serialize(writer, "end");
                    return;
                case TitleAnchor.Middle:
                    serializer.Serialize(writer, "middle");
                    return;
                case TitleAnchor.Start:
                    serializer.Serialize(writer, "start");
                    return;
            }
            throw new Exception("Cannot marshal type TitleAnchor");
        }

        public static readonly TitleAnchorConverter Singleton = new TitleAnchorConverter();
    }

    internal class TitleFrameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TitleFrame) || t == typeof(TitleFrame?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bounds":
                    return TitleFrame.Bounds;
                case "group":
                    return TitleFrame.Group;
            }
            throw new Exception("Cannot unmarshal type TitleFrame");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TitleFrame)untypedValue;
            switch (value)
            {
                case TitleFrame.Bounds:
                    serializer.Serialize(writer, "bounds");
                    return;
                case TitleFrame.Group:
                    serializer.Serialize(writer, "group");
                    return;
            }
            throw new Exception("Cannot marshal type TitleFrame");
        }

        public static readonly TitleFrameConverter Singleton = new TitleFrameConverter();
    }

    internal class TitleOrientConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TitleOrient) || t == typeof(TitleOrient?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bottom":
                    return TitleOrient.Bottom;
                case "left":
                    return TitleOrient.Left;
                case "none":
                    return TitleOrient.None;
                case "right":
                    return TitleOrient.Right;
                case "top":
                    return TitleOrient.Top;
            }
            throw new Exception("Cannot unmarshal type TitleOrient");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TitleOrient)untypedValue;
            switch (value)
            {
                case TitleOrient.Bottom:
                    serializer.Serialize(writer, "bottom");
                    return;
                case TitleOrient.Left:
                    serializer.Serialize(writer, "left");
                    return;
                case TitleOrient.None:
                    serializer.Serialize(writer, "none");
                    return;
                case TitleOrient.Right:
                    serializer.Serialize(writer, "right");
                    return;
                case TitleOrient.Top:
                    serializer.Serialize(writer, "top");
                    return;
            }
            throw new Exception("Cannot marshal type TitleOrient");
        }

        public static readonly TitleOrientConverter Singleton = new TitleOrientConverter();
    }

    internal class MinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1 && value.Length <= 1)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 1 && value.Length <= 1)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly MinMaxLengthCheckConverter Singleton = new MinMaxLengthCheckConverter();
    }

    internal class DataFormatTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DataFormatType) || t == typeof(DataFormatType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "csv":
                    return DataFormatType.Csv;
                case "dsv":
                    return DataFormatType.Dsv;
                case "json":
                    return DataFormatType.Json;
                case "topojson":
                    return DataFormatType.Topojson;
                case "tsv":
                    return DataFormatType.Tsv;
            }
            throw new Exception("Cannot unmarshal type DataFormatType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DataFormatType)untypedValue;
            switch (value)
            {
                case DataFormatType.Csv:
                    serializer.Serialize(writer, "csv");
                    return;
                case DataFormatType.Dsv:
                    serializer.Serialize(writer, "dsv");
                    return;
                case DataFormatType.Json:
                    serializer.Serialize(writer, "json");
                    return;
                case DataFormatType.Topojson:
                    serializer.Serialize(writer, "topojson");
                    return;
                case DataFormatType.Tsv:
                    serializer.Serialize(writer, "tsv");
                    return;
            }
            throw new Exception("Cannot marshal type DataFormatType");
        }

        public static readonly DataFormatTypeConverter Singleton = new DataFormatTypeConverter();
    }

    internal class InlineDatasetConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(InlineDataset) || t == typeof(InlineDataset?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new InlineDataset { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Dictionary<string, object>>(reader);
                    return new InlineDataset { AnythingMap = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<InlineDatasetElement[]>(reader);
                    return new InlineDataset { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type InlineDataset");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (InlineDataset)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.AnythingMap != null)
            {
                serializer.Serialize(writer, value.AnythingMap);
                return;
            }
            throw new Exception("Cannot marshal type InlineDataset");
        }

        public static readonly InlineDatasetConverter Singleton = new InlineDatasetConverter();
    }

    internal class InlineDatasetElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(InlineDatasetElement) || t == typeof(InlineDatasetElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new InlineDatasetElement { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new InlineDatasetElement { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new InlineDatasetElement { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Dictionary<string, object>>(reader);
                    return new InlineDatasetElement { AnythingMap = objectValue };
            }
            throw new Exception("Cannot unmarshal type InlineDatasetElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (InlineDatasetElement)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingMap != null)
            {
                serializer.Serialize(writer, value.AnythingMap);
                return;
            }
            throw new Exception("Cannot marshal type InlineDatasetElement");
        }

        public static readonly InlineDatasetElementConverter Singleton = new InlineDatasetElementConverter();
    }

    internal class AggregateOpConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AggregateOp) || t == typeof(AggregateOp?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "argmax":
                    return AggregateOp.Argmax;
                case "argmin":
                    return AggregateOp.Argmin;
                case "average":
                    return AggregateOp.Average;
                case "ci0":
                    return AggregateOp.Ci0;
                case "ci1":
                    return AggregateOp.Ci1;
                case "count":
                    return AggregateOp.Count;
                case "distinct":
                    return AggregateOp.Distinct;
                case "max":
                    return AggregateOp.Max;
                case "mean":
                    return AggregateOp.Mean;
                case "median":
                    return AggregateOp.Median;
                case "min":
                    return AggregateOp.Min;
                case "missing":
                    return AggregateOp.Missing;
                case "q1":
                    return AggregateOp.Q1;
                case "q3":
                    return AggregateOp.Q3;
                case "stderr":
                    return AggregateOp.Stderr;
                case "stdev":
                    return AggregateOp.Stdev;
                case "stdevp":
                    return AggregateOp.Stdevp;
                case "sum":
                    return AggregateOp.Sum;
                case "valid":
                    return AggregateOp.Valid;
                case "values":
                    return AggregateOp.Values;
                case "variance":
                    return AggregateOp.Variance;
                case "variancep":
                    return AggregateOp.Variancep;
            }
            throw new Exception("Cannot unmarshal type AggregateOp");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AggregateOp)untypedValue;
            switch (value)
            {
                case AggregateOp.Argmax:
                    serializer.Serialize(writer, "argmax");
                    return;
                case AggregateOp.Argmin:
                    serializer.Serialize(writer, "argmin");
                    return;
                case AggregateOp.Average:
                    serializer.Serialize(writer, "average");
                    return;
                case AggregateOp.Ci0:
                    serializer.Serialize(writer, "ci0");
                    return;
                case AggregateOp.Ci1:
                    serializer.Serialize(writer, "ci1");
                    return;
                case AggregateOp.Count:
                    serializer.Serialize(writer, "count");
                    return;
                case AggregateOp.Distinct:
                    serializer.Serialize(writer, "distinct");
                    return;
                case AggregateOp.Max:
                    serializer.Serialize(writer, "max");
                    return;
                case AggregateOp.Mean:
                    serializer.Serialize(writer, "mean");
                    return;
                case AggregateOp.Median:
                    serializer.Serialize(writer, "median");
                    return;
                case AggregateOp.Min:
                    serializer.Serialize(writer, "min");
                    return;
                case AggregateOp.Missing:
                    serializer.Serialize(writer, "missing");
                    return;
                case AggregateOp.Q1:
                    serializer.Serialize(writer, "q1");
                    return;
                case AggregateOp.Q3:
                    serializer.Serialize(writer, "q3");
                    return;
                case AggregateOp.Stderr:
                    serializer.Serialize(writer, "stderr");
                    return;
                case AggregateOp.Stdev:
                    serializer.Serialize(writer, "stdev");
                    return;
                case AggregateOp.Stdevp:
                    serializer.Serialize(writer, "stdevp");
                    return;
                case AggregateOp.Sum:
                    serializer.Serialize(writer, "sum");
                    return;
                case AggregateOp.Valid:
                    serializer.Serialize(writer, "valid");
                    return;
                case AggregateOp.Values:
                    serializer.Serialize(writer, "values");
                    return;
                case AggregateOp.Variance:
                    serializer.Serialize(writer, "variance");
                    return;
                case AggregateOp.Variancep:
                    serializer.Serialize(writer, "variancep");
                    return;
            }
            throw new Exception("Cannot marshal type AggregateOp");
        }

        public static readonly AggregateOpConverter Singleton = new AggregateOpConverter();
    }

    internal class PurpleBinConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurpleBin) || t == typeof(PurpleBin?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new PurpleBin { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue == "binned")
                    {
                        return new PurpleBin { Enum = BinEnum.Binned };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BinParams>(reader);
                    return new PurpleBin { BinParams = objectValue };
            }
            throw new Exception("Cannot unmarshal type PurpleBin");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PurpleBin)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.Enum != null)
            {
                if (value.Enum == BinEnum.Binned)
                {
                    serializer.Serialize(writer, "binned");
                    return;
                }
            }
            if (value.BinParams != null)
            {
                serializer.Serialize(writer, value.BinParams);
                return;
            }
            throw new Exception("Cannot marshal type PurpleBin");
        }

        public static readonly PurpleBinConverter Singleton = new PurpleBinConverter();
    }

    internal class BinEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BinEnum) || t == typeof(BinEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "binned")
            {
                return BinEnum.Binned;
            }
            throw new Exception("Cannot unmarshal type BinEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BinEnum)untypedValue;
            if (value == BinEnum.Binned)
            {
                serializer.Serialize(writer, "binned");
                return;
            }
            throw new Exception("Cannot marshal type BinEnum");
        }

        public static readonly BinEnumConverter Singleton = new BinEnumConverter();
    }

    internal class ColorConditionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ColorCondition) || t == typeof(ColorCondition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<ConditionalPredicateMarkPropFieldDefClass>(reader);
                    return new ColorCondition { ConditionalPredicateMarkPropFieldDefClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<ConditionalValueDef[]>(reader);
                    return new ColorCondition { ConditionalValueDefArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ColorCondition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ColorCondition)untypedValue;
            if (value.ConditionalValueDefArray != null)
            {
                serializer.Serialize(writer, value.ConditionalValueDefArray);
                return;
            }
            if (value.ConditionalPredicateMarkPropFieldDefClass != null)
            {
                serializer.Serialize(writer, value.ConditionalPredicateMarkPropFieldDefClass);
                return;
            }
            throw new Exception("Cannot marshal type ColorCondition");
        }

        public static readonly ColorConditionConverter Singleton = new ColorConditionConverter();
    }

    internal class SelectionOperandConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SelectionOperand) || t == typeof(SelectionOperand?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new SelectionOperand { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Selection>(reader);
                    return new SelectionOperand { Selection = objectValue };
            }
            throw new Exception("Cannot unmarshal type SelectionOperand");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (SelectionOperand)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.Selection != null)
            {
                serializer.Serialize(writer, value.Selection);
                return;
            }
            throw new Exception("Cannot marshal type SelectionOperand");
        }

        public static readonly SelectionOperandConverter Singleton = new SelectionOperandConverter();
    }

    internal class LogicalOperandPredicateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LogicalOperandPredicate) || t == typeof(LogicalOperandPredicate?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new LogicalOperandPredicate { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Predicate>(reader);
                    return new LogicalOperandPredicate { Predicate = objectValue };
            }
            throw new Exception("Cannot unmarshal type LogicalOperandPredicate");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LogicalOperandPredicate)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.Predicate != null)
            {
                serializer.Serialize(writer, value.Predicate);
                return;
            }
            throw new Exception("Cannot marshal type LogicalOperandPredicate");
        }

        public static readonly LogicalOperandPredicateConverter Singleton = new LogicalOperandPredicateConverter();
    }

    internal class EqualConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Equal) || t == typeof(Equal?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Equal { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Equal { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Equal { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DateTime>(reader);
                    return new Equal { DateTime = objectValue };
            }
            throw new Exception("Cannot unmarshal type Equal");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Equal)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.DateTime != null)
            {
                serializer.Serialize(writer, value.DateTime);
                return;
            }
            throw new Exception("Cannot marshal type Equal");
        }

        public static readonly EqualConverter Singleton = new EqualConverter();
    }

    internal class DayConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Day) || t == typeof(Day?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Day { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Day { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Day");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Day)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type Day");
        }

        public static readonly DayConverter Singleton = new DayConverter();
    }

    internal class MonthConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Month) || t == typeof(Month?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Month { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Month { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Month");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Month)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type Month");
        }

        public static readonly MonthConverter Singleton = new MonthConverter();
    }

    internal class LtConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Lt) || t == typeof(Lt?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Lt { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Lt { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DateTime>(reader);
                    return new Lt { DateTime = objectValue };
            }
            throw new Exception("Cannot unmarshal type Lt");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Lt)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.DateTime != null)
            {
                serializer.Serialize(writer, value.DateTime);
                return;
            }
            throw new Exception("Cannot marshal type Lt");
        }

        public static readonly LtConverter Singleton = new LtConverter();
    }

    internal class PurpleRangeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurpleRange) || t == typeof(PurpleRange?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new PurpleRange { };
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new PurpleRange { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DateTime>(reader);
                    return new PurpleRange { DateTime = objectValue };
            }
            throw new Exception("Cannot unmarshal type PurpleRange");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PurpleRange)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.DateTime != null)
            {
                serializer.Serialize(writer, value.DateTime);
                return;
            }
            throw new Exception("Cannot marshal type PurpleRange");
        }

        public static readonly PurpleRangeConverter Singleton = new PurpleRangeConverter();
    }

    internal class TimeUnitConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TimeUnit) || t == typeof(TimeUnit?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "date":
                    return TimeUnit.Date;
                case "day":
                    return TimeUnit.Day;
                case "hours":
                    return TimeUnit.Hours;
                case "hoursminutes":
                    return TimeUnit.Hoursminutes;
                case "hoursminutesseconds":
                    return TimeUnit.Hoursminutesseconds;
                case "milliseconds":
                    return TimeUnit.Milliseconds;
                case "minutes":
                    return TimeUnit.Minutes;
                case "minutesseconds":
                    return TimeUnit.Minutesseconds;
                case "month":
                    return TimeUnit.Month;
                case "monthdate":
                    return TimeUnit.Monthdate;
                case "monthdatehours":
                    return TimeUnit.Monthdatehours;
                case "quarter":
                    return TimeUnit.Quarter;
                case "quartermonth":
                    return TimeUnit.Quartermonth;
                case "seconds":
                    return TimeUnit.Seconds;
                case "secondsmilliseconds":
                    return TimeUnit.Secondsmilliseconds;
                case "utcdate":
                    return TimeUnit.Utcdate;
                case "utcday":
                    return TimeUnit.Utcday;
                case "utchours":
                    return TimeUnit.Utchours;
                case "utchoursminutes":
                    return TimeUnit.Utchoursminutes;
                case "utchoursminutesseconds":
                    return TimeUnit.Utchoursminutesseconds;
                case "utcmilliseconds":
                    return TimeUnit.Utcmilliseconds;
                case "utcminutes":
                    return TimeUnit.Utcminutes;
                case "utcminutesseconds":
                    return TimeUnit.Utcminutesseconds;
                case "utcmonth":
                    return TimeUnit.Utcmonth;
                case "utcmonthdate":
                    return TimeUnit.Utcmonthdate;
                case "utcmonthdatehours":
                    return TimeUnit.Utcmonthdatehours;
                case "utcquarter":
                    return TimeUnit.Utcquarter;
                case "utcquartermonth":
                    return TimeUnit.Utcquartermonth;
                case "utcseconds":
                    return TimeUnit.Utcseconds;
                case "utcsecondsmilliseconds":
                    return TimeUnit.Utcsecondsmilliseconds;
                case "utcyear":
                    return TimeUnit.Utcyear;
                case "utcyearmonth":
                    return TimeUnit.Utcyearmonth;
                case "utcyearmonthdate":
                    return TimeUnit.Utcyearmonthdate;
                case "utcyearmonthdatehours":
                    return TimeUnit.Utcyearmonthdatehours;
                case "utcyearmonthdatehoursminutes":
                    return TimeUnit.Utcyearmonthdatehoursminutes;
                case "utcyearmonthdatehoursminutesseconds":
                    return TimeUnit.Utcyearmonthdatehoursminutesseconds;
                case "utcyearquarter":
                    return TimeUnit.Utcyearquarter;
                case "utcyearquartermonth":
                    return TimeUnit.Utcyearquartermonth;
                case "year":
                    return TimeUnit.Year;
                case "yearmonth":
                    return TimeUnit.Yearmonth;
                case "yearmonthdate":
                    return TimeUnit.Yearmonthdate;
                case "yearmonthdatehours":
                    return TimeUnit.Yearmonthdatehours;
                case "yearmonthdatehoursminutes":
                    return TimeUnit.Yearmonthdatehoursminutes;
                case "yearmonthdatehoursminutesseconds":
                    return TimeUnit.Yearmonthdatehoursminutesseconds;
                case "yearquarter":
                    return TimeUnit.Yearquarter;
                case "yearquartermonth":
                    return TimeUnit.Yearquartermonth;
            }
            throw new Exception("Cannot unmarshal type TimeUnit");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TimeUnit)untypedValue;
            switch (value)
            {
                case TimeUnit.Date:
                    serializer.Serialize(writer, "date");
                    return;
                case TimeUnit.Day:
                    serializer.Serialize(writer, "day");
                    return;
                case TimeUnit.Hours:
                    serializer.Serialize(writer, "hours");
                    return;
                case TimeUnit.Hoursminutes:
                    serializer.Serialize(writer, "hoursminutes");
                    return;
                case TimeUnit.Hoursminutesseconds:
                    serializer.Serialize(writer, "hoursminutesseconds");
                    return;
                case TimeUnit.Milliseconds:
                    serializer.Serialize(writer, "milliseconds");
                    return;
                case TimeUnit.Minutes:
                    serializer.Serialize(writer, "minutes");
                    return;
                case TimeUnit.Minutesseconds:
                    serializer.Serialize(writer, "minutesseconds");
                    return;
                case TimeUnit.Month:
                    serializer.Serialize(writer, "month");
                    return;
                case TimeUnit.Monthdate:
                    serializer.Serialize(writer, "monthdate");
                    return;
                case TimeUnit.Monthdatehours:
                    serializer.Serialize(writer, "monthdatehours");
                    return;
                case TimeUnit.Quarter:
                    serializer.Serialize(writer, "quarter");
                    return;
                case TimeUnit.Quartermonth:
                    serializer.Serialize(writer, "quartermonth");
                    return;
                case TimeUnit.Seconds:
                    serializer.Serialize(writer, "seconds");
                    return;
                case TimeUnit.Secondsmilliseconds:
                    serializer.Serialize(writer, "secondsmilliseconds");
                    return;
                case TimeUnit.Utcdate:
                    serializer.Serialize(writer, "utcdate");
                    return;
                case TimeUnit.Utcday:
                    serializer.Serialize(writer, "utcday");
                    return;
                case TimeUnit.Utchours:
                    serializer.Serialize(writer, "utchours");
                    return;
                case TimeUnit.Utchoursminutes:
                    serializer.Serialize(writer, "utchoursminutes");
                    return;
                case TimeUnit.Utchoursminutesseconds:
                    serializer.Serialize(writer, "utchoursminutesseconds");
                    return;
                case TimeUnit.Utcmilliseconds:
                    serializer.Serialize(writer, "utcmilliseconds");
                    return;
                case TimeUnit.Utcminutes:
                    serializer.Serialize(writer, "utcminutes");
                    return;
                case TimeUnit.Utcminutesseconds:
                    serializer.Serialize(writer, "utcminutesseconds");
                    return;
                case TimeUnit.Utcmonth:
                    serializer.Serialize(writer, "utcmonth");
                    return;
                case TimeUnit.Utcmonthdate:
                    serializer.Serialize(writer, "utcmonthdate");
                    return;
                case TimeUnit.Utcmonthdatehours:
                    serializer.Serialize(writer, "utcmonthdatehours");
                    return;
                case TimeUnit.Utcquarter:
                    serializer.Serialize(writer, "utcquarter");
                    return;
                case TimeUnit.Utcquartermonth:
                    serializer.Serialize(writer, "utcquartermonth");
                    return;
                case TimeUnit.Utcseconds:
                    serializer.Serialize(writer, "utcseconds");
                    return;
                case TimeUnit.Utcsecondsmilliseconds:
                    serializer.Serialize(writer, "utcsecondsmilliseconds");
                    return;
                case TimeUnit.Utcyear:
                    serializer.Serialize(writer, "utcyear");
                    return;
                case TimeUnit.Utcyearmonth:
                    serializer.Serialize(writer, "utcyearmonth");
                    return;
                case TimeUnit.Utcyearmonthdate:
                    serializer.Serialize(writer, "utcyearmonthdate");
                    return;
                case TimeUnit.Utcyearmonthdatehours:
                    serializer.Serialize(writer, "utcyearmonthdatehours");
                    return;
                case TimeUnit.Utcyearmonthdatehoursminutes:
                    serializer.Serialize(writer, "utcyearmonthdatehoursminutes");
                    return;
                case TimeUnit.Utcyearmonthdatehoursminutesseconds:
                    serializer.Serialize(writer, "utcyearmonthdatehoursminutesseconds");
                    return;
                case TimeUnit.Utcyearquarter:
                    serializer.Serialize(writer, "utcyearquarter");
                    return;
                case TimeUnit.Utcyearquartermonth:
                    serializer.Serialize(writer, "utcyearquartermonth");
                    return;
                case TimeUnit.Year:
                    serializer.Serialize(writer, "year");
                    return;
                case TimeUnit.Yearmonth:
                    serializer.Serialize(writer, "yearmonth");
                    return;
                case TimeUnit.Yearmonthdate:
                    serializer.Serialize(writer, "yearmonthdate");
                    return;
                case TimeUnit.Yearmonthdatehours:
                    serializer.Serialize(writer, "yearmonthdatehours");
                    return;
                case TimeUnit.Yearmonthdatehoursminutes:
                    serializer.Serialize(writer, "yearmonthdatehoursminutes");
                    return;
                case TimeUnit.Yearmonthdatehoursminutesseconds:
                    serializer.Serialize(writer, "yearmonthdatehoursminutesseconds");
                    return;
                case TimeUnit.Yearquarter:
                    serializer.Serialize(writer, "yearquarter");
                    return;
                case TimeUnit.Yearquartermonth:
                    serializer.Serialize(writer, "yearquartermonth");
                    return;
            }
            throw new Exception("Cannot marshal type TimeUnit");
        }

        public static readonly TimeUnitConverter Singleton = new TimeUnitConverter();
    }

    internal class ValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Value) || t == typeof(Value?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new Value { };
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Value { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Value { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Value { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Value");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Value)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type Value");
        }

        public static readonly ValueConverter Singleton = new ValueConverter();
    }

    internal class FieldConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Field) || t == typeof(Field?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Field { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<RepeatRef>(reader);
                    return new Field { RepeatRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type Field");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Field)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.RepeatRef != null)
            {
                serializer.Serialize(writer, value.RepeatRef);
                return;
            }
            throw new Exception("Cannot marshal type Field");
        }

        public static readonly FieldConverter Singleton = new FieldConverter();
    }

    internal class RepeatEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RepeatEnum) || t == typeof(RepeatEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "column":
                    return RepeatEnum.Column;
                case "row":
                    return RepeatEnum.Row;
            }
            throw new Exception("Cannot unmarshal type RepeatEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (RepeatEnum)untypedValue;
            switch (value)
            {
                case RepeatEnum.Column:
                    serializer.Serialize(writer, "column");
                    return;
                case RepeatEnum.Row:
                    serializer.Serialize(writer, "row");
                    return;
            }
            throw new Exception("Cannot marshal type RepeatEnum");
        }

        public static readonly RepeatEnumConverter Singleton = new RepeatEnumConverter();
    }

    internal class LegendTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LegendType) || t == typeof(LegendType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "gradient":
                    return LegendType.Gradient;
                case "symbol":
                    return LegendType.Symbol;
            }
            throw new Exception("Cannot unmarshal type LegendType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LegendType)untypedValue;
            switch (value)
            {
                case LegendType.Gradient:
                    serializer.Serialize(writer, "gradient");
                    return;
                case LegendType.Symbol:
                    serializer.Serialize(writer, "symbol");
                    return;
            }
            throw new Exception("Cannot marshal type LegendType");
        }

        public static readonly LegendTypeConverter Singleton = new LegendTypeConverter();
    }

    internal class DomainUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DomainUnion) || t == typeof(DomainUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue == "unaggregated")
                    {
                        return new DomainUnion { Enum = Domain.Unaggregated };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DomainClass>(reader);
                    return new DomainUnion { DomainClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<Equal[]>(reader);
                    return new DomainUnion { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type DomainUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DomainUnion)untypedValue;
            if (value.Enum != null)
            {
                if (value.Enum == Domain.Unaggregated)
                {
                    serializer.Serialize(writer, "unaggregated");
                    return;
                }
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.DomainClass != null)
            {
                serializer.Serialize(writer, value.DomainClass);
                return;
            }
            throw new Exception("Cannot marshal type DomainUnion");
        }

        public static readonly DomainUnionConverter Singleton = new DomainUnionConverter();
    }

    internal class DomainConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Domain) || t == typeof(Domain?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "unaggregated")
            {
                return Domain.Unaggregated;
            }
            throw new Exception("Cannot unmarshal type Domain");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Domain)untypedValue;
            if (value == Domain.Unaggregated)
            {
                serializer.Serialize(writer, "unaggregated");
                return;
            }
            throw new Exception("Cannot marshal type Domain");
        }

        public static readonly DomainConverter Singleton = new DomainConverter();
    }

    internal class InterpolateUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(InterpolateUnion) || t == typeof(InterpolateUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "cubehelix":
                            return new InterpolateUnion { Enum = ScaleInterpolate.Cubehelix };
                        case "cubehelix-long":
                            return new InterpolateUnion { Enum = ScaleInterpolate.CubehelixLong };
                        case "hcl":
                            return new InterpolateUnion { Enum = ScaleInterpolate.Hcl };
                        case "hcl-long":
                            return new InterpolateUnion { Enum = ScaleInterpolate.HclLong };
                        case "hsl":
                            return new InterpolateUnion { Enum = ScaleInterpolate.Hsl };
                        case "hsl-long":
                            return new InterpolateUnion { Enum = ScaleInterpolate.HslLong };
                        case "lab":
                            return new InterpolateUnion { Enum = ScaleInterpolate.Lab };
                        case "rgb":
                            return new InterpolateUnion { Enum = ScaleInterpolate.Rgb };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<ScaleInterpolateParams>(reader);
                    return new InterpolateUnion { ScaleInterpolateParams = objectValue };
            }
            throw new Exception("Cannot unmarshal type InterpolateUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (InterpolateUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case ScaleInterpolate.Cubehelix:
                        serializer.Serialize(writer, "cubehelix");
                        return;
                    case ScaleInterpolate.CubehelixLong:
                        serializer.Serialize(writer, "cubehelix-long");
                        return;
                    case ScaleInterpolate.Hcl:
                        serializer.Serialize(writer, "hcl");
                        return;
                    case ScaleInterpolate.HclLong:
                        serializer.Serialize(writer, "hcl-long");
                        return;
                    case ScaleInterpolate.Hsl:
                        serializer.Serialize(writer, "hsl");
                        return;
                    case ScaleInterpolate.HslLong:
                        serializer.Serialize(writer, "hsl-long");
                        return;
                    case ScaleInterpolate.Lab:
                        serializer.Serialize(writer, "lab");
                        return;
                    case ScaleInterpolate.Rgb:
                        serializer.Serialize(writer, "rgb");
                        return;
                }
            }
            if (value.ScaleInterpolateParams != null)
            {
                serializer.Serialize(writer, value.ScaleInterpolateParams);
                return;
            }
            throw new Exception("Cannot marshal type InterpolateUnion");
        }

        public static readonly InterpolateUnionConverter Singleton = new InterpolateUnionConverter();
    }

    internal class ScaleInterpolateParamsTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScaleInterpolateParamsType) || t == typeof(ScaleInterpolateParamsType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "cubehelix":
                    return ScaleInterpolateParamsType.Cubehelix;
                case "cubehelix-long":
                    return ScaleInterpolateParamsType.CubehelixLong;
                case "rgb":
                    return ScaleInterpolateParamsType.Rgb;
            }
            throw new Exception("Cannot unmarshal type ScaleInterpolateParamsType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ScaleInterpolateParamsType)untypedValue;
            switch (value)
            {
                case ScaleInterpolateParamsType.Cubehelix:
                    serializer.Serialize(writer, "cubehelix");
                    return;
                case ScaleInterpolateParamsType.CubehelixLong:
                    serializer.Serialize(writer, "cubehelix-long");
                    return;
                case ScaleInterpolateParamsType.Rgb:
                    serializer.Serialize(writer, "rgb");
                    return;
            }
            throw new Exception("Cannot marshal type ScaleInterpolateParamsType");
        }

        public static readonly ScaleInterpolateParamsTypeConverter Singleton = new ScaleInterpolateParamsTypeConverter();
    }

    internal class ScaleInterpolateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScaleInterpolate) || t == typeof(ScaleInterpolate?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "cubehelix":
                    return ScaleInterpolate.Cubehelix;
                case "cubehelix-long":
                    return ScaleInterpolate.CubehelixLong;
                case "hcl":
                    return ScaleInterpolate.Hcl;
                case "hcl-long":
                    return ScaleInterpolate.HclLong;
                case "hsl":
                    return ScaleInterpolate.Hsl;
                case "hsl-long":
                    return ScaleInterpolate.HslLong;
                case "lab":
                    return ScaleInterpolate.Lab;
                case "rgb":
                    return ScaleInterpolate.Rgb;
            }
            throw new Exception("Cannot unmarshal type ScaleInterpolate");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ScaleInterpolate)untypedValue;
            switch (value)
            {
                case ScaleInterpolate.Cubehelix:
                    serializer.Serialize(writer, "cubehelix");
                    return;
                case ScaleInterpolate.CubehelixLong:
                    serializer.Serialize(writer, "cubehelix-long");
                    return;
                case ScaleInterpolate.Hcl:
                    serializer.Serialize(writer, "hcl");
                    return;
                case ScaleInterpolate.HclLong:
                    serializer.Serialize(writer, "hcl-long");
                    return;
                case ScaleInterpolate.Hsl:
                    serializer.Serialize(writer, "hsl");
                    return;
                case ScaleInterpolate.HslLong:
                    serializer.Serialize(writer, "hsl-long");
                    return;
                case ScaleInterpolate.Lab:
                    serializer.Serialize(writer, "lab");
                    return;
                case ScaleInterpolate.Rgb:
                    serializer.Serialize(writer, "rgb");
                    return;
            }
            throw new Exception("Cannot marshal type ScaleInterpolate");
        }

        public static readonly ScaleInterpolateConverter Singleton = new ScaleInterpolateConverter();
    }

    internal class NiceUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(NiceUnion) || t == typeof(NiceUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new NiceUnion { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new NiceUnion { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "day":
                            return new NiceUnion { Enum = NiceTime.Day };
                        case "hour":
                            return new NiceUnion { Enum = NiceTime.Hour };
                        case "minute":
                            return new NiceUnion { Enum = NiceTime.Minute };
                        case "month":
                            return new NiceUnion { Enum = NiceTime.Month };
                        case "second":
                            return new NiceUnion { Enum = NiceTime.Second };
                        case "week":
                            return new NiceUnion { Enum = NiceTime.Week };
                        case "year":
                            return new NiceUnion { Enum = NiceTime.Year };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<NiceClass>(reader);
                    return new NiceUnion { NiceClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type NiceUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (NiceUnion)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case NiceTime.Day:
                        serializer.Serialize(writer, "day");
                        return;
                    case NiceTime.Hour:
                        serializer.Serialize(writer, "hour");
                        return;
                    case NiceTime.Minute:
                        serializer.Serialize(writer, "minute");
                        return;
                    case NiceTime.Month:
                        serializer.Serialize(writer, "month");
                        return;
                    case NiceTime.Second:
                        serializer.Serialize(writer, "second");
                        return;
                    case NiceTime.Week:
                        serializer.Serialize(writer, "week");
                        return;
                    case NiceTime.Year:
                        serializer.Serialize(writer, "year");
                        return;
                }
            }
            if (value.NiceClass != null)
            {
                serializer.Serialize(writer, value.NiceClass);
                return;
            }
            throw new Exception("Cannot marshal type NiceUnion");
        }

        public static readonly NiceUnionConverter Singleton = new NiceUnionConverter();
    }

    internal class NiceTimeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(NiceTime) || t == typeof(NiceTime?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "day":
                    return NiceTime.Day;
                case "hour":
                    return NiceTime.Hour;
                case "minute":
                    return NiceTime.Minute;
                case "month":
                    return NiceTime.Month;
                case "second":
                    return NiceTime.Second;
                case "week":
                    return NiceTime.Week;
                case "year":
                    return NiceTime.Year;
            }
            throw new Exception("Cannot unmarshal type NiceTime");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (NiceTime)untypedValue;
            switch (value)
            {
                case NiceTime.Day:
                    serializer.Serialize(writer, "day");
                    return;
                case NiceTime.Hour:
                    serializer.Serialize(writer, "hour");
                    return;
                case NiceTime.Minute:
                    serializer.Serialize(writer, "minute");
                    return;
                case NiceTime.Month:
                    serializer.Serialize(writer, "month");
                    return;
                case NiceTime.Second:
                    serializer.Serialize(writer, "second");
                    return;
                case NiceTime.Week:
                    serializer.Serialize(writer, "week");
                    return;
                case NiceTime.Year:
                    serializer.Serialize(writer, "year");
                    return;
            }
            throw new Exception("Cannot marshal type NiceTime");
        }

        public static readonly NiceTimeConverter Singleton = new NiceTimeConverter();
    }

    internal class ScaleRangeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScaleRange) || t == typeof(ScaleRange?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new ScaleRange { String = stringValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<RangeElement[]>(reader);
                    return new ScaleRange { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ScaleRange");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ScaleRange)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            throw new Exception("Cannot marshal type ScaleRange");
        }

        public static readonly ScaleRangeConverter Singleton = new ScaleRangeConverter();
    }

    internal class SchemeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Scheme) || t == typeof(Scheme?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Scheme { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<SchemeParams>(reader);
                    return new Scheme { SchemeParams = objectValue };
            }
            throw new Exception("Cannot unmarshal type Scheme");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Scheme)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.SchemeParams != null)
            {
                serializer.Serialize(writer, value.SchemeParams);
                return;
            }
            throw new Exception("Cannot marshal type Scheme");
        }

        public static readonly SchemeConverter Singleton = new SchemeConverter();
    }

    internal class ScaleTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScaleType) || t == typeof(ScaleType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "band":
                    return ScaleType.Band;
                case "bin-linear":
                    return ScaleType.BinLinear;
                case "bin-ordinal":
                    return ScaleType.BinOrdinal;
                case "linear":
                    return ScaleType.Linear;
                case "log":
                    return ScaleType.Log;
                case "ordinal":
                    return ScaleType.Ordinal;
                case "point":
                    return ScaleType.Point;
                case "pow":
                    return ScaleType.Pow;
                case "quantile":
                    return ScaleType.Quantile;
                case "quantize":
                    return ScaleType.Quantize;
                case "sequential":
                    return ScaleType.Sequential;
                case "sqrt":
                    return ScaleType.Sqrt;
                case "threshold":
                    return ScaleType.Threshold;
                case "time":
                    return ScaleType.Time;
                case "utc":
                    return ScaleType.Utc;
            }
            throw new Exception("Cannot unmarshal type ScaleType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ScaleType)untypedValue;
            switch (value)
            {
                case ScaleType.Band:
                    serializer.Serialize(writer, "band");
                    return;
                case ScaleType.BinLinear:
                    serializer.Serialize(writer, "bin-linear");
                    return;
                case ScaleType.BinOrdinal:
                    serializer.Serialize(writer, "bin-ordinal");
                    return;
                case ScaleType.Linear:
                    serializer.Serialize(writer, "linear");
                    return;
                case ScaleType.Log:
                    serializer.Serialize(writer, "log");
                    return;
                case ScaleType.Ordinal:
                    serializer.Serialize(writer, "ordinal");
                    return;
                case ScaleType.Point:
                    serializer.Serialize(writer, "point");
                    return;
                case ScaleType.Pow:
                    serializer.Serialize(writer, "pow");
                    return;
                case ScaleType.Quantile:
                    serializer.Serialize(writer, "quantile");
                    return;
                case ScaleType.Quantize:
                    serializer.Serialize(writer, "quantize");
                    return;
                case ScaleType.Sequential:
                    serializer.Serialize(writer, "sequential");
                    return;
                case ScaleType.Sqrt:
                    serializer.Serialize(writer, "sqrt");
                    return;
                case ScaleType.Threshold:
                    serializer.Serialize(writer, "threshold");
                    return;
                case ScaleType.Time:
                    serializer.Serialize(writer, "time");
                    return;
                case ScaleType.Utc:
                    serializer.Serialize(writer, "utc");
                    return;
            }
            throw new Exception("Cannot marshal type ScaleType");
        }

        public static readonly ScaleTypeConverter Singleton = new ScaleTypeConverter();
    }

    internal class SortConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Sort) || t == typeof(Sort?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new Sort { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "ascending":
                            return new Sort { Enum = VgComparatorOrder.Ascending };
                        case "descending":
                            return new Sort { Enum = VgComparatorOrder.Descending };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<EncodingSortField>(reader);
                    return new Sort { EncodingSortField = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<Equal[]>(reader);
                    return new Sort { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Sort");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Sort)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case VgComparatorOrder.Ascending:
                        serializer.Serialize(writer, "ascending");
                        return;
                    case VgComparatorOrder.Descending:
                        serializer.Serialize(writer, "descending");
                        return;
                }
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.EncodingSortField != null)
            {
                serializer.Serialize(writer, value.EncodingSortField);
                return;
            }
            throw new Exception("Cannot marshal type Sort");
        }

        public static readonly SortConverter Singleton = new SortConverter();
    }

    internal class VgComparatorOrderConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(VgComparatorOrder) || t == typeof(VgComparatorOrder?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ascending":
                    return VgComparatorOrder.Ascending;
                case "descending":
                    return VgComparatorOrder.Descending;
            }
            throw new Exception("Cannot unmarshal type VgComparatorOrder");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (VgComparatorOrder)untypedValue;
            switch (value)
            {
                case VgComparatorOrder.Ascending:
                    serializer.Serialize(writer, "ascending");
                    return;
                case VgComparatorOrder.Descending:
                    serializer.Serialize(writer, "descending");
                    return;
            }
            throw new Exception("Cannot marshal type VgComparatorOrder");
        }

        public static readonly VgComparatorOrderConverter Singleton = new VgComparatorOrderConverter();
    }

    internal class PurpleTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurpleType) || t == typeof(PurpleType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "geojson":
                    return PurpleType.Geojson;
                case "nominal":
                    return PurpleType.Nominal;
                case "ordinal":
                    return PurpleType.Ordinal;
                case "quantitative":
                    return PurpleType.Quantitative;
                case "temporal":
                    return PurpleType.Temporal;
            }
            throw new Exception("Cannot unmarshal type PurpleType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PurpleType)untypedValue;
            switch (value)
            {
                case PurpleType.Geojson:
                    serializer.Serialize(writer, "geojson");
                    return;
                case PurpleType.Nominal:
                    serializer.Serialize(writer, "nominal");
                    return;
                case PurpleType.Ordinal:
                    serializer.Serialize(writer, "ordinal");
                    return;
                case PurpleType.Quantitative:
                    serializer.Serialize(writer, "quantitative");
                    return;
                case PurpleType.Temporal:
                    serializer.Serialize(writer, "temporal");
                    return;
            }
            throw new Exception("Cannot marshal type PurpleType");
        }

        public static readonly PurpleTypeConverter Singleton = new PurpleTypeConverter();
    }

    internal class DetailConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Detail) || t == typeof(Detail?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FieldDef>(reader);
                    return new Detail { FieldDef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<FieldDef[]>(reader);
                    return new Detail { FieldDefArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Detail");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Detail)untypedValue;
            if (value.FieldDefArray != null)
            {
                serializer.Serialize(writer, value.FieldDefArray);
                return;
            }
            if (value.FieldDef != null)
            {
                serializer.Serialize(writer, value.FieldDef);
                return;
            }
            throw new Exception("Cannot marshal type Detail");
        }

        public static readonly DetailConverter Singleton = new DetailConverter();
    }

    internal class HrefConditionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HrefCondition) || t == typeof(HrefCondition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<ConditionalPredicateFieldDefClass>(reader);
                    return new HrefCondition { ConditionalPredicateFieldDefClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<ConditionalValueDef[]>(reader);
                    return new HrefCondition { ConditionalValueDefArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type HrefCondition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (HrefCondition)untypedValue;
            if (value.ConditionalValueDefArray != null)
            {
                serializer.Serialize(writer, value.ConditionalValueDefArray);
                return;
            }
            if (value.ConditionalPredicateFieldDefClass != null)
            {
                serializer.Serialize(writer, value.ConditionalPredicateFieldDefClass);
                return;
            }
            throw new Exception("Cannot marshal type HrefCondition");
        }

        public static readonly HrefConditionConverter Singleton = new HrefConditionConverter();
    }

    internal class OrderConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Order) || t == typeof(Order?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<OrderFieldDefClass>(reader);
                    return new Order { OrderFieldDefClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<OrderFieldDef[]>(reader);
                    return new Order { OrderFieldDefArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Order");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Order)untypedValue;
            if (value.OrderFieldDefArray != null)
            {
                serializer.Serialize(writer, value.OrderFieldDefArray);
                return;
            }
            if (value.OrderFieldDefClass != null)
            {
                serializer.Serialize(writer, value.OrderFieldDefClass);
                return;
            }
            throw new Exception("Cannot marshal type Order");
        }

        public static readonly OrderConverter Singleton = new OrderConverter();
    }

    internal class TextConditionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextCondition) || t == typeof(TextCondition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<ConditionalPredicateTextFieldDefClass>(reader);
                    return new TextCondition { ConditionalPredicateTextFieldDefClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<ConditionalValueDef[]>(reader);
                    return new TextCondition { ConditionalValueDefArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TextCondition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TextCondition)untypedValue;
            if (value.ConditionalValueDefArray != null)
            {
                serializer.Serialize(writer, value.ConditionalValueDefArray);
                return;
            }
            if (value.ConditionalPredicateTextFieldDefClass != null)
            {
                serializer.Serialize(writer, value.ConditionalPredicateTextFieldDefClass);
                return;
            }
            throw new Exception("Cannot marshal type TextCondition");
        }

        public static readonly TextConditionConverter Singleton = new TextConditionConverter();
    }

    internal class TooltipUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TooltipUnion) || t == typeof(TooltipUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TextFieldDefWithCondition>(reader);
                    return new TooltipUnion { TextFieldDefWithCondition = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<TextFieldDef[]>(reader);
                    return new TooltipUnion { TextFieldDefArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TooltipUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TooltipUnion)untypedValue;
            if (value.TextFieldDefArray != null)
            {
                serializer.Serialize(writer, value.TextFieldDefArray);
                return;
            }
            if (value.TextFieldDefWithCondition != null)
            {
                serializer.Serialize(writer, value.TextFieldDefWithCondition);
                return;
            }
            throw new Exception("Cannot marshal type TooltipUnion");
        }

        public static readonly TooltipUnionConverter Singleton = new TooltipUnionConverter();
    }

    internal class AxisOrientConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AxisOrient) || t == typeof(AxisOrient?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bottom":
                    return AxisOrient.Bottom;
                case "left":
                    return AxisOrient.Left;
                case "right":
                    return AxisOrient.Right;
                case "top":
                    return AxisOrient.Top;
            }
            throw new Exception("Cannot unmarshal type AxisOrient");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AxisOrient)untypedValue;
            switch (value)
            {
                case AxisOrient.Bottom:
                    serializer.Serialize(writer, "bottom");
                    return;
                case AxisOrient.Left:
                    serializer.Serialize(writer, "left");
                    return;
                case AxisOrient.Right:
                    serializer.Serialize(writer, "right");
                    return;
                case AxisOrient.Top:
                    serializer.Serialize(writer, "top");
                    return;
            }
            throw new Exception("Cannot marshal type AxisOrient");
        }

        public static readonly AxisOrientConverter Singleton = new AxisOrientConverter();
    }

    internal class KeyvalsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Keyvals) || t == typeof(Keyvals?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<ImputeSequence>(reader);
                    return new Keyvals { ImputeSequence = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<object[]>(reader);
                    return new Keyvals { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Keyvals");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Keyvals)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.ImputeSequence != null)
            {
                serializer.Serialize(writer, value.ImputeSequence);
                return;
            }
            throw new Exception("Cannot marshal type Keyvals");
        }

        public static readonly KeyvalsConverter Singleton = new KeyvalsConverter();
    }

    internal class ImputeMethodConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ImputeMethod) || t == typeof(ImputeMethod?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "max":
                    return ImputeMethod.Max;
                case "mean":
                    return ImputeMethod.Mean;
                case "median":
                    return ImputeMethod.Median;
                case "min":
                    return ImputeMethod.Min;
                case "value":
                    return ImputeMethod.Value;
            }
            throw new Exception("Cannot unmarshal type ImputeMethod");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ImputeMethod)untypedValue;
            switch (value)
            {
                case ImputeMethod.Max:
                    serializer.Serialize(writer, "max");
                    return;
                case ImputeMethod.Mean:
                    serializer.Serialize(writer, "mean");
                    return;
                case ImputeMethod.Median:
                    serializer.Serialize(writer, "median");
                    return;
                case ImputeMethod.Min:
                    serializer.Serialize(writer, "min");
                    return;
                case ImputeMethod.Value:
                    serializer.Serialize(writer, "value");
                    return;
            }
            throw new Exception("Cannot marshal type ImputeMethod");
        }

        public static readonly ImputeMethodConverter Singleton = new ImputeMethodConverter();
    }

    internal class AnyMarkConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AnyMark) || t == typeof(AnyMark?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "area":
                            return new AnyMark { Enum = BoxPlot.Area };
                        case "bar":
                            return new AnyMark { Enum = BoxPlot.Bar };
                        case "boxplot":
                            return new AnyMark { Enum = BoxPlot.Boxplot };
                        case "circle":
                            return new AnyMark { Enum = BoxPlot.Circle };
                        case "errorband":
                            return new AnyMark { Enum = BoxPlot.Errorband };
                        case "errorbar":
                            return new AnyMark { Enum = BoxPlot.Errorbar };
                        case "geoshape":
                            return new AnyMark { Enum = BoxPlot.Geoshape };
                        case "line":
                            return new AnyMark { Enum = BoxPlot.Line };
                        case "point":
                            return new AnyMark { Enum = BoxPlot.Point };
                        case "rect":
                            return new AnyMark { Enum = BoxPlot.Rect };
                        case "rule":
                            return new AnyMark { Enum = BoxPlot.Rule };
                        case "square":
                            return new AnyMark { Enum = BoxPlot.Square };
                        case "text":
                            return new AnyMark { Enum = BoxPlot.Text };
                        case "tick":
                            return new AnyMark { Enum = BoxPlot.Tick };
                        case "trail":
                            return new AnyMark { Enum = BoxPlot.Trail };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BoxPlotDefClass>(reader);
                    return new AnyMark { BoxPlotDefClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type AnyMark");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AnyMark)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case BoxPlot.Area:
                        serializer.Serialize(writer, "area");
                        return;
                    case BoxPlot.Bar:
                        serializer.Serialize(writer, "bar");
                        return;
                    case BoxPlot.Boxplot:
                        serializer.Serialize(writer, "boxplot");
                        return;
                    case BoxPlot.Circle:
                        serializer.Serialize(writer, "circle");
                        return;
                    case BoxPlot.Errorband:
                        serializer.Serialize(writer, "errorband");
                        return;
                    case BoxPlot.Errorbar:
                        serializer.Serialize(writer, "errorbar");
                        return;
                    case BoxPlot.Geoshape:
                        serializer.Serialize(writer, "geoshape");
                        return;
                    case BoxPlot.Line:
                        serializer.Serialize(writer, "line");
                        return;
                    case BoxPlot.Point:
                        serializer.Serialize(writer, "point");
                        return;
                    case BoxPlot.Rect:
                        serializer.Serialize(writer, "rect");
                        return;
                    case BoxPlot.Rule:
                        serializer.Serialize(writer, "rule");
                        return;
                    case BoxPlot.Square:
                        serializer.Serialize(writer, "square");
                        return;
                    case BoxPlot.Text:
                        serializer.Serialize(writer, "text");
                        return;
                    case BoxPlot.Tick:
                        serializer.Serialize(writer, "tick");
                        return;
                    case BoxPlot.Trail:
                        serializer.Serialize(writer, "trail");
                        return;
                }
            }
            if (value.BoxPlotDefClass != null)
            {
                serializer.Serialize(writer, value.BoxPlotDefClass);
                return;
            }
            throw new Exception("Cannot marshal type AnyMark");
        }

        public static readonly AnyMarkConverter Singleton = new AnyMarkConverter();
    }

    internal class BoxPlotDefExtentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BoxPlotDefExtent) || t == typeof(BoxPlotDefExtent?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new BoxPlotDefExtent { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "ci":
                            return new BoxPlotDefExtent { Enum = ExtentExtent.Ci };
                        case "iqr":
                            return new BoxPlotDefExtent { Enum = ExtentExtent.Iqr };
                        case "min-max":
                            return new BoxPlotDefExtent { Enum = ExtentExtent.MinMax };
                        case "stderr":
                            return new BoxPlotDefExtent { Enum = ExtentExtent.Stderr };
                        case "stdev":
                            return new BoxPlotDefExtent { Enum = ExtentExtent.Stdev };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type BoxPlotDefExtent");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BoxPlotDefExtent)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case ExtentExtent.Ci:
                        serializer.Serialize(writer, "ci");
                        return;
                    case ExtentExtent.Iqr:
                        serializer.Serialize(writer, "iqr");
                        return;
                    case ExtentExtent.MinMax:
                        serializer.Serialize(writer, "min-max");
                        return;
                    case ExtentExtent.Stderr:
                        serializer.Serialize(writer, "stderr");
                        return;
                    case ExtentExtent.Stdev:
                        serializer.Serialize(writer, "stdev");
                        return;
                }
            }
            throw new Exception("Cannot marshal type BoxPlotDefExtent");
        }

        public static readonly BoxPlotDefExtentConverter Singleton = new BoxPlotDefExtentConverter();
    }

    internal class ExtentExtentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ExtentExtent) || t == typeof(ExtentExtent?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ci":
                    return ExtentExtent.Ci;
                case "iqr":
                    return ExtentExtent.Iqr;
                case "min-max":
                    return ExtentExtent.MinMax;
                case "stderr":
                    return ExtentExtent.Stderr;
                case "stdev":
                    return ExtentExtent.Stdev;
            }
            throw new Exception("Cannot unmarshal type ExtentExtent");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ExtentExtent)untypedValue;
            switch (value)
            {
                case ExtentExtent.Ci:
                    serializer.Serialize(writer, "ci");
                    return;
                case ExtentExtent.Iqr:
                    serializer.Serialize(writer, "iqr");
                    return;
                case ExtentExtent.MinMax:
                    serializer.Serialize(writer, "min-max");
                    return;
                case ExtentExtent.Stderr:
                    serializer.Serialize(writer, "stderr");
                    return;
                case ExtentExtent.Stdev:
                    serializer.Serialize(writer, "stdev");
                    return;
            }
            throw new Exception("Cannot marshal type ExtentExtent");
        }

        public static readonly ExtentExtentConverter Singleton = new ExtentExtentConverter();
    }

    internal class BoxPlotConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BoxPlot) || t == typeof(BoxPlot?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "area":
                    return BoxPlot.Area;
                case "bar":
                    return BoxPlot.Bar;
                case "boxplot":
                    return BoxPlot.Boxplot;
                case "circle":
                    return BoxPlot.Circle;
                case "errorband":
                    return BoxPlot.Errorband;
                case "errorbar":
                    return BoxPlot.Errorbar;
                case "geoshape":
                    return BoxPlot.Geoshape;
                case "line":
                    return BoxPlot.Line;
                case "point":
                    return BoxPlot.Point;
                case "rect":
                    return BoxPlot.Rect;
                case "rule":
                    return BoxPlot.Rule;
                case "square":
                    return BoxPlot.Square;
                case "text":
                    return BoxPlot.Text;
                case "tick":
                    return BoxPlot.Tick;
                case "trail":
                    return BoxPlot.Trail;
            }
            throw new Exception("Cannot unmarshal type BoxPlot");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BoxPlot)untypedValue;
            switch (value)
            {
                case BoxPlot.Area:
                    serializer.Serialize(writer, "area");
                    return;
                case BoxPlot.Bar:
                    serializer.Serialize(writer, "bar");
                    return;
                case BoxPlot.Boxplot:
                    serializer.Serialize(writer, "boxplot");
                    return;
                case BoxPlot.Circle:
                    serializer.Serialize(writer, "circle");
                    return;
                case BoxPlot.Errorband:
                    serializer.Serialize(writer, "errorband");
                    return;
                case BoxPlot.Errorbar:
                    serializer.Serialize(writer, "errorbar");
                    return;
                case BoxPlot.Geoshape:
                    serializer.Serialize(writer, "geoshape");
                    return;
                case BoxPlot.Line:
                    serializer.Serialize(writer, "line");
                    return;
                case BoxPlot.Point:
                    serializer.Serialize(writer, "point");
                    return;
                case BoxPlot.Rect:
                    serializer.Serialize(writer, "rect");
                    return;
                case BoxPlot.Rule:
                    serializer.Serialize(writer, "rule");
                    return;
                case BoxPlot.Square:
                    serializer.Serialize(writer, "square");
                    return;
                case BoxPlot.Text:
                    serializer.Serialize(writer, "text");
                    return;
                case BoxPlot.Tick:
                    serializer.Serialize(writer, "tick");
                    return;
                case BoxPlot.Trail:
                    serializer.Serialize(writer, "trail");
                    return;
            }
            throw new Exception("Cannot marshal type BoxPlot");
        }

        public static readonly BoxPlotConverter Singleton = new BoxPlotConverter();
    }

    internal class ResolveModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ResolveMode) || t == typeof(ResolveMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "independent":
                    return ResolveMode.Independent;
                case "shared":
                    return ResolveMode.Shared;
            }
            throw new Exception("Cannot unmarshal type ResolveMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ResolveMode)untypedValue;
            switch (value)
            {
                case ResolveMode.Independent:
                    serializer.Serialize(writer, "independent");
                    return;
                case ResolveMode.Shared:
                    serializer.Serialize(writer, "shared");
                    return;
            }
            throw new Exception("Cannot marshal type ResolveMode");
        }

        public static readonly ResolveModeConverter Singleton = new ResolveModeConverter();
    }

    internal class SelectionDefBindConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SelectionDefBind) || t == typeof(SelectionDefBind?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue == "scales")
                    {
                        return new SelectionDefBind { Enum = BindEnum.Scales };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Dictionary<string, BindValue>>(reader);
                    return new SelectionDefBind { AnythingMap = objectValue };
            }
            throw new Exception("Cannot unmarshal type SelectionDefBind");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (SelectionDefBind)untypedValue;
            if (value.Enum != null)
            {
                if (value.Enum == BindEnum.Scales)
                {
                    serializer.Serialize(writer, "scales");
                    return;
                }
            }
            if (value.AnythingMap != null)
            {
                serializer.Serialize(writer, value.AnythingMap);
                return;
            }
            throw new Exception("Cannot marshal type SelectionDefBind");
        }

        public static readonly SelectionDefBindConverter Singleton = new SelectionDefBindConverter();
    }

    internal class SelectionDefTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SelectionDefType) || t == typeof(SelectionDefType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "interval":
                    return SelectionDefType.Interval;
                case "multi":
                    return SelectionDefType.Multi;
                case "single":
                    return SelectionDefType.Single;
            }
            throw new Exception("Cannot unmarshal type SelectionDefType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SelectionDefType)untypedValue;
            switch (value)
            {
                case SelectionDefType.Interval:
                    serializer.Serialize(writer, "interval");
                    return;
                case SelectionDefType.Multi:
                    serializer.Serialize(writer, "multi");
                    return;
                case SelectionDefType.Single:
                    serializer.Serialize(writer, "single");
                    return;
            }
            throw new Exception("Cannot marshal type SelectionDefType");
        }

        public static readonly SelectionDefTypeConverter Singleton = new SelectionDefTypeConverter();
    }

    internal class TitleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Title) || t == typeof(Title?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Title { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TitleParams>(reader);
                    return new Title { TitleParams = objectValue };
            }
            throw new Exception("Cannot unmarshal type Title");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Title)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.TitleParams != null)
            {
                serializer.Serialize(writer, value.TitleParams);
                return;
            }
            throw new Exception("Cannot marshal type Title");
        }

        public static readonly TitleConverter Singleton = new TitleConverter();
    }

    internal class TransformBinConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TransformBin) || t == typeof(TransformBin?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new TransformBin { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BinParams>(reader);
                    return new TransformBin { BinParams = objectValue };
            }
            throw new Exception("Cannot unmarshal type TransformBin");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TransformBin)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.BinParams != null)
            {
                serializer.Serialize(writer, value.BinParams);
                return;
            }
            throw new Exception("Cannot marshal type TransformBin");
        }

        public static readonly TransformBinConverter Singleton = new TransformBinConverter();
    }

    internal class OpConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Op) || t == typeof(Op?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "argmax":
                    return Op.Argmax;
                case "argmin":
                    return Op.Argmin;
                case "average":
                    return Op.Average;
                case "ci0":
                    return Op.Ci0;
                case "ci1":
                    return Op.Ci1;
                case "count":
                    return Op.Count;
                case "cume_dist":
                    return Op.CumeDist;
                case "dense_rank":
                    return Op.DenseRank;
                case "distinct":
                    return Op.Distinct;
                case "first_value":
                    return Op.FirstValue;
                case "lag":
                    return Op.Lag;
                case "last_value":
                    return Op.LastValue;
                case "lead":
                    return Op.Lead;
                case "max":
                    return Op.Max;
                case "mean":
                    return Op.Mean;
                case "median":
                    return Op.Median;
                case "min":
                    return Op.Min;
                case "missing":
                    return Op.Missing;
                case "nth_value":
                    return Op.NthValue;
                case "ntile":
                    return Op.Ntile;
                case "percent_rank":
                    return Op.PercentRank;
                case "q1":
                    return Op.Q1;
                case "q3":
                    return Op.Q3;
                case "rank":
                    return Op.Rank;
                case "row_number":
                    return Op.RowNumber;
                case "stderr":
                    return Op.Stderr;
                case "stdev":
                    return Op.Stdev;
                case "stdevp":
                    return Op.Stdevp;
                case "sum":
                    return Op.Sum;
                case "valid":
                    return Op.Valid;
                case "values":
                    return Op.Values;
                case "variance":
                    return Op.Variance;
                case "variancep":
                    return Op.Variancep;
            }
            throw new Exception("Cannot unmarshal type Op");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Op)untypedValue;
            switch (value)
            {
                case Op.Argmax:
                    serializer.Serialize(writer, "argmax");
                    return;
                case Op.Argmin:
                    serializer.Serialize(writer, "argmin");
                    return;
                case Op.Average:
                    serializer.Serialize(writer, "average");
                    return;
                case Op.Ci0:
                    serializer.Serialize(writer, "ci0");
                    return;
                case Op.Ci1:
                    serializer.Serialize(writer, "ci1");
                    return;
                case Op.Count:
                    serializer.Serialize(writer, "count");
                    return;
                case Op.CumeDist:
                    serializer.Serialize(writer, "cume_dist");
                    return;
                case Op.DenseRank:
                    serializer.Serialize(writer, "dense_rank");
                    return;
                case Op.Distinct:
                    serializer.Serialize(writer, "distinct");
                    return;
                case Op.FirstValue:
                    serializer.Serialize(writer, "first_value");
                    return;
                case Op.Lag:
                    serializer.Serialize(writer, "lag");
                    return;
                case Op.LastValue:
                    serializer.Serialize(writer, "last_value");
                    return;
                case Op.Lead:
                    serializer.Serialize(writer, "lead");
                    return;
                case Op.Max:
                    serializer.Serialize(writer, "max");
                    return;
                case Op.Mean:
                    serializer.Serialize(writer, "mean");
                    return;
                case Op.Median:
                    serializer.Serialize(writer, "median");
                    return;
                case Op.Min:
                    serializer.Serialize(writer, "min");
                    return;
                case Op.Missing:
                    serializer.Serialize(writer, "missing");
                    return;
                case Op.NthValue:
                    serializer.Serialize(writer, "nth_value");
                    return;
                case Op.Ntile:
                    serializer.Serialize(writer, "ntile");
                    return;
                case Op.PercentRank:
                    serializer.Serialize(writer, "percent_rank");
                    return;
                case Op.Q1:
                    serializer.Serialize(writer, "q1");
                    return;
                case Op.Q3:
                    serializer.Serialize(writer, "q3");
                    return;
                case Op.Rank:
                    serializer.Serialize(writer, "rank");
                    return;
                case Op.RowNumber:
                    serializer.Serialize(writer, "row_number");
                    return;
                case Op.Stderr:
                    serializer.Serialize(writer, "stderr");
                    return;
                case Op.Stdev:
                    serializer.Serialize(writer, "stdev");
                    return;
                case Op.Stdevp:
                    serializer.Serialize(writer, "stdevp");
                    return;
                case Op.Sum:
                    serializer.Serialize(writer, "sum");
                    return;
                case Op.Valid:
                    serializer.Serialize(writer, "valid");
                    return;
                case Op.Values:
                    serializer.Serialize(writer, "values");
                    return;
                case Op.Variance:
                    serializer.Serialize(writer, "variance");
                    return;
                case Op.Variancep:
                    serializer.Serialize(writer, "variancep");
                    return;
            }
            throw new Exception("Cannot marshal type Op");
        }

        public static readonly OpConverter Singleton = new OpConverter();
    }

    internal class SpacingConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Spacing) || t == typeof(Spacing?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Spacing { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<RowColNumber>(reader);
                    return new Spacing { RowColNumber = objectValue };
            }
            throw new Exception("Cannot unmarshal type Spacing");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Spacing)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.RowColNumber != null)
            {
                serializer.Serialize(writer, value.RowColNumber);
                return;
            }
            throw new Exception("Cannot marshal type Spacing");
        }

        public static readonly SpacingConverter Singleton = new SpacingConverter();
    }
}
